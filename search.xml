<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django Model Relationship</title>
    <url>/2019/11/04/Django_Model_Relationship/</url>
    <content><![CDATA[<p><em>好久没写了，这次用阴阳师来举例子。</em></p>
<h2 id="Django-Model的三种Relationship"><a href="#Django-Model的三种Relationship" class="headerlink" title="Django Model的三种Relationship"></a>Django Model的三种Relationship</h2><ol>
<li>一对一 (关键词 <strong>OneToOneField</strong>)</li>
<li>一对多 (关键词 <strong>ForeignKey</strong>) <em>没有OneToManyField这种写法</em></li>
<li>多对多 (关键词 <strong>ManyToManyField</strong>)</li>
</ol>
<a id="more"></a>

<h2 id="代码和关系"><a href="#代码和关系" class="headerlink" title="代码和关系"></a>代码和关系</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义稀有度，五个等级，n r sr ssr sp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rare</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    N = <span class="string">&#x27;n&#x27;</span></span><br><span class="line">    R = <span class="string">&#x27;r&#x27;</span></span><br><span class="line">    SR = <span class="string">&#x27;sr&#x27;</span></span><br><span class="line">    SSR = <span class="string">&#x27;ssr&#x27;</span></span><br><span class="line">    SP = <span class="string">&#x27;sp&#x27;</span></span><br><span class="line"></span><br><span class="line">    LEVEL_CHOICES = [</span><br><span class="line">        (N,<span class="string">&#x27;N&#x27;</span>),</span><br><span class="line">        (R,<span class="string">&#x27;R&#x27;</span>),</span><br><span class="line">        (SR,<span class="string">&#x27;SR&#x27;</span>),</span><br><span class="line">        (SSR,<span class="string">&#x27;SSR&#x27;</span>),</span><br><span class="line">        (SP,<span class="string">&#x27;SP&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># one to one relationship with formula</span></span><br><span class="line"></span><br><span class="line">    level = models.CharField(max_length=<span class="number">4</span>, choices=LEVEL_CHOICES,default=SSR,unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义式神名称</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Formula</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 一对多定义</span></span><br><span class="line">    rare = models.ForeignKey(Rare, on_delete=models.CASCADE)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>, unique=<span class="literal">True</span>, primary_key = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义cp字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lover</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 一对一定义</span></span><br><span class="line">    formula = models.OneToOneField(Formula, on_delete=models.SET_NULL,null=<span class="literal">True</span>)</span><br><span class="line">    lover_name = models.CharField(max_length=<span class="number">10</span>,unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lover_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义御魂套字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soul</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 多对多定义</span></span><br><span class="line">    formula = models.ManyToManyField(Formula)</span><br><span class="line">    <span class="comment"># 御魂套名称</span></span><br><span class="line">    <span class="built_in">set</span> = models.CharField(max_length=<span class="number">10</span>,unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<ol>
<li>式神和其cp为<strong>一对一</strong>关系，酒吞置于红叶，鲤鱼精至于河童。</li>
<li>稀有度和式神为<strong>一对多</strong>关系。 一个种稀有度能对应多个式神，但一个式神只能有一种稀有度。</li>
<li>御魂套和式神为<strong>多对多</strong>关系。一套御魂可以给多个式神使用，一个式神也可以使用多套御魂。</li>
</ol>
<h2 id="给数据库创建一些数据"><a href="#给数据库创建一些数据" class="headerlink" title="给数据库创建一些数据"></a>给数据库创建一些数据</h2><h3 id="创建的方法"><a href="#创建的方法" class="headerlink" title="创建的方法"></a>创建的方法</h3><ol>
<li>使用对象属性来创建</li>
<li>使用objects来创建</li>
</ol>
<h4 id="使用对象属性创建"><a href="#使用对象属性创建" class="headerlink" title="使用对象属性创建"></a>使用对象属性创建</h4><p><strong>如果是创建自身的数据，则对象要调用save()，如果是创建关联性数据，则无需调用save()</strong></p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line">创建了稀有度为n的数据</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="keyword">from</span> onmyoji_models.models <span class="keyword">import</span> *</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">n = Rare(level=<span class="string">&#x27;n&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">n.save()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">Rare.objects.<span class="built_in">all</span>()</span></span><br><span class="line">&lt;QuerySet [&lt;Rare: n&gt;]&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用objects来创建"><a href="#使用objects来创建" class="headerlink" title="使用objects来创建"></a>使用objects来创建</h4><p><strong>使用objects来创建无需调用save()</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Rare.objects.create(level=&#x27;sr&#x27;)</span><br><span class="line">&lt;Rare: sr&gt;</span><br><span class="line">&gt;&gt;&gt; Rare.objects.all()</span><br><span class="line">&lt;QuerySet <span class="meta">[&lt;Rare: n&gt;, &lt;Rare: sr&gt;]</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="我该把关键词写在哪里"><a href="#我该把关键词写在哪里" class="headerlink" title="我该把关键词写在哪里"></a>我该把关键词写在哪里</h2><ol>
<li>OneToOneField，一对一的情况，随便写。</li>
<li>ForeignKey，一对多的情况，写在<strong>多的一方</strong>，一种稀有度对应多个式神，所以ForeignKey定义在式神上，也就是class Formula上。</li>
<li>ManyToManyField，多对多的情况，任意写。</li>
<li>建议将字段命名为关联class的小写，比如一对多，在class Formula需要定义一个ForeignKey字段和class Rare关联，则该字段名为’rare’。</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">rare</span> = models.ForeignKey(Rare, <span class="literal">on</span>_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<h2 id="三种关系的例子和相互读取"><a href="#三种关系的例子和相互读取" class="headerlink" title="三种关系的例子和相互读取"></a>三种关系的例子和相互读取</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>用酒吞和红叶举例子。</p>
<p>先创建酒吞，因为Formula有个rare字段的是关联了class Rare，所以要先获取rare的instance对象，将对象赋值给rare，然后创建酒吞。</p>
<p><strong>这边要注意的是，如果获取instance对象，则需要用到get()方法，倘若使用的是filter()，则获取的是一个query set对象，是不能够给rare赋值的。</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ssr = Rare.objects.<span class="builtin-name">get</span>(<span class="attribute">level</span>=<span class="string">&#x27;ssr&#x27;</span>)</span><br><span class="line">Formula.objects.create(<span class="attribute">name</span>=<span class="string">&#x27;JiuTun&#x27;</span>,rare=ssr)</span><br><span class="line">&lt;Formula: JiuTun&gt;</span><br></pre></td></tr></table></figure>
<p>接着在Lover中创建红叶。formula是个传入的对象，所以先get()获取到酒吞</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; jiutun = Formula.objects.<span class="builtin-name">get</span>(<span class="attribute">name</span>=<span class="string">&#x27;JiuTun&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; Lover.objects.create(<span class="attribute">lover_name</span>=<span class="string">&#x27;HongYe&#x27;</span>,formula=jiutun)</span><br><span class="line">&lt;Lover: HongYe&gt;</span><br></pre></td></tr></table></figure>
<p>相互之间访问数据</p>
<ol>
<li>Formula到Lover</li>
</ol>
<ul>
<li><p>对象属性方式，formula对象直接访问lover的lover_name字段</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; jiutun = Formula.objects.<span class="builtin-name">get</span>(<span class="attribute">name</span>=<span class="string">&#x27;JiuTun&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; jiutun.lover.lover_name</span><br><span class="line"><span class="string">&#x27;HongYe&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>objects的方式,传入的formula是instance对象</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; jiutun = Formula.objects.<span class="builtin-name">get</span>(<span class="attribute">name</span>=<span class="string">&#x27;JiuTun&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; Lover.objects.<span class="builtin-name">get</span>(<span class="attribute">formula</span>=jiutun)</span><br><span class="line">&lt;Lover: HongYe&gt;</span><br><span class="line">&gt;&gt;&gt; Lover.objects.<span class="builtin-name">get</span>(<span class="attribute">formula</span>=jiutun).lover_name</span><br><span class="line"><span class="string">&#x27;HongYe&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>Lover到Formula</li>
</ol>
<ul>
<li>对象属性方式，访问formula的name字段<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hongye = Lover.objects.<span class="builtin-name">get</span>(<span class="attribute">lover_name</span>=<span class="string">&#x27;HongYe&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; hongye.formula.name</span><br><span class="line"><span class="string">&#x27;JiuTun&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>objects的方式，传入的lover是instance对象<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Formula.objects.<span class="builtin-name">get</span>(<span class="attribute">lover</span>=hongye)</span><br><span class="line">&lt;Formula: JiuTun&gt;</span><br><span class="line">&gt;&gt;&gt; Formula.objects.<span class="builtin-name">get</span>(<span class="attribute">lover</span>=hongye).name</span><br><span class="line"><span class="string">&#x27;JiuTun&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3></li>
</ul>
<p>通过对象属性的方式给给Formula添加鬼切式神。</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">guiqie = Formula(name=<span class="string">&#x27;GuiQie&#x27;</span>, rare=ssr)</span></span><br><span class="line">&lt;Formula: GuiQie&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">guiqie.save()</span></span><br></pre></td></tr></table></figure>
<p>此时数据库内有数据了，formula为Guiqie,其rare为ssr。</p>
<p>相互之间访问数据</p>
<ol>
<li>从多(Formula)到一(Rare)</li>
</ol>
<ul>
<li><p>对象属性方式</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; formula = Formula.objects.<span class="builtin-name">get</span>(<span class="attribute">name</span>=<span class="string">&#x27;GuiQie&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; formula.rare.level</span><br><span class="line"><span class="string">&#x27;ssr&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>objects方式,访问Rare的level字段</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Rare.objects.<span class="builtin-name">get</span>(<span class="attribute">formula</span>=formula)</span><br><span class="line">&lt;Rare: ssr&gt;</span><br><span class="line">&gt;&gt;&gt; Rare.objects.<span class="builtin-name">get</span>(<span class="attribute">formula</span>=formula).level</span><br><span class="line"><span class="string">&#x27;ssr&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>从一(Rare)到多(Formula)</li>
</ol>
<p>因为访问多，所以属性方法访问要用_set，objects对象访问则建议用filter()，因为get()遇到大于1个数据会报错。<br>因为是访问的多，所以得到结果是query set类型，访问具体数据，需要迭代进行访问。</p>
<ul>
<li>对象属性方式<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">ssr = Rare.objects.get(level=<span class="string">&#x27;ssr&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">ssr.formula_set.<span class="built_in">all</span>()</span></span><br><span class="line">&lt;QuerySet [&lt;Formula: GuiQie&gt;, &lt;Formula: CiMuTongZi&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="keyword">for</span> i <span class="keyword">in</span> ssr.formula_set.<span class="built_in">all</span>():</span></span><br><span class="line"><span class="meta">...</span> <span class="python">    print(i)</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line">GuiQie</span><br><span class="line">CiMuTongZi</span><br></pre></td></tr></table></figure></li>
<li>objects方式<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">ssr = Rare.objects.get(level=<span class="string">&#x27;ssr&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">formulas = Formula.objects.<span class="built_in">filter</span>(rare=ssr)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="keyword">for</span> i <span class="keyword">in</span> formulas:</span></span><br><span class="line"><span class="meta">...</span> <span class="python">    print(i)</span></span><br><span class="line"><span class="meta">...</span></span><br><span class="line">GuiQie</span><br><span class="line">CiMuTongZi</span><br></pre></td></tr></table></figure>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3></li>
</ul>
<p>代码里，ManyToManyField定义在class Soul。</p>
<p>使用objects方式创建破势套和针女套</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Soul.objects.<span class="keyword">create</span>(<span class="keyword">set</span>=<span class="string">&#x27;PoShi&#x27;</span>)</span><br><span class="line">&lt;Soul: Soul <span class="keyword">object</span> (<span class="number">1</span>)&gt;</span><br><span class="line">&gt;&gt;&gt; Soul.objects.<span class="keyword">create</span>(<span class="keyword">set</span>=<span class="string">&#x27;ZhenNv&#x27;</span>)</span><br><span class="line">&lt;Soul: Soul <span class="keyword">object</span> (<span class="number">2</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>指定Soul(御魂)关联给Formula(式神)，<strong>使用add的方式</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; zhennv = Soul.objects.<span class="builtin-name">get</span>(<span class="attribute">set</span>=<span class="string">&#x27;ZhenNv&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; zhennv.formula.<span class="builtin-name">add</span>(guiqie)</span><br></pre></td></tr></table></figure>
<p>指定Formula(式神)关联给Soul(御魂)，<strong>使用add的方式</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">poshi = Soul.objects.<span class="builtin-name">get</span>(<span class="attribute">set</span>=<span class="string">&#x27;PoShi&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt; guiqie.soul_set.<span class="builtin-name">add</span>(poshi)</span><br></pre></td></tr></table></figure>
<p>将指定御魂(Soul)关联所有式神(Formula)，<strong>使用set()方法</strong></p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">all</span> = Formula.objects.<span class="built_in">all</span>()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">poshi = Soul.objects.get(<span class="built_in">set</span>=<span class="string">&#x27;PoShi&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">poshi.formula.<span class="built_in">set</span>(<span class="built_in">all</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将指定式神关联所有御魂，<strong>使用set()方法</strong></p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">all</span> = Soul.objects.<span class="built_in">all</span>()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">Yi=Formula.objects.get(name=<span class="string">&#x27;Yi&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">Yi.soul_set.<span class="built_in">set</span>(<span class="built_in">all</span>)</span></span><br></pre></td></tr></table></figure>

<p>相互之间访问数据（好像不存在objects访问的方法，待考证）</p>
<ol>
<li><p>通过式神(Formula)获取御魂(Soul, ManyToManyField),使用_set.value()方式</p>
<ul>
<li><p>对象属性方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">guiqie</span><span class="selector-class">.soul_set</span><span class="selector-class">.values</span>()</span><br><span class="line">&lt;<span class="selector-tag">QuerySet</span> <span class="selector-attr">[&#123;<span class="string">&#x27;id&#x27;</span>: 1, <span class="string">&#x27;set&#x27;</span>: <span class="string">&#x27;ZhenNv&#x27;</span>&#125;]</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过御魂(Soul, ManyToManyField)查询式神(Formula)</p>
<ul>
<li>对象属性方式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">poshi</span><span class="selector-class">.formula</span><span class="selector-class">.values</span>()</span><br><span class="line">&lt;<span class="selector-tag">QuerySet</span> <span class="selector-attr">[&#123;<span class="string">&#x27;rare_id&#x27;</span>: 4, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;GuiQie&#x27;</span>&#125;]</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p>refer</p>
<blockquote>
<p><a href="https://imliyan.com/blogs/article/Django%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B/">https://imliyan.com/blogs/article/Django%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B/</a><br><a href="https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.OneToOneField">https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.OneToOneField</a><br><a href="https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ForeignKey">https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ForeignKey</a><br><a href="https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ManyToManyField">https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ManyToManyField</a><br><a href="https://docs.djangoproject.com/en/2.2/topics/db/examples/many_to_many/">https://docs.djangoproject.com/en/2.2/topics/db/examples/many_to_many/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT认证的实现</title>
    <url>/2020/02/29/JWT%E8%AE%A4%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="什么是JWT，以及原理"><a href="#什么是JWT，以及原理" class="headerlink" title="什么是JWT，以及原理"></a>什么是JWT，以及原理</h2><p>网上有大把解释JWT认证原理的，直接看refer部分。</p>
<h2 id="JWT认证"><a href="#JWT认证" class="headerlink" title="JWT认证"></a>JWT认证</h2><ol>
<li>当用户登陆的时候，后端根据部分字段进行签名，然后将签名得到的数据返回给用户。</li>
<li>用户下一次请求数据的时候，在请求头的authentication字段携带token。</li>
<li>服务端收到token后进行解密，前两段用私钥签名的结果跟第三段对比，看是否一致，如果一致，则判定当前用户合法，反之则非法。</li>
<li>JWT的token为三段，前两段用base64编码，可以解开，第一段是描述认证方式和算法，第二段就是具体的一些信息，第三段为服务端私钥根据前两段内容进行的签名，也就是加密部分。</li>
</ol>
<a id="more"></a>

<h2 id="JWT后端部分代码"><a href="#JWT后端部分代码" class="headerlink" title="JWT后端部分代码"></a>JWT后端部分代码</h2><ol>
<li><p>后端使用python写，求快，直接用的sanic库，以下为主要代码，只求结果正确。</p>
</li>
<li><p>主要逻辑：</p>
<ol>
<li>登录认证通过，则后端根据username以及一些基本信息生成token，然后返回给前端</li>
</ol>
</li>
</ol>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">    token = jwt.encode(payload, <span class="string">&#x27;today&#x27;</span>, headers=jwt_headers, algorithm=<span class="string">&#x27;HS256&#x27;</span>).decode()</span><br><span class="line">		<span class="comment"># 若用户名和密码为admin， 则认为认证通过</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;admin&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> json(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;authSuccess&#x27;</span>,<span class="string">&#x27;access_token&#x27;</span>: token, <span class="string">&#x27;account_id&#x27;</span>: username&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> json(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">401</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;authFaildd&#x27;</span>&#125;)</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>其他但凡和后端存在数据交互的，则进行token的认证，将该方法作为装饰器。</li>
</ol>
<pre><code>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">func</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;执行check&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;执行wrapper&#x27;</span>)</span><br><span class="line">        jwt_headers = &#123;</span><br><span class="line">            <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">            <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = request.headers.get(<span class="string">&#x27;authorization&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token = token.split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                payload = jwt.decode(token, <span class="string">&#x27;today&#x27;</span>, audience=<span class="string">&#x27;yisan.com&#x27;</span>, headers=jwt_headers, algorithms=[<span class="string">&#x27;HS256&#x27;</span>])</span><br><span class="line">                <span class="keyword">if</span> payload:</span><br><span class="line">                    <span class="keyword">return</span> func(request)</span><br><span class="line">                <span class="keyword">return</span> json(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">401</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;checkFailed&#x27;</span>&#125;)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">return</span> json(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">401</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;checkFailed&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 具体要请求的接口数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> json(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">405</span>, <span class="string">&#x27;info&#x27;</span>: <span class="string">&#x27;函数没有返回值&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="JWT前端部分代码"><a href="#JWT前端部分代码" class="headerlink" title="JWT前端部分代码"></a>JWT前端部分代码</h2><ol>
<li><p>主要使用axios的响应拦截器，对返回json数据的code值进行判断。</p>
</li>
<li><p>主要逻辑</p>
<ol>
<li><p>axios相应拦截器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> code = res.data.code</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.location)</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="comment">// 后端返回401, 且当前uri不是/login, 则跳转到login页面</span></span><br><span class="line">  <span class="keyword">if</span> (code === <span class="number">401</span> &amp;&amp; <span class="built_in">document</span>.location.pathname !== <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;登陆失败或失效&#x27;</span>)</span><br><span class="line">    sessionStorage.removeItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">   <span class="comment">// 后端返回401， 且当前uri是/login, 则不跳转，防止死循环</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">401</span> &amp;&amp; <span class="built_in">document</span>.location.pathname === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;不跳转了&#x27;)</span></span><br><span class="line">    <span class="comment">// return false</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.data</span><br><span class="line">&#125;)</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
<li><p>/login页面，在created阶段，发送token验证请求，如果当前为登陆状态，则跳转至/homepage</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.token = sessionStorage.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  tokenCheck(<span class="built_in">this</span>.token).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">if</span> (res.code === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/homepage&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<h2 id="GitHub仓库地址"><a href="#GitHub仓库地址" class="headerlink" title="GitHub仓库地址"></a>GitHub仓库地址</h2><blockquote>
<p><a href="https://github.com/huangyisan/simulator_jwt_auth.git">https://github.com/huangyisan/simulator_jwt_auth.git</a></p>
</blockquote>
<p>refer</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/70275218">https://zhuanlan.zhihu.com/p/70275218</a></p>
<p><a href="https://segmentfault.com/a/1190000010312468">https://segmentfault.com/a/1190000010312468</a></p>
<p><a href="https://jasonwatmore.com/post/2018/07/06/vue-vuex-jwt-authentication-tutorial-example">https://jasonwatmore.com/post/2018/07/06/vue-vuex-jwt-authentication-tutorial-example</a></p>
<p><a href="https://juejin.im/post/5ce3e9146fb9a07eba2c1258">https://juejin.im/post/5ce3e9146fb9a07eba2c1258</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
        <tag>vue</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins blueocean发布hexo</title>
    <url>/2020/12/20/Jenkins%20blueocean%E5%8F%91%E5%B8%83hexo/</url>
    <content><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>之前一直用travis-ci做hexo的发布，但是从两个月之前开始，不知道为什么提交了代码后，travis-ci虽然触发了，但一直卡pending状态，一直不进行构建。导致需要在本机构建hexo，然后推送到master分支，前几篇关于concourse的就是手动构建hexo目录结构进行发布的。</p>
<a id="more"></a>

<p>实在不能忍了，前几天阿里云买了台2c4g的机器，准备自己弄个jenkins，做构建发布。</p>
<p>因为之前公司也简单接触过jenkins，不过那会都是页面点点点，这次准备写pipeline进行构建。</p>
<p>我也是才知道，jenkins有个blue ocean的界面，专门用来弄pipeline。而且也是只要将pipeline文件(默认为Jenkinsfile,可以在构建项目的Build Configuration里面修改)放置于仓库根目录，便可以使用Jenkinsfile定义的pipeline进行构建了。我最早那会接触的gitlab和travis-ci也是这么个流程。这样的话就可以在代码仓库直接维护pipeline了。</p>
<p>此次编写的pipeline为<strong>Declarative Pipeline</strong></p>
<h2 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h2><p>发布流程还是参照之前travis-ci编写的流程，只不过这次改成用jenkins去实现了。</p>
<ol>
<li>拉取hexo分支和master分支</li>
<li>在hexo分支进行hexo目录构建</li>
<li>将master分支的.git目录整个复制到hexo分支下的public目录中</li>
<li>将public中的文件强推至master分支，完成发布</li>
</ol>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><ol>
<li>触发式构建</li>
<li>邮件通知</li>
</ol>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="前期步骤"><a href="#前期步骤" class="headerlink" title="前期步骤"></a>前期步骤</h3><ol>
<li>准备插件，总之要用什么就装什么插件，blueocean是必备的，Extended E-mail Notification也得准备，pipeline会用Extended E-mail Notification方式发送。</li>
<li>在github准备<code>Personal access tokens</code>注意权限，用于blueocean对仓库的操作。且在jenkins设置里面配置Github服务器。(网上教程一大把)</li>
<li>准备一个邮箱，并设置其能够使用脚本的方式发邮件，比如qq的是开启IMAP独立token。(一开始我用的阿里邮箱，实在没找到在哪里，听说用163的也可以。)由于ECS是阿里云的，所以25端口无法使用，qq的话得走587 smtp端口。</li>
<li>根据邮箱信息配置好Extended E-mail Notification里面的内容，<code>SMTP server</code>,<code>SMTP Port</code>主要是这两部分。</li>
<li>jenkins设置里面的Jenkins Location，配置好发送邮箱的地址。</li>
<li>在github上需要构建的repo仓库中配置好webhook，用于提交后出发回调给jenkins，jenkins webhook地址一般为”jenkins服务器地址/github-webhook”。<strong>jenkinsfile的方式自动触发构建是通过github的回调实现，而不是在jenkins页面上配置触发构建</strong>。</li>
<li>根据blueocean的引导，选择要构建的github项目。</li>
</ol>
<h3 id="编写Jenkinsfile"><a href="#编写Jenkinsfile" class="headerlink" title="编写Jenkinsfile"></a>编写Jenkinsfile</h3><ol>
<li>将需要构建的branch追加该Jenkinsfile</li>
<li>内容如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&#x27;master&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        // 并行拉取hexo和master分支</span><br><span class="line">        stage(<span class="string">&#x27;Parellel get repo&#x27;</span>) &#123;</span><br><span class="line">            parallel &#123;</span><br><span class="line">                stage(<span class="string">&#x27;Fetch hexo barnch&#x27;</span>) &#123;</span><br><span class="line">                    environment &#123;</span><br><span class="line">                        NVM_DIR = <span class="string">&quot;/var/lib/jenkins/.nvm&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    steps &#123;</span><br><span class="line">                        // 指定工作目录为hexo-branch, 并将hexo分支拉取到hexo-branch目录，如果没有这个目录则创建。</span><br><span class="line">                        <span class="built_in">dir</span>(<span class="string">&#x27;hexo-branch&#x27;</span>) &#123;</span><br><span class="line">                            // credentialsId在jenkins配置的credential manager中可以找到，也就是之前配置的Personal access tokens对应的<span class="built_in">id</span></span><br><span class="line">                            git branch: <span class="string">&#x27;hexo&#x27;</span>, credentialsId: <span class="string">&#x27;0cc091e1-b69f-4e1d-b8c6-b7a9df25e438&#x27;</span>, url: <span class="string">&#x27;https://github.com/huangyisan/myblog.git&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                stage(<span class="string">&#x27;Fetch master branch&#x27;</span>) &#123;</span><br><span class="line">                    steps&#123;</span><br><span class="line">                        <span class="built_in">dir</span>(<span class="string">&#x27;master-branch&#x27;</span>) &#123;</span><br><span class="line">                            git branch: <span class="string">&#x27;master&#x27;</span>, credentialsId: <span class="string">&#x27;0cc091e1-b69f-4e1d-b8c6-b7a9df25e438&#x27;</span>, url: <span class="string">&#x27;https://github.com/huangyisan/myblog.git&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage(<span class="string">&#x27;Build hexo&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">dir</span>(<span class="string">&#x27;hexo-branch&#x27;</span>) &#123;</span><br><span class="line">                    // 因为我用的是nvm管理的node，所以得提前在linux的jenkins用户下安装nvm，这边是引入环境，并且构建hexo</span><br><span class="line">                    sh <span class="string">&#x27;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; &amp;&amp; npm install &amp;&amp; hexo clean &amp;&amp; hexo g&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage(<span class="string">&#x27;cp master .git to hexo-branch/public&#x27;</span>)&#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                // 指定工作目录为master-branch，并且将.git文件cp到hexo-branch下的public中</span><br><span class="line">                <span class="built_in">dir</span>(<span class="string">&#x27;master-branch&#x27;</span>) &#123;</span><br><span class="line">                    sh <span class="string">&#x27;cp -a ./.git ../hexo-branch/public&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage(<span class="string">&#x27;set git user info&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">dir</span>(<span class="string">&#x27;hexo-branch&#x27;</span>) &#123;</span><br><span class="line">                    // 设定提交代码人的信息</span><br><span class="line">                    sh <span class="string">&#x27;cd ./public &amp;&amp; git config user.name  &quot;huangyisan&quot; &amp;&amp; git config user.email &quot;anonymousyisan@gmail.com&quot;&#x27;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage (<span class="string">&#x27;git add &amp;&amp; commit&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">dir</span>(<span class="string">&#x27;hexo-branch&#x27;</span>) &#123;</span><br><span class="line">                    // Git commit信息</span><br><span class="line">                    sh <span class="string">&#x27;cd ./public &amp;&amp; git add . &amp;&amp; git commit -m &quot;Jenkins CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot; &#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stage (<span class="string">&#x27;Push public to Master branch&#x27;</span>) &#123;</span><br><span class="line">            environment &#123;</span><br><span class="line">                // 定义了一个变量GH_REF</span><br><span class="line">                GH_REF=<span class="string">&quot;github.com/huangyisan/myblog.git&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="built_in">dir</span>(<span class="string">&#x27;hexo-branch&#x27;</span>) &#123;</span><br><span class="line">                    // 从credential manager中获取<span class="built_in">id</span>为<span class="string">&#x27;e5d2d117-b5ab-4dc5-9e07-a5e96bfb6e31&#x27;</span>的密钥，赋值给TOKEN</span><br><span class="line">                    withCredentials([string(credentialsId: <span class="string">&#x27;e5d2d117-b5ab-4dc5-9e07-a5e96bfb6e31&#x27;</span>, variable: <span class="string">&#x27;TOKEN&#x27;</span>)]) &#123;</span><br><span class="line">                        // 进入public目录后，强推master分支</span><br><span class="line">                        sh <span class="string">&#x27;cd public &amp;&amp; git push --force --quiet &quot;https://$&#123;TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // post为构建结束后的操作</span><br><span class="line">    post &#123;</span><br><span class="line">        // always表示无论构建结构是成功还是失败，亦或其他都执行</span><br><span class="line">        always &#123;</span><br><span class="line">            <span class="built_in">dir</span>(<span class="string">&#x27;hexo-branch&#x27;</span>) &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    // 获取commit <span class="built_in">id</span>号, 设定邮件的类型，发送方，主题，内容等</span><br><span class="line">                    def COMMIT_ID = &quot;&quot;</span><br><span class="line">                    COMMIT_ID = sh(returnStdout: true, script:<span class="string">&#x27;git log --pretty=format:&quot;%h&quot; -1&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">                    def mimeType = &#x27;text/html&#x27;</span><br><span class="line"></span><br><span class="line">                    def to = &#x27;anonymousyisan@gmail.com&#x27;</span><br><span class="line"></span><br><span class="line">                    def subject = &#x27;【构建通知】$PROJECT_NAME - &#x27; + &quot;$&#123;COMMIT_ID&#125;&quot; +  &#x27; - Build # $BUILD_NUMBER - $BUILD_STATUS!&#x27;</span><br><span class="line"></span><br><span class="line">                    def body = </span><br><span class="line">                    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">略....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">                    &#x27;&#x27;&#x27;</span></span><br><span class="line">                // 执行发送邮件函数</span><br><span class="line">                emailext(</span><br><span class="line">                    to: to,</span><br><span class="line">                    subject: subject,</span><br><span class="line">                    mimeType: mimeType,</span><br><span class="line">                    body: body</span><br><span class="line">                )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交代码后自动构建"><a href="#提交代码后自动构建" class="headerlink" title="提交代码后自动构建"></a>提交代码后自动构建</h3><ol>
<li>可以在blueocean的pipeline中点击查看各个构建步骤的详细信息。</li>
<li>pipeline构建图如下</li>
</ol>
<p><img src="https://assets.iostat.io/image/jenkins_blueocean_build.png"></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>打开博客页面，看其是否正常显示，且已经有了最新的更新</li>
<li>博客地址</li>
</ol>
<p><a href="https://iostat.io/">kirakirazone</a></p>
<p>本文Jenkinsfile地址: <a href="https://github.com/huangyisan/myblog/blob/hexo/Jenkinsfile">https://github.com/huangyisan/myblog/blob/hexo/Jenkinsfile</a></p>
<p>refer:</p>
<blockquote>
<p>多分支构建参考<a href="https://blog.csdn.net/yanggd1987/article/details/106900128/">https://blog.csdn.net/yanggd1987/article/details/106900128/</a><br><a href="https://plugins.jenkins.io/github/">https://plugins.jenkins.io/github/</a><br><a href="https://stackoverflow.com/questions/43912510/send-notification-e-mail-to-upstream-committer-in-jenkins-pipeline">https://stackoverflow.com/questions/43912510/send-notification-e-mail-to-upstream-committer-in-jenkins-pipeline</a><br><a href="https://www.jenkins.io/doc/book/pipeline/syntax/">https://www.jenkins.io/doc/book/pipeline/syntax/</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 只出现一次的数字</title>
    <url>/2019/01/28/LeetCode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [2,2,1]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [4,1,2,1,2]</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>使用异或的方式，非常巧妙，异或算法为相同为0，不同为1。</li>
<li><strong>数字A异或数字B两次，则结果为A</strong>。</li>
<li>利用这个方法，可以找到非空数组里面只出现一次的那个元素。</li>
<li><strong>0和数字B进行异或，得到的结果为数字B</strong>，基于这点，到最后所有元素异或剩下的结果就是只出现一次的那个元素。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution:</span></span><br><span class="line">    <span class="symbol">def</span> <span class="symbol">singleNumber</span>(<span class="symbol">self, <span class="symbol">nums</span></span>):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :<span class="symbol">type</span> <span class="symbol">nums: <span class="symbol">List</span></span>[<span class="symbol">int</span>]</span><br><span class="line">        :<span class="symbol">rtype: <span class="symbol">int</span></span></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        <span class="symbol">a</span> = <span class="symbol">0</span></span><br><span class="line">        <span class="symbol">for</span> <span class="symbol">num</span> <span class="symbol">in</span> <span class="symbol">nums:</span></span><br><span class="line">            <span class="symbol">a</span> = <span class="symbol">a</span> ^ <span class="symbol">num</span></span><br><span class="line">            <span class="symbol">print</span>(<span class="symbol">a</span>)</span><br><span class="line">        <span class="symbol">return</span> <span class="symbol">a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 实现strStr()</title>
    <url>/2019/01/23/LeetCode-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">&quot;hello&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;ll&quot;</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">haystack</span> = <span class="string">&quot;aaaaa&quot;</span>, <span class="attr">needle</span> = <span class="string">&quot;bba&quot;</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>python非常简单，直接使用find命令就可以查询到指定字符串第一次出现的position。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack, needle</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> haystack.find(needle)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>refer</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/implement-strstr/">https://leetcode-cn.com/problems/implement-strstr/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 最后一个单词长度</title>
    <url>/2019/01/24/LeetCode-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: &quot;Hello World&quot;</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>两种情况，一种是为空，第二种是非空字符串。</li>
<li>字符串为空，则直接返回0，非空字符串，则返回最后一个单词。</li>
<li>python用split()方法，默认以空格，制表符等分割字符串，成为一个list。</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        slist = s.split()</span><br><span class="line">        print(slist)</span><br><span class="line">        <span class="keyword">if</span> slist == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(slist[-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>refer:</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/length-of-last-word/submissions/">https://leetcode-cn.com/problems/length-of-last-word/submissions/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Loki日志服务01</title>
    <url>/2021/03/06/Loki%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A101/</url>
    <content><![CDATA[<h2 id="Loki"><a href="#Loki" class="headerlink" title="Loki"></a>Loki</h2><p>之前日志服务用的较多的一般是ELK，EFK，graylog等，但这些日志由java编写，运行需要jdk，而且配置上面，还是有点复杂，比如需要对日志需要写grok将复杂的日志进行匹配，好在后面出了可以根据分隔符的方式进行日志的提取，也就是dissect插件，可以根据分隔符进行分割。</p>
<p>ELK在日志方面给我的感觉是大而全，查询匹配是杠杠的，Kibana图表非常丰富。但如果面对大量的数据，需要查询，在不堆机器的情况下，还是会比较疲软，查询比较慢，之前公司每当突发流量的时候，由于日志写入比较大，队列都在kafka，es消费慢，导致无法实时出数据。</p>
<p>最近公众号一直推送关于这个名为Loki的日志服务，感到心痒痒。看了官网，受到了prometheus启发，对日志进行打标签的方式而非全文索引的方式(还未尝试，可能描述不当)，而且也可以跟kubernetes集成。</p>
<p>准备开两个档，这次这个打算用简单粗暴的方式来体验下Loki，挖个坑，下次体验和kubernetes结合。</p>
<p>Like Prometheus, but for logs!</p>
<a id="more"></a>



<h2 id="安装Loki-使用Local方式"><a href="#安装Loki-使用Local方式" class="headerlink" title="安装Loki(使用Local方式)"></a>安装Loki(使用Local方式)</h2><h3 id="安装和运行"><a href="#安装和运行" class="headerlink" title="安装和运行"></a>安装和运行</h3><ol>
<li><a href="https://github.com/grafana/loki/releases/">https://github.com/grafana/loki/releases/</a></li>
<li>找到要安装的版本，我采用的是v2.1.0</li>
<li>下载Loki和Promtail, (Loki为日志的引擎，通过Promtail来发送日志到Loki)</li>
<li>在本机找一个目录存放这两个2进制文件</li>
<li>下载两者的配置文件(第一个配置文件不适配v2.1.0或者最新的版本，使用<a href="https://raw.githubusercontent.com/grafana/loki/af6e8cb6c9a02be44a978c4933fb17778cb401b7/cmd/loki/loki-local-config.yaml%E6%9B%BF%E4%BB%A3%E3%80%82">https://raw.githubusercontent.com/grafana/loki/af6e8cb6c9a02be44a978c4933fb17778cb401b7/cmd/loki/loki-local-config.yaml替代。</a> issue-3055)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/grafana/loki/master/cmd/loki/loki-local-config.yaml</span><br><span class="line">wget https://raw.githubusercontent.com/grafana/loki/master/cmd/promtail/promtail-local-config.yaml</span><br></pre></td></tr></table></figure></li>
<li>使用如下命令启动Loki<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./loki-linux-amd64 -config.file=loki-local-config.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@test:~$cd /usr/local/loki/</span><br><span class="line">root@test:/usr/local/loki$ls</span><br><span class="line">loki-linux-amd64  loki-local-config.yaml  promtail-linux-amd64  promtail-local-config.yaml</span><br><span class="line">root@test:/usr/local/loki$./loki-linux-amd64 -config.file=loki-local-config.yaml</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="尝试搜集nginx日志"><a href="#尝试搜集nginx日志" class="headerlink" title="尝试搜集nginx日志"></a>尝试搜集nginx日志</h2><ol>
<li>所以首先对nginx默认的日志进行改造，让他以json的方式进行输出到目录，然后用Promtail对其进行读取。</li>
<li>读取使用LogQL的json方式去读取，这个LogQL内容填写在grafana中。</li>
</ol>
<h3 id="grafana的安装和配置"><a href="#grafana的安装和配置" class="headerlink" title="grafana的安装和配置"></a>grafana的安装和配置</h3><p>忽略，可以参考<a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a><br>配置完数据源即可。</p>
<h3 id="nginx的部分配置改造"><a href="#nginx的部分配置改造" class="headerlink" title="nginx的部分配置改造"></a>nginx的部分配置改造</h3><p>虚拟server配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name  loki.test.com; # 域名设置</span><br><span class="line">    listen       8888;</span><br><span class="line">    access_log /var/log/nginx/loki_access.log promtail_json;</span><br><span class="line">    location / &#123;</span><br><span class="line">        return 200 &quot;It&#x27;s ok!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>promtail_json日志格式配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">log_format promtail_json &#x27;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;@version&quot;:&quot;Promtail json&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;server_addr&quot;:&quot;$server_addr&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;remote_addr&quot;:&quot;$remote_addr&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;host&quot;:&quot;$host&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;uri&quot;:&quot;$uri&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;body_bytes_sent&quot;:$body_bytes_sent,&#x27;</span><br><span class="line">        &#x27;&quot;bytes_sent&quot;:$body_bytes_sent,&#x27;</span><br><span class="line">        &#x27;&quot;request&quot;:&quot;$request&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;request_length&quot;:$request_length,&#x27;</span><br><span class="line">        &#x27;&quot;request_time&quot;:$request_time,&#x27;</span><br><span class="line">        &#x27;&quot;status&quot;:&quot;$status&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;http_referer&quot;:&quot;$http_referer&quot;,&#x27;</span><br><span class="line">        &#x27;&quot;http_user_agent&quot;:&quot;$http_user_agent&quot;&#x27;</span><br><span class="line">        &#x27;&#125;&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问127.0.0.1:8888，观察日志已经正常输出为json格式，请保证该json格式正确。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@test:/etc/nginx/conf.d$tail -f /var/log/nginx/loki_access.log </span><br><span class="line">&#123;&quot;@timestamp&quot;:&quot;2021-03-06T01:54:42-05:00&quot;,&quot;@version&quot;:&quot;Promtail json&quot;,&quot;server_addr&quot;:&quot;127.0.0.1&quot;,&quot;remote_addr&quot;:&quot;192.168.65.130&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;uri&quot;:&quot;/&quot;,&quot;body_bytes_sent&quot;:8,&quot;bytes_sent&quot;:8,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;request_length&quot;:78,&quot;request_time&quot;:0.000,&quot;status&quot;:&quot;200&quot;,&quot;http_referer&quot;:&quot;-&quot;,&quot;http_user_agent&quot;:&quot;curl/7.29.0&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>nginx日志改造完毕</strong></p>
<h3 id="Promtail配置文件修改"><a href="#Promtail配置文件修改" class="headerlink" title="Promtail配置文件修改"></a>Promtail配置文件修改</h3><ol>
<li>因为搜集日志是Promtail处理，所以自然而然是需要根据自己需求来配置Promtail的配置文件。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  http_listen_port: 9080</span><br><span class="line">  grpc_listen_port: 0</span><br><span class="line"></span><br><span class="line">positions:</span><br><span class="line">  filename: /tmp/loki-positions.yaml  # 记录pos点</span><br><span class="line">  sync_period: 5s # 5s一次将当前读取到的pos点同步至filename配置的文件内</span><br><span class="line"></span><br><span class="line">clients:</span><br><span class="line">  - url: http://localhost:3100/loki/api/v1/push</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">- job_name: Loki</span><br><span class="line">  static_configs:</span><br><span class="line">  - labels: # 设定的部分标签</span><br><span class="line">     job: Loki-nginx</span><br><span class="line">     host: localhost</span><br><span class="line">     app: nginx</span><br><span class="line">     __path__: /var/log/nginx/loki_access.log # 待读取的nginx日志</span><br></pre></td></tr></table></figure>
<h3 id="LogQL-json部分文档理解"><a href="#LogQL-json部分文档理解" class="headerlink" title="LogQL json部分文档理解"></a>LogQL json部分文档理解</h3><ol>
<li>json的提取分为两种方式，<strong>带参数</strong>和<strong>不带参数</strong></li>
</ol>
<h4 id="不带参数的方式"><a href="#不带参数的方式" class="headerlink" title="不带参数的方式"></a>不带参数的方式</h4><ol>
<li>使用<code>|json</code>来提取日志的json内容，前提是json内容为有效json格式。</li>
<li>嵌套的字段会用”_”将内外层的key进行拼接。</li>
<li><strong>忽略数组。</strong></li>
</ol>
<p>看一下<a href="https://grafana.com/docs/loki/latest/logql/">官网</a>中不带参数方式的样例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;HTTP/2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;servers&quot;</span>: [<span class="string">&quot;129.0.1.1&quot;</span>,<span class="string">&quot;10.2.1.3&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;6.032&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;foo.grafana.net&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="string">&quot;55&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;headers&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;User-Agent&quot;</span>: <span class="string">&quot;curl/7.68.0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;response&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">401</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="string">&quot;228&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;latency_seconds&quot;</span>: <span class="string">&quot;6.031&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被json解后，得到如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;protocol&quot; =&gt; &quot;HTTP/2.0&quot;</span><br><span class="line">&quot;request_time&quot; =&gt; &quot;6.032&quot;</span><br><span class="line">&quot;request_method&quot; =&gt; &quot;GET&quot;</span><br><span class="line">&quot;request_host&quot; =&gt; &quot;foo.grafana.net&quot;</span><br><span class="line">&quot;request_size&quot; =&gt; &quot;55&quot;</span><br><span class="line">&quot;response_status&quot; =&gt; &quot;401&quot;</span><br><span class="line">&quot;response_size&quot; =&gt; &quot;228&quot;</span><br><span class="line">&quot;response_size&quot; =&gt; &quot;228&quot;</span><br></pre></td></tr></table></figure>
<p>从输出能看到，原本request字段内容为嵌套，<strong>所以request里面的内容的key验证了如上第二点，使用”_”进行了拼接。</strong><br><strong>同时servers由于是个数组，所以在解析后直接丢弃了servers这个key，验证了第三点。</strong></p>
<h4 id="带参数的方式"><a href="#带参数的方式" class="headerlink" title="带参数的方式"></a>带参数的方式</h4><ol>
<li>带参数的方式，json只会根据参数来解开需要的部分(当单条json数据比较大的时候应该能省很多资源)。</li>
<li>使用| json label=”expression”, another=”expression”的方式来编写该方法。可以存在多个参数</li>
</ol>
<p>看一下<a href="https://grafana.com/docs/loki/latest/logql/">官网</a>中带参数方式的样例</p>
<p>使用| json first_server=”servers[0]”, ua=”request.headers[&quot;User-Agent&quot;]进行提取</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;HTTP/2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;servers&quot;</span>: [<span class="string">&quot;129.0.1.1&quot;</span>,<span class="string">&quot;10.2.1.3&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;6.032&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;foo.grafana.net&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="string">&quot;55&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;headers&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;User-Agent&quot;</span>: <span class="string">&quot;curl/7.68.0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;response&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">401</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="string">&quot;228&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;latency_seconds&quot;</span>: <span class="string">&quot;6.031&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;first_server&quot; =&gt; &quot;129.0.1.1&quot;</span><br><span class="line">&quot;ua&quot; =&gt; &quot;curl/7.68.0&quot;</span><br></pre></td></tr></table></figure>
<p>first_server和ua都为原先参数中指定的key</p>
<p>如果要提取整个对象，可以使用| json server_list=”servers”, headers=”request.headers<br>这样就能得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;server_list&quot; =&gt; `[&quot;129.0.1.1&quot;,&quot;10.2.1.3&quot;]`</span><br><span class="line">&quot;headers&quot; =&gt; `&#123;&quot;Accept&quot;: &quot;*/*&quot;, &quot;User-Agent&quot;: &quot;curl/7.68.0&quot;&#125;`</span><br></pre></td></tr></table></figure>
<h3 id="尝试写一条LogQL表达式"><a href="#尝试写一条LogQL表达式" class="headerlink" title="尝试写一条LogQL表达式"></a>尝试写一条LogQL表达式</h3><p>一条完整的LogQL表达式由<strong>两部分</strong>构成：</p>
<ul>
<li>a log stream selector，可以理解为，通过设定的label去匹配要抓取哪些日志。</li>
<li>a log pipeline，可以理解为表达式。比如json的提取。</li>
</ul>
<p>比如如下表达式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;container=&quot;query-frontend&quot;,namespace=&quot;tempo-dev&quot;&#125; |= &quot;metrics.go&quot; | logfmt | duration &gt; 10s and throughput_mb &lt; 500</span><br></pre></td></tr></table></figure>
<p>{container=”query-frontend”,namespace=”tempo-dev”} 部分为log stream selector，后面部分为log pipeline。</p>
<h3 id="编写一个简单的nginx日志需求"><a href="#编写一个简单的nginx日志需求" class="headerlink" title="编写一个简单的nginx日志需求"></a>编写一个简单的nginx日志需求</h3><ol>
<li>Loki-nginx日志中状态码为200的条数。</li>
<li>根据当前选定时间范围，自动调整。</li>
</ol>
<p>思考：</p>
<ol>
<li>如何指定Loki-nginx，可以使用log stream selector的表达式来选定。</li>
<li>nginx日志已经转变为了json，所以可以用<code>|json</code>来提取。</li>
<li>如何获取status字段的信息? |json后面直接跟随|status即可，即<code>|json|status</code>。</li>
<li>如何根据当前选定的时间范围？ 使用内置变量<code>[$\_\_interval]</code>。</li>
<li>条数该得用什么方法获得？LogQL有内置函数<code>count_over_time</code>配合<code>sum</code>，这边需要注意的是<code>count_over_time</code>是根据指定时间范围返回日志条目的具体内容，所以还需要配合<code>sum</code>获得时间段内的总数。</li>
</ol>
<p>编写：</p>
<ol>
<li>首先选定Loki-nginx的日志，<code>&#123;job=&quot;Loki-nginx&quot;&#125;</code>。</li>
<li>使用count_over_time函数配合<code>[$\_\_interval]</code>来获取总共的条数。<code>count_over_time(&#123;job=&quot;Loki-nginx&quot;&#125;[$\_\_interval])</code></li>
<li>过滤status字段，让其等于200，表达式<code>count_over_time(&#123;job=&quot;Loki-nginx&quot;&#125; | json | status = 200 [$\_\_interval])</code>，此时会报错，因为status为字符串，可以添加__error__=””让其忽略转换出现的异常。得到<code>count_over_time(&#123;job=&quot;Loki-nginx&quot;&#125; | json | status = 200 \_\_error\_\_=&quot;&quot; [$\_\_interval])</code></li>
<li>此时在grafana上显示为多条数据，配合sum得到单独一个数值。</li>
<li>最终的表达式为： <code>sum(count_over_time(&#123;job=&quot;Loki-nginx&quot;&#125; | json | status = 200 __error__=&quot;&quot; [$__interval]))</code></li>
</ol>
<p>Grafana图:<br><img src="https://assets.iostat.io/imageLogQL_status200.png"></p>
<p>refer:</p>
<blockquote>
<p><a href="https://grafana.com/docs/loki/latest/clients/promtail/configuration/#configuring-promtail">https://grafana.com/docs/loki/latest/clients/promtail/configuration/#configuring-promtail</a><br><a href="https://grafana.com/docs/loki/latest/logql/">https://grafana.com/docs/loki/latest/logql/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>Loki</tag>
        <tag>linux</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>Promotions in Program C</title>
    <url>/2019/01/07/Promotions-in-Program-C/</url>
    <content><![CDATA[<h2 id="scanf-函数不会自行提升成double类型，printf-函数会自行提升成double类型。"><a href="#scanf-函数不会自行提升成double类型，printf-函数会自行提升成double类型。" class="headerlink" title="scanf()函数不会自行提升成double类型，printf()函数会自行提升成double类型。"></a>scanf()函数不会自行提升成double类型，printf()函数会自行提升成double类型。</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a double type number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the number is %f\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the number is %lf\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input a <span class="keyword">double</span> type number: <span class="number">1</span></span><br><span class="line">the number is <span class="number">0.000000</span></span><br><span class="line">the number is <span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
<p><strong>scanf()函数因为指向的是num的指针,所以不适用float promotions to double</strong></p>
<a id="more"></a>

<p><strong>scanf()若使用double类型，必须写成”%lf”, 而printf()即便指定的是”%f”,也会自行提升成double类型。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a double type number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the number is %f\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the number is %lf\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input a <span class="keyword">double</span> type number: <span class="number">1</span></span><br><span class="line">the number is <span class="number">1.000000</span></span><br><span class="line">the number is <span class="number">1.000000</span></span><br></pre></td></tr></table></figure>
<h2 id="integer-promotions"><a href="#integer-promotions" class="headerlink" title="integer-promotions"></a>integer-promotions</h2><p>refer:</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/19952200/scanf-printf-double-variable-c">https://stackoverflow.com/questions/19952200/scanf-printf-double-variable-c</a><br><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a> [6.5.2.2 page-71]<br><a href="https://www.geeksforgeeks.org/integer-promotions-in-c/">https://www.geeksforgeeks.org/integer-promotions-in-c/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Python防注入</title>
    <url>/2019/01/30/Python%E9%98%B2%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="注入案例："><a href="#注入案例：" class="headerlink" title="注入案例："></a>注入案例：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line">db = MySQLdb.connect(host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">user=<span class="string">&quot;&quot;</span>,</span><br><span class="line">passwd=<span class="string">&quot;&quot;</span>,</span><br><span class="line">db=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line">platform = <span class="built_in">input</span>(<span class="string">&#x27;Enter language: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;SELECT * FROM platforms WHERE language = &#x27;%s&#x27;;&quot;</span> % platform)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur.fetchall():</span><br><span class="line">print(row)</span><br><span class="line"></span><br><span class="line">db.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>上述代码，让用户输入想查询的language，如果用户按套路，比如输入Ruby，则可以正常查询。</p>
<p>执行代码为：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> platforms <span class="keyword">WHERE</span> language = <span class="string">&#x27;Ruby&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>但如果搞事情输入Ruby’; DROP TABLE platforms;那么platforms表被删除。<br>执行代码为：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> platforms <span class="keyword">WHERE</span> language = <span class="string">&#x27;Ruby&#x27;</span>; <span class="keyword">DROP</span> TABLE platforms;&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="防止sql注入"><a href="#防止sql注入" class="headerlink" title="防止sql注入"></a>防止sql注入</h2><p>代码改写为如下:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import MySQLdb</span><br><span class="line"></span><br><span class="line">db = MySQLdb.connect(<span class="attribute">host</span>=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line"><span class="attribute">user</span>=<span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attribute">passwd</span>=<span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attribute">db</span>=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line">platform = raw_input(<span class="string">&#x27;Enter language: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">&quot;SELECT * FROM platforms WHERE language = %s;&quot;</span>, (platform,))</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur.fetchall():</span><br><span class="line"><span class="builtin-name">print</span> (row)</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>这边%s是占位符，和<strong>字符串format的方式不同，而且后面的元组前面也不需要%符号，即便是数字，也是用%s来占位。</strong></p>
<h2 id="防sql原因"><a href="#防sql原因" class="headerlink" title="防sql原因"></a>防sql原因</h2><p>之所以能防sql是因为execute函数会对传入的args内容预处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mogrify</span>(<span class="params">self, query, args=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns the exact string that is sent to the database by calling the</span></span><br><span class="line"><span class="string">    execute() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method follows the extension to the DB API 2.0 followed by Psycopg.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    conn = self._get_db()</span><br><span class="line">    <span class="keyword">if</span> PY2:  <span class="comment"># Use bytes on Python 2 always</span></span><br><span class="line">        query = self._ensure_bytes(query, encoding=conn.encoding)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        query = query % self._escape_args(args, conn)</span><br></pre></td></tr></table></figure>
<p>execute后续调用一些函数，比如下面<code>escape_string</code>函数。(能力有限，前面几级调用不是非常看得懂。)</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">escape_string</span><span class="params">(<span class="keyword">self</span>, s)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.server_status &amp;</span><br><span class="line">            SERVER_STATUS.SERVER_STATUS_NO_BACKSLASH_ESCAPES)<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> converters.escape_string(s)</span><br></pre></td></tr></table></figure>
<p>refer</p>
<blockquote>
<p><a href="https://blog.sqreen.io/preventing-sql-injections-in-python/">https://blog.sqreen.io/preventing-sql-injections-in-python/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制(搬运)</title>
    <url>/2019/07/30/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="如何使用主从复制"><a href="#如何使用主从复制" class="headerlink" title="如何使用主从复制"></a>如何使用主从复制</h1><h2 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h2><p><strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p>
<p>从节点开启主从复制，有3种方式</p>
<a id="more"></a>

<ol>
<li>配置文件</li>
</ol>
<ul>
<li>在从服务器的配置文件中加入：slaveof &lt;masterip&gt; &lt;masterport&gt;</li>
</ul>
<ol start="2">
<li>启动命令</li>
</ol>
<ul>
<li>redis-server启动命令后加入 –slaveof &lt;masterip&gt; &lt;masterport&gt;</li>
</ul>
<ol start="3">
<li>客户端命令</li>
</ol>
<ul>
<li>Redis服务器启动后，直接通过客户端执行命令：slaveof &lt;masterip&gt; &lt;masterport&gt;，则该Redis实例成为从节点。</li>
</ul>
<h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p>通过<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>命令建立主从复制关系以后，可以通过<code>slaveof no one</code>断开。需要注意的是，从节点断开复制后，<strong>不会删除已有的数据，只是不再接受主节点新的数据变化</strong>。</p>
<h1 id="主从复制的实现原理"><a href="#主从复制的实现原理" class="headerlink" title="主从复制的实现原理"></a>主从复制的实现原理</h1><p>主从复制过程大体可以分为3个阶段</p>
<ol>
<li>连接建立阶段</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ol>
<h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p><strong>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</strong></p>
<ol>
<li>保存主节点信息</li>
</ol>
<ul>
<li>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</li>
<li>slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</li>
</ul>
<ol start="2">
<li>建立socket连接</li>
</ol>
<ul>
<li>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接</li>
<li>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</li>
<li>主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</li>
</ul>
<ol start="3">
<li><p>发送ping命令</p>
<ul>
<li><strong>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</strong></li>
<li>从节点发送ping命令后，可能出现3种情况：<ol>
<li>返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</li>
<li>超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</li>
<li>返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</li>
</ol>
</li>
</ul>
</li>
<li><p>身份验证</p>
<ul>
<li>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</li>
<li>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</li>
</ul>
</li>
<li><p>发送从节点端口信息</p>
<ul>
<li>身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</li>
</ul>
</li>
</ol>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><ol>
<li><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：<strong>从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步</strong>。</p>
</li>
<li><p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制。</p>
</li>
<li><p>需要注意的是，<strong>在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端</strong>；<strong>而到了这一阶段及以后，主从节点互为客户端</strong>。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>
</li>
</ol>
<h4 id="数据同步阶段–全量复制和部分复制"><a href="#数据同步阶段–全量复制和部分复制" class="headerlink" title="数据同步阶段–全量复制和部分复制"></a>数据同步阶段–全量复制和部分复制</h4><ol>
<li><p>全量复制<br> <strong>用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</strong><br> Redis通过psync命令进行全量复制的过程如下：</p>
<ol>
<li>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制。</li>
<li>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</li>
<li>主节点的bgsave执行完成后，将RDB文件发送给从节点；<strong>从节点首先清除自己的旧数据，然后载入接收的RDB文件</strong>，将数据库状态更新至主节点执行bgsave时的数据库状态。</li>
<li>主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</li>
<li>如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。</li>
</ol>
</li>
<li><p>部分复制<br> <strong>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</strong><br> 部分复制的实现，依赖于三个重要的概念：</p>
<ol>
<li><p>复制偏移量</p>
<ul>
<li>主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。<ul>
<li>offset用于判断主从节点的数据库状态是否一致：<strong>如果二者offset相同，则一致</strong>；<strong>如果offset不同，则不一致</strong>，此时可以根据两个offset找出从节点缺少的那部分数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>复制积压缓冲区</p>
<ul>
<li><p>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，<strong>无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</strong></p>
<ul>
<li><p>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。<strong>由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区</strong>。</p>
<ul>
<li><p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</p>
<pre><code>* **从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制**：
  * 如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；
    * 如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器运行ID(runid)</p>
<ul>
<li>每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid。</li>
<li>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)。</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h2><p>psync命令的执行过程可以参见下图</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5hwl7a3ssj20fe092my9.jpg"></p>
<ol>
<li><p>首先，从节点根据当前状态，决定如何调用psync命令</p>
<ol>
<li>如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制。</li>
<li>如果从节点之前执行了slaveof，则发送命令为psync &lt;runid&gt; &lt;offset&gt;，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。</li>
</ol>
</li>
<li><p>主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制</p>
<ol>
<li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制。</li>
<li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可。</li>
<li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC &lt;runid&gt; &lt;offset&gt;，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><ol>
<li>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</li>
<li>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</li>
</ol>
<p><strong>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</strong></p>
<p><strong>repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</strong></p>
<p><strong>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</strong></p>
<h4 id="命令传播阶段–心跳机制"><a href="#命令传播阶段–心跳机制" class="headerlink" title="命令传播阶段–心跳机制"></a>命令传播阶段–心跳机制</h4><p><strong>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</strong></p>
<h5 id="主-gt-从：PING"><a href="#主-gt-从：PING" class="headerlink" title="主-&gt;从：PING"></a>主-&gt;从：PING</h5><ol>
<li>每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</li>
<li>PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</li>
<li>关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在Redis的官方文档中，对该参数的注释中说明是从节点向主节点发送PING命令。</li>
</ol>
<h5 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h5><p><strong>在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量</strong></p>
<ol>
<li>实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</li>
<li>检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。<strong>注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的</strong>。</li>
<li>辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</li>
</ol>
<h1 id="应用中的问题"><a href="#应用中的问题" class="headerlink" title="应用中的问题"></a>应用中的问题</h1><p>查看refer内容</p>
<p>refer:</p>
<blockquote>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html">https://www.cnblogs.com/kismetv/p/9236731.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SMTP465端口和587端口</title>
    <url>/2021/06/08/SMTP465%E7%AB%AF%E5%8F%A3%E5%92%8C587%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>今天在做concourse发邮件这部分，一看官网上有开箱即用的resource, 心想今天能早点下班了。官方地址如下:</p>
<blockquote>
<p><a href="https://github.com/pivotal-cf/email-resource">https://github.com/pivotal-cf/email-resource</a></p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>根据README.md配置了关于邮件发送这块的resource,发现一直卡Dial状态，接着就超时了。</li>
</ol>
<p>我想是官方pivotal-cf group下的，再怎么也不会出问题吧，应该是我哪里配置配的有问题，然后我又捣鼓了一个小时，还是没搞定。</p>
<a id="more"></a>

<h3 id="pipeline配置"><a href="#pipeline配置" class="headerlink" title="pipeline配置"></a>pipeline配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">send-an-email</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">email</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">smtp:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">smtp.example.com</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">&quot;465&quot;</span> <span class="comment"># this must be a string</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">a-user</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">my-password</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">build-system@example.com</span></span><br><span class="line">    <span class="attr">to:</span> [ <span class="string">&quot;dev-team@example.com&quot;</span>, <span class="string">&quot;product@example.net&quot;</span> ] <span class="comment">#optional if `params.additional_recipient` is specified</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我的pipeline resource定义完全就是照搬的github上的样例，就是把他的587端口修改成了465，因为我司是用的阿里云邮箱，使用的是465端口，为什么就无法发送了呢？</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li>接着我选了个587端口的邮箱，gmail，发现是可以正常发送的。</li>
<li>难道是被阿里云禁止？ 这个应该不可能，因为换成用python的脚本是可以正常发送，而且阿里云只禁止25端口</li>
</ol>
<h3 id="465端口和587端口的区别"><a href="#465端口和587端口的区别" class="headerlink" title="465端口和587端口的区别"></a>465端口和587端口的区别</h3><p>好好的为什么会有两个端口，我就去谷歌上查了下。</p>
<ol>
<li>465端口可以理解为全程走TLS，在你的本地mail sender和mail server建联的时候就是采用了TLS。</li>
<li>而587不是，587端口你可以通过明文，如果可能，则可以升级使用TLS方式发送邮件。采用的是STARTTLS协议</li>
<li>两者在行为上还是存在区别。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote>
<p><a href="https://github.com/pivotal-cf/email-resource/blob/master/out/sender.go">https://github.com/pivotal-cf/email-resource/blob/master/out/sender.go</a></p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c, err = smtp.Dial(fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, s.host, s.port))</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line"><span class="keyword">if</span> ok, _ := c.Extension(<span class="string">&quot;STARTTLS&quot;</span>); ok &#123;</span><br><span class="line">		config := s.tlsConfig()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = c.StartTLS(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;unable to start TLS&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">..</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到他用<strong>smtp.Dial</strong>方法去连接，然后调用<strong>StartTLS</strong>方法传入配置</p>
<p>如果查看smtp.Dial方法的源码，可以看到其方法是调用的net.Dial方法，这个方法并不是用来建立SSL连接的</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	host, _, _ := net.SplitHostPort(addr)</span><br><span class="line">	<span class="keyword">return</span> NewClient(conn, host)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>既然知道了465的行为，也就是在一开始的时候就需要去做ssl的建联，而非通过smtp.Dial，所以将代码修改如下:</p>
<blockquote>
<p><a href="https://github.com/huangyisan/email-resource/blob/master/out/sender.go">https://github.com/huangyisan/email-resource/blob/master/out/sender.go</a></p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s.port == <span class="string">&quot;465&quot;</span> &#123;</span><br><span class="line">	fmt.Fprintln(os.Stderr, <span class="string">&quot;Dialing with TLS for 465 Port...&quot;</span>)</span><br><span class="line">	conn, err := tls.Dial(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>,s.host,s.port), s.tlsConfig())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>  &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;unable to start TLS&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c, err = smtp.NewClient(conn, s.host)</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	c, err = smtp.Dial(fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, s.host, s.port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;Error Dialing smtp server&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ok, _ := c.Extension(<span class="string">&quot;STARTTLS&quot;</span>); ok &#123;</span><br><span class="line">		config := s.tlsConfig()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err = c.StartTLS(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;unable to start TLS&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在建联初期，使用<strong>tls.Dial</strong>方法，传入tls的配置进行建联，得到一个conn对象，然后使用<strong>smtp.NewClient</strong>方法传入conn对象，得到*<strong>smtp.Client</strong>对象, 让该对象进行邮件发送处理。</p>
<p>refer</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/15796530/what-is-the-difference-between-ports-465-and-587">https://stackoverflow.com/questions/15796530/what-is-the-difference-between-ports-465-and-587</a></p>
</blockquote>
<blockquote>
<p><a href="https://sendgrid.com/blog/what-is-starttls/">https://sendgrid.com/blog/what-is-starttls/</a></p>
</blockquote>
<blockquote>
<p><a href="https://sendgrid.com/blog/whats-the-difference-between-ports-465-and-587/">https://sendgrid.com/blog/whats-the-difference-between-ports-465-and-587/</a></p>
</blockquote>
<blockquote>
<p><a href="https://gist.github.com/chrisgillis/10888032">https://gist.github.com/chrisgillis/10888032</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>True or False</title>
    <url>/2018/12/17/True-or-False/</url>
    <content><![CDATA[<h2 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h2><p>先来看一段代码:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;&gt;&gt;</span> <span class="number">2</span> <span class="string">in</span> [<span class="number">1</span>,<span class="number">0</span>] <span class="string">==</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>起先我认为输出的结果是True，因为 2 in [1,0] 为False，接着False == False 返回的是True。</p>
<a id="more"></a>

<p>后来发现，这个其实是<strong>链式比较(chained comparisons)**，这种比较法，常见的为类似1&lt;2&lt;3这种，能立马反应过来，其实质为 1&lt;2 and 2&lt;3。<br>所以2 in [1,0] == False的本质其实为</strong>(2 in [1,0]) and ([1,0] == False)**，很显然，前面的返回为False，后面的返回也为False，False and False的结果为False，所以最终得到的结果为False。</p>
<p>如下比较符号进行组合，都为链式比较<br>“&lt;” | “&gt;” | “==” | “&gt;=” | “&lt;=” | “&lt;&gt;” | “!=” | “is” [“not”] | [“not”] “in”</p>
<blockquote>
<p><a href="https://docs.python.org/2/reference/expressions.html#comparisons">https://docs.python.org/2/reference/expressions.html#comparisons</a></p>
</blockquote>
<h2 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h2><p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&quot;</span> <span class="keyword">in</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>空字符串始终被视为任何其他字符串的子字符串</strong>，所以其返回为True。<br><strong>字符串的比较等价于find()方法，x in y 等价于y.find(x) != -1。</strong><br>当find()执行结果为-1的时候，表示x不是y的子字符串，反之，则x为y的子字符串。空字符串的执行结果如下:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&quot;abc&quot;</span>.<span class="builtin-name">find</span>(<span class="string">&#x27;&#x27;</span>) != -1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.python.org/3/reference/expressions.html#membership-test-operations">https://docs.python.org/3/reference/expressions.html#membership-test-operations</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>bash fork: retry: Resource temporarily unavailable</title>
    <url>/2019/01/02/bash-fork-retry-Resource-temporarily-unavailable/</url>
    <content><![CDATA[<h2 id="修改ulimit无法解决fork不出子进程的问题"><a href="#修改ulimit无法解决fork不出子进程的问题" class="headerlink" title="修改ulimit无法解决fork不出子进程的问题"></a>修改ulimit无法解决fork不出子进程的问题</h2><p>现场没有保留，大抵经过如下：<br>朋友的一台系统为Ubuntu的机器，上面启动了一个进程，该进程会fork出子进程，但是当root用户所有的进程数到一万多后就无法继续fork了，输入命令开始报错<code>bash fork: retry: Resource temporarily unavailable</code></p>
<a id="more"></a>

<p>排查经过：</p>
<ol>
<li>起先我以为是ulimit的配置没修改，或者不够大，但使用ulimit -u看了下，65535，足够大了。</li>
<li>感觉虽然ulimit调整了，但是执行中的进程limit并没有到达65535，于是乎，去/proc/pid/limit查看了，发现max process也是65535。</li>
<li>那么不成是内存，cpu之类的(其实想想也不太可能，内存小也不会报fork错误)，看了发现完全够用。</li>
</ol>
<p>这下懵圈了</p>
<p><code>bash fork: retry: Resource temporarily unavailable</code> 这个报错绝逼是某个参数的配置配小了。</p>
<p>由于是Ubuntu的系统，所以和平常用的centos还是有区别的。选择谷歌了，查来查去，一堆人都说是修改ulimit参数。</p>
<p>最后是找到了这篇文章：</p>
<blockquote>
<p><a href="https://askubuntu.com/questions/845380/bash-fork-retry-resource-temporarily-unavailable">https://askubuntu.com/questions/845380/bash-fork-retry-resource-temporarily-unavailable</a></p>
</blockquote>
<p>里面让修改的地方是一个名为pid.max的文件，和我机器路径稍微有点出入，我的路径是在<code>/sys/fs/cgroup/pids/user.slice/user-0.slice/pid.max</code> 这个数值只有10813，所以<code>ps -eLf | wc -l</code>到一万七八就上不去了。</p>
<ul>
<li>这个文件的数量改动后立马生效，不需要重启</li>
<li>重启机器后，这个值又会还原成10813，看来Ubuntu系统默认pid.max的值为10813(当时我没注意Ubuntu具体是哪个版本。。。。)，这个值如何产生的目前还不太清楚。</li>
</ul>
<h2 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h2><p>在centos7上</p>
<ul>
<li>获取当前进程数：<code>cat /sys/fs/cgroup/pids/pids.current</code>   类似使用<code>ps -ef | wc -l</code></li>
<li>获取当前<strong>线程数和进程数</strong>总和：<code>wc -l /sys/fs/cgroup/pids/tasks</code>  类似使用<code>ps -eLf | wc -l</code></li>
</ul>
<p>centos7上也是可以实现pid.max：<br>只需要在/sys/fs/cgroup/pids/下创建以为目录，则该目录中就会自动创建pid.max：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[root@leanote test]</span># <span class="selector-tag">pwd</span></span><br><span class="line">/<span class="selector-tag">sys</span>/<span class="selector-tag">fs</span>/<span class="selector-tag">cgroup</span>/<span class="selector-tag">pids</span>/<span class="selector-tag">test</span></span><br><span class="line"><span class="selector-attr">[root@leanote test]</span># <span class="selector-tag">ls</span></span><br><span class="line"><span class="selector-tag">cgroup</span><span class="selector-class">.clone_children</span>  <span class="selector-tag">cgroup</span><span class="selector-class">.event_control</span>  <span class="selector-tag">cgroup</span><span class="selector-class">.procs</span>  <span class="selector-tag">notify_on_release</span>  <span class="selector-tag">pids</span><span class="selector-class">.current</span>  <span class="selector-tag">pids</span><span class="selector-class">.max</span>  <span class="selector-tag">tasks</span></span><br></pre></td></tr></table></figure>
<p>对当前shell交互进程限制</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@leanote</span> <span class="string">test</span>]<span class="comment"># ls</span></span><br><span class="line"><span class="string">cgroup.clone_children</span>  <span class="string">cgroup.event_control</span>  <span class="string">cgroup.procs</span>  <span class="string">notify_on_release</span>  <span class="string">pids.current</span>  <span class="string">pids.max</span>  <span class="string">tasks</span></span><br><span class="line">[<span class="string">root@leanote</span> <span class="string">test</span>]<span class="comment"># cat cgroup.procs </span></span><br><span class="line">[<span class="string">root@leanote</span> <span class="string">test</span>]<span class="comment"># echo $$</span></span><br><span class="line"><span class="number">14514</span></span><br><span class="line">[<span class="string">root@leanote</span> <span class="string">test</span>]<span class="comment"># echo 14514 &gt; cgroup.procs </span></span><br><span class="line">[<span class="string">root@leanote</span> <span class="string">test</span>]<span class="comment"># echo 1 &gt; pids.max </span></span><br><span class="line"><span class="string">-bash:</span> <span class="attr">fork: retry:</span> <span class="literal">No</span> <span class="string">child</span> <span class="string">processes</span></span><br><span class="line"><span class="string">-bash:</span> <span class="attr">fork:</span> <span class="string">Resource</span> <span class="string">temporarily</span> <span class="string">unavailable</span></span><br><span class="line"><span class="string">-bash:</span> <span class="attr">fork: retry:</span> <span class="literal">No</span> <span class="string">child</span> <span class="string">processes</span></span><br><span class="line"><span class="string">-bash:</span> <span class="attr">fork: retry:</span> <span class="literal">No</span> <span class="string">child</span> <span class="string">processes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给pid.max输入1后，直接就出<code>-bash: fork: retry: No child processes</code>报错了。</li>
<li>pid.max只会对cgroup.procs中存在的进程进行pid.max限制。</li>
<li>当进程消失后,cgroup.procs中的进程号也会自动消失。</li>
</ul>
<p>在上一级不存在pid.max是因为对整个系统没必要做限制。<br>Ubuntu系统上<code>/sys/fs/cgroup/pids/user.slice/user-0.slice/pid.max</code>这个其实是对用户编号为0的用户进行了pid.max的限制。</p>
<p>refer:</p>
<p>知乎上看到有个小伙伴也遇到这个问题了</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/29192624">https://zhuanlan.zhihu.com/p/29192624</a></p>
</blockquote>
<p>fork的文档</p>
<blockquote>
<p><a href="http://man7.org/linux/man-pages/man2/fork.2.html">http://man7.org/linux/man-pages/man2/fork.2.html</a></p>
</blockquote>
<p>cgroup介绍</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000007241437">https://segmentfault.com/a/1190000007241437</a><br><a href="https://mccxj.github.io/blog/20171230_os-thread-limit.html">https://mccxj.github.io/blog/20171230_os-thread-limit.html</a></p>
</blockquote>
<p>cgroup 进程数限制</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000007468509">https://segmentfault.com/a/1190000007468509</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7网卡改名</title>
    <url>/2018/12/27/centos7%E7%BD%91%E5%8D%A1%E6%94%B9%E5%90%8D/</url>
    <content><![CDATA[<p>客户瞎搞，两张网卡，说是看着名称不爽，自行修改了网卡名，为bond0和bond1，bond1能启动，而bond0无法启动。<br>我这边接手擦屁股。</p>
<p>先说udev服务，然后再看问题产生的原因。</p>
<h2 id="system-udevd进程"><a href="#system-udevd进程" class="headerlink" title="system-udevd进程"></a>system-udevd进程</h2><p>在centos6中为udevd进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_31_91_centos6 ~]# ps -ef | grep udev</span><br><span class="line">root       470     1  0 01:17 ?        00:00:00 /sbin/udevd -d</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>在centos7中为system-udevd进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_31_91_centos7 ~]# ps -ef | grep udev</span><br><span class="line">root       460     1  0 10月09 ?      00:00:00 /usr/lib/systemd/systemd-udevd</span><br></pre></td></tr></table></figure>
<ul>
<li><p>udev的作用是：<br><code>man udev</code><br>receives device uevents directly from the kernel whenever a device is added or removed from the system, or it changes its state.<br>当有设备从系统插入或者拔出，或者改变了状态的时候，内核会直接收到设备uevents。</p>
</li>
<li><p>udev rules文件存在位置：</p>
</li>
</ul>
<ol>
<li>system rules directory: /usr/lib/udev/rules.d</li>
<li>volatile runtime directory: /run/udev/rules.d</li>
<li>local administration directory: /etc/udev/rules.d</li>
</ol>
<ul>
<li>udev读取文件规则：</li>
</ul>
<ol>
<li>读取这些目录下以.rules为后缀的文件。</li>
<li>文件先后顺序和其所在目录无关，和文件的名称顺序有关。</li>
<li>若不同目录存在相同的文件，则根据目录名称来排优先级顺序。/etc&gt;/run&gt;/usr</li>
</ol>
<ul>
<li>udev进行网卡重命名<blockquote>
<p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsg">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsg</a></p>
</blockquote>
</li>
</ul>
<p><strong>优先查询的是<code>/usr/lib/udev/rules.d/60-net.rules</code>配置文件。</strong>如果发现包含 HWADDR 条目的 ifcfg 文件与某个接口的 MAC 地址匹配，它会将该接口重命名为 ifcfg 文件中由 DEVICE 指令给出的名称。</p>
<h2 id="问题产生的原因"><a href="#问题产生的原因" class="headerlink" title="问题产生的原因"></a>问题产生的原因</h2><p>当时发现<code>/usr/lib/udev/rules.d/60-net.rules</code>文件内已经存在了bond1的配置，而bond0的配置写到了<code>/etc/udev/rules.d/70-persistent-net.rules</code>里面，由于60的优先级高于70，所以bond0网卡一直起不来。</p>
<p>其实centos7已经不用<code>70-persistent-net.rules</code>这个文件了，在centos6中，删除了<code>70-persistent-net.rules</code>文件，他会通过<code>/lib/udev/write_net_rules</code>文件来生成，但centos7已经不存在该文件了，centos7是使用<code>/lib/udev/rename_device</code>文件来生成<code>/usr/lib/udev/rules.d/60-net.rules</code>。</p>
<h2 id="合理修改centos7网卡名称流程"><a href="#合理修改centos7网卡名称流程" class="headerlink" title="合理修改centos7网卡名称流程"></a>合理修改centos7网卡名称流程</h2><p>首先修改当前网卡名称</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">/sbin<span class="built_in">/ip </span>link <span class="builtin-name">set</span> eth1 down</span><br><span class="line">/sbin<span class="built_in">/ip </span>link <span class="builtin-name">set</span> eth1 name eth123</span><br><span class="line">/sbin<span class="built_in">/ip </span>link <span class="builtin-name">set</span> eth123 up</span><br></pre></td></tr></table></figure>
<p>然后在<code>/usr/lib/udev/rules.d/60-net.rules</code>中加入配置策略<br>ACTION==”add”, SUBSYSTEM==”net”, DRIVERS==”?*”, ATTR{address}==”00:50:56:8e:3f:a7”, NAME=”eth123”</p>
<p>最后修改ifcfg-xxx里面的NAME和DEVICE字段值为eth123。</p>
<p>重启网卡即可。</p>
<p>refer:</p>
<blockquote>
<p><a href="https://www.freedesktop.org/software/systemd/man/udev.html#">https://www.freedesktop.org/software/systemd/man/udev.html#</a><br><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsg">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsg</a><br><a href="https://unix.stackexchange.com/questions/205010/centos-7-rename-network-interface-without-rebooting">https://unix.stackexchange.com/questions/205010/centos-7-rename-network-interface-without-rebooting</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>concourse食用指北01-自动创建pipelines</title>
    <url>/2020/10/19/concourse%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%9701-%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BApipelines/</url>
    <content><![CDATA[<p>之前没有接触过使用concourse做ci/cd工具，这次进行了尝试，该文档主要是记录了对使用过程中的一些改进。</p>
<p>我这边会记录对每个需求的设计和改进。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>只需要提交代码，能让concourse自动创建pipelines。</li>
</ol>
<a id="more"></a>

<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>concourse有别于jenkins，其UI主要是用来查看pipelines/jobs的状态，在页面不允许创建，修改或者删除pipelines。</li>
<li>创建pipelines通过cli的方式可以使用<code>set-pipeline</code>命令来实现，具体语句为<code>fly -t main set-pipeline -p $&#123;pipeline_name&#125; -c $&#123;config_file&#125;</code>。</li>
<li>pipeline yaml中可以使用<code>set_pipeline</code>关键字来生成pipeline。</li>
</ol>
<h3 id="初版目录结构"><a href="#初版目录结构" class="headerlink" title="初版目录结构"></a>初版目录结构</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── pipelines</span><br><span class="line">├── README.md</span><br><span class="line">└── set-pipelines.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结构说明</strong></p>
<ol>
<li>pipelines目录用于存放子pipelines。</li>
<li>set-pipelines.yml文件中定义了待创建的pipelines，例如如下部分，表明创建一个名称为test-pipeline，该pipelines的生成是根据set-pipeline/pipelines/test-pipeline.yml配置文件。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set-pipelines</span></span><br><span class="line">    <span class="attr">plan:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">set-pipeline</span></span><br><span class="line">        <span class="attr">trigger:</span> <span class="literal">true</span> <span class="comment"># 触发式更新</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">set_pipeline:</span> <span class="string">test-pipeline</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">set-pipeline/pipelines/test-pipeline.yml</span></span><br><span class="line"><span class="string">***</span></span><br></pre></td></tr></table></figure>
<h3 id="初版存在的问题"><a href="#初版存在的问题" class="headerlink" title="初版存在的问题"></a>初版存在的问题</h3><ol>
<li>虽然子pipeline的更新无需手动了，但set-pipelines.yml文件的更新还是需要手工执行fly -t main set-pipeline的命令。</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>引入一个总控的pipeline，去控制set-pipelines.yml</li>
<li>当pipeline代码仓库更新的时候，self-update.yml去触发更新set-pipelines.yml，而self-update.yml定义好后一般无需对其进行修改。</li>
</ol>
<h3 id="第二版目录结构"><a href="#第二版目录结构" class="headerlink" title="第二版目录结构"></a>第二版目录结构</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">├──</span> <span class="string">pipelines</span></span><br><span class="line"><span class="string">├──</span> <span class="string">README.md</span></span><br><span class="line"><span class="string">├──</span> <span class="string">self-update.yml</span></span><br><span class="line"><span class="string">└──</span> <span class="string">set-pipelines.yml</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结构说明</strong></p>
<ol>
<li>self-update,yml该文件用于控制set-pipelines.yml，其对set-pipelines,yml的文件控制也是采用了set-pipeline</li>
</ol>
<h3 id="第二版存在的问题"><a href="#第二版存在的问题" class="headerlink" title="第二版存在的问题"></a>第二版存在的问题</h3><ol>
<li>如果添加子pipeline，需要两步走，第一步在pipelines文件夹内放入子pipeline定义的yaml文件，第二步，修改set-pipelines.yml文件，新增子pipeline在set-pipeline上下文的定义。</li>
</ol>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>采用动态的方式生成set-pipelines.yml文件，也就是在concouse运行的时候，根据目录结构自动生成set-pipelines.yml，从而满足需求。</li>
</ol>
<h3 id="第三版目录结构"><a href="#第三版目录结构" class="headerlink" title="第三版目录结构"></a>第三版目录结构</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">├──</span> <span class="string">pipeline_render.py</span></span><br><span class="line"><span class="string">├──</span> <span class="string">pipelines</span></span><br><span class="line"><span class="string">├──</span> <span class="string">README.md</span></span><br><span class="line"><span class="string">├──</span> <span class="string">self-update.yml</span></span><br><span class="line"><span class="string">├──</span> <span class="string">set-pipelines.jinja</span></span><br></pre></td></tr></table></figure>
<p><strong>结构说明</strong></p>
<ol>
<li>新增set-pipelines.jinja以及pipeline_render.py两个文件，pipeline_render.py读取pipelines目录下的文件，根据set-pipelines.jinja模板动态生成set-pipelines.yml，提供给concouse使用。</li>
</ol>
<h3 id="实现知识点"><a href="#实现知识点" class="headerlink" title="实现知识点"></a>实现知识点</h3><ol>
<li>配合python镜像，对pipelines仓库下pipelines目录进行set-pipelines.yml文件渲染。</li>
<li>定义outputs，将渲染好的新内容定向到该outputs中。</li>
<li>根据outputs的路径，进行set-pipelines。</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>self-update.yml的job执行必须在set-pipelines.yml的job之前执行完成，所以需要给set-pipelines.yml一个delay的延时，如果set-pipelines.yml的job先于self-update.yml执行完成，则子pipelines无法会更新。</li>
</ol>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concourse</tag>
      </tags>
  </entry>
  <entry>
    <title>concourse食用指北02-镜像构建</title>
    <url>/2020/10/19/concourse%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%9702-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>根据仓库的dockerfile，自动构建镜像，并且推送到镜像仓库</li>
</ol>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>镜像构建可以使用<a href="https://github.com/concourse/docker-image-resource">docker-image-resource</a></li>
</ol>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>拉取dockerfile代码仓库</li>
<li>构建镜像</li>
<li>推送到镜像仓库</li>
</ol>
<h3 id="第一版pipeline部分配置"><a href="#第一版pipeline部分配置" class="headerlink" title="第一版pipeline部分配置"></a>第一版pipeline部分配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">git-repo</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">gitlab</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">((repository.gitlab.url))/test.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">((repository.gitlab.username))</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">((repository.gitlab.password))</span></span><br><span class="line">    <span class="attr">tag_filter:</span> <span class="string">&quot;v*&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-image</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">((repository.harbor.url))/test-image</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">((repository.harbor.username))</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">((repository.harbor.password))</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">publish</span></span><br><span class="line">  <span class="attr">serial:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">do:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">git-repo</span></span><br><span class="line">      <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">put:</span> <span class="string">test-image</span></span><br><span class="line">      <span class="attr">params:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">git-repo</span></span><br><span class="line">        <span class="attr">tag_file:</span> <span class="string">git-repo/.git/ref</span></span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>定义两个resource，一个为git类型，用于git仓库的操作；另外一个为docker-image类型，用于镜像构建以及镜像仓库的操作。</li>
<li>jobs的put阶段，表示对dockerfile的构建，以及镜像仓库的推送。</li>
<li>tag_file用于给定镜像的tag，这边使用.git/ref表示，git仓库用的哪个tag，则将该tag添加给镜像。</li>
</ol>
<h3 id="SemVer捕获"><a href="#SemVer捕获" class="headerlink" title="SemVer捕获"></a>SemVer捕获</h3><ol>
<li>让镜像tag使用Semantic Versioning</li>
<li>docker的镜像tag采用<a href="https://semver.org/">SemVer</a>的方式，而代码仓库的tag未必完全遵循了SemVer。</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>开发协商代码仓库的tag使用规范。</li>
<li>concourse编写task，用正则的方式捕获tag中SemVer部分。</li>
<li>镜像构建的时候采用上步骤中捕获到的SemVer。</li>
</ol>
<h3 id="第二版pipeline部分配置"><a href="#第二版pipeline部分配置" class="headerlink" title="第二版pipeline部分配置"></a>第二版pipeline部分配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">publish</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">do:</span></span><br><span class="line">    <span class="string">***</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">get-servmer</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">concourse-brain/tasks/get-sermver.yaml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">put:</span> <span class="string">test-image</span></span><br><span class="line">      <span class="attr">params:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">git-repo</span></span><br><span class="line">        <span class="attr">tag_file:</span> <span class="string">git-repo-tag/tag</span></span><br><span class="line">    <span class="string">***</span></span><br></pre></td></tr></table></figure>
<p><code>git-repo-tag/tag</code>该文件记录了task执行后捕获到的SemVer</p>
<p><strong>get-sermver.yaml 部分task配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="attr">run:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/bin/sh</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">    <span class="string">cd</span> <span class="string">git-repo</span></span><br><span class="line">    <span class="string">last_tag=$(git</span> <span class="string">describe</span> <span class="string">--tags</span> <span class="string">$(git</span> <span class="string">rev-list</span> <span class="string">--tags</span> <span class="string">--max-count=1))</span></span><br><span class="line">    <span class="string">echo</span> <span class="string">$&#123;last_tag&#125;</span> <span class="string">&gt;</span> <span class="string">last_tag</span></span><br><span class="line">    <span class="string">res=$(perl</span> <span class="string">-nle&#x27;print</span> <span class="string">$&amp;</span> <span class="string">while</span> <span class="string">m&#123;REGEX&#125;g&#x27;</span> <span class="string">last_tag)</span></span><br><span class="line">    <span class="string">if</span> [ <span class="string">!</span> <span class="string">-n</span> <span class="string">&quot;$res&quot;</span> ] <span class="string">;then</span> <span class="string">echo</span> <span class="string">$&#123;last_tag&#125;</span> <span class="string">&gt;</span> <span class="string">../outputs-file/tag;</span> <span class="string">else</span> <span class="string">echo</span> <span class="string">$&#123;res&#125;</span> <span class="string">&gt;</span> <span class="string">../git-repo-tag/tag</span> <span class="string">;fi</span></span><br></pre></td></tr></table></figure>
<p>主要是将tag进行正则匹配，写入git-repo-tag/tag，供docker-image resource读取。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>一般alpine，busybox等镜像没有pcre库，也就是grep无法支持perl模式-P，导致一些正则无法正常匹配。</li>
<li>安装pcre产生的镜像空间远大于安装perl，可以直接采用perl的方式来解决上述问题。具体语法为<code>perl -nle&#39;print $&amp; while m&#123;REGEX&#125;g&#39; file</code></li>
</ol>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concourse</tag>
      </tags>
  </entry>
  <entry>
    <title>concourse食用指北03-HelmChart构建</title>
    <url>/2020/10/20/concourse%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%9703-HelmChart%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>根据仓库的helm chart，自动构建Chart，并且推送到Chart仓库</li>
</ol>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ol>
<li>没有合适的resource，需要自己通过脚本实现。</li>
<li>需要自己构建helm的镜像，用于chart的推送。</li>
</ol>
<a id="more"></a>


<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先构建用于helm打包chart的基础镜像</li>
<li>编写打包脚本</li>
<li>配合脚本镜像chart打包，并上传至chart仓库</li>
</ol>
<h3 id="helm基础镜像dockerfile部分内容"><a href="#helm基础镜像dockerfile部分内容" class="headerlink" title="helm基础镜像dockerfile部分内容"></a>helm基础镜像dockerfile部分内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">COPY helm /usr/local/bin/helm</span><br><span class="line">RUN chmod +x /usr/local/bin/helm</span><br><span class="line">RUN helm plugin install https://github.com/chartmuseum/helm-push</span><br><span class="line">RUN helm repo add --username=xxx --password=&#x27;yyy&#x27; harbor https:/hubname.com/chartrepo/yourreponame</span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>将helm二进制文件添加到镜像中。</li>
<li>安装helm-push插件，用于构建中push chart。</li>
<li>添加helm源。</li>
</ol>
<h3 id="chart打包推送脚本部分内容"><a href="#chart打包推送脚本部分内容" class="headerlink" title="chart打包推送脚本部分内容"></a>chart打包推送脚本部分内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">chart_name=`cat $1/Chart.yaml | grep -E &quot;^name&quot;| awk &#x27;&#123;print $NF&#125;&#x27;`</span><br><span class="line">chart_version=`cat $1/Chart.yaml | grep -E &quot;^version&quot;| awk &#x27;&#123;print $NF&#125;&#x27;`</span><br><span class="line">helm package $1</span><br><span class="line">repo_name=`helm repo list | grep -E &quot;$&#123;Harbor_Url&#125;&quot; | awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">helm push $&#123;package_info&#125; $&#123;repo_name&#125;</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>chart的名称以及version是从Chart.yaml文件中获取。</li>
<li>打包后推送至当前helm镜像中的chart仓库中。</li>
</ol>
<h3 id="推送chart-pipeline部分配置"><a href="#推送chart-pipeline部分配置" class="headerlink" title="推送chart pipeline部分配置"></a>推送chart pipeline部分配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-script</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">gitlab</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">((repository.gitlab.url))/xxx/harbor-script.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">((repository.gitlab.username))</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">((repository.gitlab.password))</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">chart-template</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">gitlab</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">((repository.gitlab.url))/helmchart/mysql.git</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">((repository.gitlab.username))</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">((repository.gitlab.password))</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">upload-chart</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">harbor-script</span></span><br><span class="line">      <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">get:</span> <span class="string">chart-template</span></span><br><span class="line">      <span class="attr">trigger:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">task:</span> <span class="string">upload-helm</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">platform:</span> <span class="string">linux</span></span><br><span class="line">        <span class="attr">image_resource:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">          <span class="attr">source:</span> </span><br><span class="line">            <span class="attr">repository:</span> <span class="string">((repository.harbor.url))/helm-box</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">((repository.harbor.username))</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">((repository.harbor.password))</span></span><br><span class="line">            <span class="attr">tag:</span> <span class="string">v1.3</span></span><br><span class="line">        <span class="attr">inputs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-script</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">chart-template</span></span><br><span class="line">        <span class="attr">run:</span></span><br><span class="line">          <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/bin/sh</span></span><br><span class="line">          <span class="attr">args:</span> [<span class="string">&quot;harbor-script/Upload-Chart.sh&quot;</span>,<span class="string">&quot;mysql&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>将harbor-script以及chart-template两个resource获取到。</li>
<li>将上述两个资源作为inputs提供给helm-box使用。</li>
<li>在helm-box中执行Upload-Chart.sh脚本，传入待打包的路径名。</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>上述功能，可以自定义编写成自定义的resource，这样传入的变量可以进行更好的控制。</li>
</ol>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concourse</tag>
      </tags>
  </entry>
  <entry>
    <title>concourse食用指北04-编写一个自定义resource</title>
    <url>/2020/10/20/concourse%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%9704-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89resource/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>编写一个自定义微信告警resource</li>
</ol>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>一个resource的执行有三个阶段组成，<code>check</code>，<code>in</code>，<code>out</code>。</li>
<li>任意一个阶段，传入的字段都为固定，且都有其固定的标准输出格式。</li>
<li>check对应check，in阶段对应yaml中的<code>get</code>，out阶段对应yaml中的<code>put</code>。</li>
<li>如果要在concourse ui打印输出，则需要将标准输出重定向到标准错误输出。</li>
<li>in阶段和out阶段只是逻辑上对你的resource代码进行区别，并不是强制某些代码必须写在in阶段。而check阶段的代码则是强制。</li>
<li>三个阶段执行顺序为check阶段，in阶段，out阶段。</li>
<li>编写的dockerfile需要将check in out作为可执行文件放入/opt/resource下面。</li>
</ol>
<a id="more"></a>

<h3 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h3><ol>
<li>check阶段为资源执行的第一个阶段，主要用于检查资源的最新版本。</li>
<li>传入两个字段，一个为source，一个为version， 例如<code>&#123;“source”: &#123;“url”: “git-url”,  “user”: “abc”, “password”: “xyz”&#125;, “version”: &quot;777&quot;&#125;</code></li>
<li>标准输出则为数组形式的kv键值对[{“key1”: “value”, “key2”:” value2”}]</li>
</ol>
<h3 id="in阶段"><a href="#in阶段" class="headerlink" title="in阶段"></a>in阶段</h3><ol>
<li>in阶段为check之后的第二个阶段。</li>
<li>在out阶段执行完毕后，也会再次执行in阶段，用于预期目标的验证。</li>
<li>in阶段传入三个字段，source，version，params，例如<code>&#123;“source”: &#123;“url”: “git-url”,  “user”: “abc”, “password”: “xyz”&#125;, “version”: &quot;777&quot;, params:&#123;&quot;tag&quot;:123&#125;&#125;</code></li>
<li>其标准输出为以必须存在以”version”为key的多维字典，例如<code>&#123;&quot;version&quot;: &#123;&quot;key&quot;: version, &quot;metadata&quot;: [&#123; &quot;name&quot;: &quot;commit&quot;, &quot;value&quot;: &quot;61cebf&quot; &#125;,&#123; &quot;name&quot;: &quot;author&quot;, &quot;value&quot;: &quot;Hulk Hogan&quot; &#125;]&#125;&#125;</code></li>
</ol>
<h3 id="out阶段"><a href="#out阶段" class="headerlink" title="out阶段"></a>out阶段</h3><ol>
<li>out阶段为最后一个阶段。</li>
<li>out阶段传入三个字段source，params，例如<code>&#123;&quot;params&quot;: &#123;&quot;branch&quot;:&quot;develop&quot;,&quot;repo&quot;: &quot;some-repo&quot;&#125;,&quot;source&quot;: &#123;&quot;uri&quot;: &quot;git@...&quot;,&quot;private_key&quot;: &quot;...&quot;&#125;&#125;</code></li>
<li>其标准输出为必须存在以”version”为key的多维字典{“version”: { “ref”: “61cebf” },”metadata”:[{ “name”: “commit”, “value”: “61cebf” },{ “name”: “author”, “value”: “Mick Foley” }]}</li>
</ol>
<h2 id="尝试编写一个用于微信告警的resource-type"><a href="#尝试编写一个用于微信告警的resource-type" class="headerlink" title="尝试编写一个用于微信告警的resource type"></a>尝试编写一个用于微信告警的resource type</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>该resource不属于像git，docker-image等需要检查版本的resource，所以check阶段可以省略。但check脚本还是需要。</li>
<li>in阶段，因为只是告警，所以在自身resource中不需要尝试拉取任何资源。</li>
<li>out阶段，此阶段用于告警通知，需要规划变量进行传入。变量包含但不限于微信机器人token，告警内容，告警级别等。</li>
</ol>
<h3 id="check阶段部分代码"><a href="#check阶段部分代码" class="headerlink" title="check阶段部分代码"></a>check阶段部分代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_check</span>():</span></span><br><span class="line">    timestamp = get_timestamp()</span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;version&quot;</span>: timestamp, <span class="string">&quot;stage&quot;</span>: <span class="string">&quot;check&quot;</span>&#125;]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(json.dumps(_check()))</span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>这边没有直接打印空，而是采取打印时间戳，这样就能在concourse ui页面看到是否正常执行了check。</li>
</ol>
<h3 id="in阶段部分代码"><a href="#in阶段部分代码" class="headerlink" title="in阶段部分代码"></a>in阶段部分代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_check</span>():</span></span><br><span class="line">    timestamp = get_timestamp()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;version&quot;</span>: &#123;<span class="string">&quot;version&quot;</span>: timestamp, <span class="string">&quot;stage&quot;</span>: <span class="string">&quot;in&quot;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(json.dumps(_check()))</span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>雷同check部分代码。</li>
</ol>
<h3 id="out部分阶段代码"><a href="#out部分阶段代码" class="headerlink" title="out部分阶段代码"></a>out部分阶段代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_env</span>():</span></span><br><span class="line">    BUILD_PIPELINE_NAME = os.getenv(<span class="string">&#x27;BUILD_PIPELINE_NAME&#x27;</span>)</span><br><span class="line">    BUILD_PIPELINE_ID = os.getenv(<span class="string">&#x27;BUILD_PIPELINE_ID&#x27;</span>)</span><br><span class="line">    BUILD_NAME = os.getenv(<span class="string">&#x27;BUILD_NAME&#x27;</span>)</span><br><span class="line">    BUILD_TEAM_NAME = os.getenv(<span class="string">&#x27;BUILD_TEAM_NAME&#x27;</span>)</span><br><span class="line">    BUILD_JOB_NAME = os.getenv(<span class="string">&#x27;BUILD_JOB_NAME&#x27;</span>)</span><br><span class="line">    BUILD_ID = os.getenv(<span class="string">&#x27;BUILD_ID&#x27;</span>)</span><br><span class="line">    BUILD_TEAM_ID = os.getenv(<span class="string">&#x27;BUILD_TEAM_ID&#x27;</span>)</span><br><span class="line">    BUILD_JOB_ID = os.getenv(<span class="string">&#x27;BUILD_JOB_ID&#x27;</span>)</span><br><span class="line">    ATC_EXTERNAL_URL = os.getenv(<span class="string">&#x27;ATC_EXTERNAL_URL&#x27;</span>)</span><br><span class="line">    URL = <span class="string">&#x27;&#123;ATC_EXTERNAL_URL&#125;/teams/&#123;BUILD_TEAM_NAME&#125;/pipelines/&#123;BUILD_PIPELINE_NAME&#125;/jobs/&#123;BUILD_JOB_NAME&#125;/builds/&#123;BUILD_NAME&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        ATC_EXTERNAL_URL=ATC_EXTERNAL_URL,</span><br><span class="line">        BUILD_TEAM_NAME=BUILD_TEAM_NAME,</span><br><span class="line">        BUILD_PIPELINE_NAME=BUILD_PIPELINE_NAME,</span><br><span class="line">        BUILD_JOB_NAME=BUILD_JOB_NAME,</span><br><span class="line">        BUILD_NAME=BUILD_NAME)</span><br><span class="line">    env_dict = &#123;</span><br><span class="line">        <span class="string">&#x27;BUILD_PIPELINE_NAME&#x27;</span>: BUILD_PIPELINE_NAME,</span><br><span class="line">        <span class="string">&#x27;BUILD_PIPELINE_ID&#x27;</span>: BUILD_PIPELINE_ID,</span><br><span class="line">        <span class="string">&#x27;BUILD_NAME&#x27;</span>: BUILD_NAME,</span><br><span class="line">        <span class="string">&#x27;BUILD_TEAM_NAME&#x27;</span>: BUILD_TEAM_NAME,</span><br><span class="line">        <span class="string">&#x27;BUILD_JOB_NAME&#x27;</span>: BUILD_JOB_NAME,</span><br><span class="line">        <span class="string">&#x27;BUILD_ID&#x27;</span>: BUILD_ID,</span><br><span class="line">        <span class="string">&#x27;BUILD_TEAM_ID&#x27;</span>: BUILD_TEAM_ID,</span><br><span class="line">        <span class="string">&#x27;BUILD_JOB_ID&#x27;</span>: BUILD_JOB_ID,</span><br><span class="line">        <span class="string">&#x27;ATC_EXTERNAL_URL&#x27;</span>: ATC_EXTERNAL_URL,</span><br><span class="line">        <span class="string">&#x27;URL&#x27;</span>: URL</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> env_dict</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payload_data</span>(<span class="params">payload</span>):</span></span><br><span class="line">    <span class="comment"># source = payload[&quot;source&quot;]</span></span><br><span class="line">    source = payload[<span class="string">&quot;params&quot;</span>]</span><br><span class="line">    url = <span class="string">&quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/send&quot;</span> <span class="keyword">if</span> <span class="keyword">not</span> source.get(<span class="string">&quot;url&quot;</span>) <span class="keyword">else</span> source.get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    secret = source[<span class="string">&quot;secret&quot;</span>]</span><br><span class="line">    msgtype = <span class="string">&quot;markdown&quot;</span> <span class="keyword">if</span> <span class="keyword">not</span> source.get(<span class="string">&quot;msgtype&quot;</span>) <span class="keyword">else</span> source.get(<span class="string">&quot;msgtype&quot;</span>)</span><br><span class="line">    <span class="comment"># success, failed, abort</span></span><br><span class="line">    level = <span class="string">&quot;success&quot;</span> <span class="keyword">if</span> <span class="keyword">not</span> source.get(<span class="string">&quot;level&quot;</span>) <span class="keyword">else</span> source.get(<span class="string">&quot;level&quot;</span>)</span><br><span class="line">    content = <span class="string">&quot;No content&quot;</span> <span class="keyword">if</span> <span class="keyword">not</span> source.get(<span class="string">&quot;content&quot;</span>) <span class="keyword">else</span> source.get(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">    payload_dict = &#123;<span class="string">&quot;url&quot;</span>: url, <span class="string">&quot;secret&quot;</span>: secret, <span class="string">&quot;msgtype&quot;</span>: msgtype, <span class="string">&quot;level&quot;</span>: level,</span><br><span class="line">                    <span class="string">&quot;content&quot;</span>: content&#125;</span><br><span class="line">    <span class="keyword">return</span> payload_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_out</span>(<span class="params">stream</span>):</span></span><br><span class="line">    payload = get_args(stream)</span><br><span class="line">    payload_dict = payload_data(payload)</span><br><span class="line"></span><br><span class="line">    url, secret, msgtype, level, content = payload_dict.values()</span><br><span class="line"></span><br><span class="line">    data = message(msgtype, level, content)</span><br><span class="line">    post_message(url, secret, data)</span><br><span class="line">    timestamp = get_timestamp()</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;version&quot;</span>: &#123;<span class="string">&quot;version&quot;</span>: timestamp&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单说明</strong></p>
<ol>
<li>get_env函数用于获取concouse在up一个容器的时候传入的metadata，<strong>其metadata信息是作为环境变量存储在镜像里面的</strong>。</li>
<li>payload_data函数用于获取yaml配置中put的参数，通过从params中获取。</li>
<li>_out方法执行了向微信接口进行post数据，并最终返回标准输出给main函数进行打印。</li>
</ol>
<h2 id="dockerfile的编写"><a href="#dockerfile的编写" class="headerlink" title="dockerfile的编写"></a>dockerfile的编写</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol>
<li>需要将check in out三个文件放入/opt/resource下面。</li>
<li>给check in out文件可执行权限。</li>
</ol>
<h3 id="dockerfile样例"><a href="#dockerfile样例" class="headerlink" title="dockerfile样例"></a>dockerfile样例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">MAINTAINER anonymousyisan@gmail.com</span><br><span class="line"></span><br><span class="line">RUN apk add --update --no-cache python3  py-pip &amp;&amp; ln -sf python3 /usr/bin/python</span><br><span class="line">RUN pip install requests</span><br><span class="line"></span><br><span class="line">COPY assets/check.py /opt/resource/check</span><br><span class="line">COPY assets/in.py /opt/resource/in</span><br><span class="line">COPY assets/out.py /opt/resource/out</span><br><span class="line"></span><br><span class="line">RUN chmod +x /opt/resource/*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="yaml配置自定义resource"><a href="#yaml配置自定义resource" class="headerlink" title="yaml配置自定义resource"></a>yaml配置自定义resource</h2><h3 id="yaml部分配置"><a href="#yaml部分配置" class="headerlink" title="yaml部分配置"></a>yaml部分配置</h3><h4 id="定义resource-type以及定义resource"><a href="#定义resource-type以及定义resource" class="headerlink" title="定义resource type以及定义resource"></a>定义resource type以及定义resource</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resource_types:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wx-alert-resource</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">docker-image</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">dockerhuangyisan/wechat-notification-resource</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="string">latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wx-alert</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">wx-alert-resource</span></span><br></pre></td></tr></table></figure>
<h4 id="hook阶段执行put"><a href="#hook阶段执行put" class="headerlink" title="hook阶段执行put"></a>hook阶段执行put</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">publish</span></span><br><span class="line">  <span class="attr">plan:</span></span><br><span class="line">      <span class="string">****</span></span><br><span class="line">      <span class="attr">on_success:</span></span><br><span class="line">        <span class="attr">put:</span> <span class="string">wx-alert</span></span><br><span class="line">        <span class="attr">params:</span></span><br><span class="line">          <span class="attr">secret:</span> <span class="string">((wx.secret))</span></span><br><span class="line">          <span class="attr">msgtype:</span> <span class="string">markdown</span></span><br><span class="line">          <span class="attr">level:</span> <span class="string">success</span></span><br><span class="line">          <span class="attr">content:</span> <span class="string">Job</span> <span class="string">Success!</span></span><br></pre></td></tr></table></figure>
<h3 id="微信端告警样例"><a href="#微信端告警样例" class="headerlink" title="微信端告警样例"></a>微信端告警样例</h3><p><img src="https://assets.iostat.io/image/wechat_message.png" alt="wechat_message_example"></p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><ol>
<li>如果想在resource中进行调试，不要直接在标准输出中打印，因为concouse会捕获标准输出进行验证是否为合法VersionResult，所以处理办法就是将标准输出定向到标准错误输出中，python可以使用print(“strings”, file=sys.stderr),  shell可以exec 3&gt;&1;exec 1&gt;&amp;2。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>wechat notification resource源码地址:<a href="https://github.com/huangyisan/wechat_notification_resource">https://github.com/huangyisan/wechat_notification_resource</a></li>
<li>官方介绍: <a href="https://concourse-ci.org/implementing-resource-types.html">https://concourse-ci.org/implementing-resource-types.html</a></li>
<li><a href="https://medium.com/devops-dudes/writing-a-custom-concourse-resource-overview-1ed6d2983e39">https://medium.com/devops-dudes/writing-a-custom-concourse-resource-overview-1ed6d2983e39</a></li>
</ol>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concourse</tag>
      </tags>
  </entry>
  <entry>
    <title>concourse食用指北05-一些优化和技巧</title>
    <url>/2020/10/26/concourse%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%9705-%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E5%92%8C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="使用vscode编辑器"><a href="#使用vscode编辑器" class="headerlink" title="使用vscode编辑器"></a>使用vscode编辑器</h3><p>pipeline的yaml配置文件中，配置参数需要遵循上下文。倘若只根据官方文档列出来的去编写，可能会因为配置参数的缩进错误，放置层级的错误从而不断的修改，在没有完全上手的阶段，效率会比较底下。</p>
<p>可以尝试使用vscode，vscode有专门针对concourse pipeline配置的扩展，使用后会自动层级对齐，补全，错误提示等功能，极大提升编写效率。</p>
<p>直接在”扩展”里面搜索concourse ci pipeline editor, 安装完毕后，对于如下规则的yml文件就会默认启用插件功能。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">**/*pipeline*<span class="string">.yml</span> | **<span class="string">/pipeline/</span>*<span class="string">.yml</span> : activates support for editing pipelines</span><br><span class="line">**<span class="string">/tasks/</span>*<span class="string">.yml</span> | **/*task.yml : activates support for editing tasks.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="镜像的制作"><a href="#镜像的制作" class="headerlink" title="镜像的制作"></a>镜像的制作</h3><p>因为concourse运行的每一个task都是出于容器中，所以如果想快速的集成或者部署，那么可以控制一下容器的大小，毕竟如果一个容器的空间很大好几个G，那么拉取镜像就占用了不少时间。所以我个人建议，不采用大一桶的容器，容器尽量精简，只对task需要的功能进行添加。</p>
<h3 id="并行执行任务"><a href="#并行执行任务" class="headerlink" title="并行执行任务"></a>并行执行任务</h3><p>一些例如get获取镜像，代码等独立任务如果可以并行执行，则进行并行执行，这样可以提升效率。而且并行执行的编写也非常简单，只需要将任务定义在parallel同一层级下面即可。</p>
<h3 id="添加一些重试机制"><a href="#添加一些重试机制" class="headerlink" title="添加一些重试机制"></a>添加一些重试机制</h3><p>拉取镜像也好，推送镜像也好，难免会因为网络的问题导致任务失败，concourse pipeline配置里面可以添加<code>attempt</code>参数，指定重试次数，当失败的时候，则自动进行重试。</p>
<h3 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h3><p>防止一些job因特殊原因一直处于运行状态，比如资源不足从而编译打包镜像变得异常缓慢，此时可以对job设置<code>timeout</code>参数，预估一个大致能完成的时间，超过该时间，则直接job失败。</p>
<h3 id="相同的task进行抽取"><a href="#相同的task进行抽取" class="headerlink" title="相同的task进行抽取"></a>相同的task进行抽取</h3><p>有些task执行的行为相似，可能只是部分参数不一样，或者<code>input</code>，<code>output</code>不同，那么可以将这样的task单独抽取出来，使用file关键字对task的单独文件进行引入，然后将不一样的部分，使用<code>params</code>配置项上下文定义变量。就可以进行复用了，精简了配置。</p>
<h3 id="将一些统一的配置进行抽取"><a href="#将一些统一的配置进行抽取" class="headerlink" title="将一些统一的配置进行抽取"></a>将一些统一的配置进行抽取</h3><p>在set-pipeline阶段，可以将一些公共配置参数进行抽取，放到一个独立的文件内，使用<code>var_files</code>配置参数就能实现，比如远端服务器地址，repo的域名等，将这些配置提取的好处是，如果将来有一天进行修改，则不需要对每个pipeline进行修改，只需要修改一个文件即可。</p>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>concourse</tag>
      </tags>
  </entry>
  <entry>
    <title>css居中-垂直方向</title>
    <url>/2020/03/18/css%E5%B1%85%E4%B8%AD-%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p><a href="https://iostat.io/2020/03/14/css%E5%B1%85%E4%B8%AD-%E6%B0%B4%E5%B9%B3%E6%96%B9%E5%90%91/">查看如何水平居中</a></p>
<p><strong>垂直居中相对比较复杂</strong></p>
<h2 id="行级元素-inline-inline-类型-垂直居中"><a href="#行级元素-inline-inline-类型-垂直居中" class="headerlink" title="行级元素(inline inline-*类型)垂直居中"></a>行级元素(inline inline-*类型)垂直居中</h2><h3 id="单行情况"><a href="#单行情况" class="headerlink" title="单行情况"></a>单行情况</h3><ol>
<li>有时候看似居中了，其实是上下padding预留了相同的空间，所以中间的内容居中了。</li>
</ol>
<a id="more"></a>

<iframe height="265" style="width: 100%;" scrolling="no" title="Centering text (kinda) with Padding" src="https://codepen.io/huangyisan/embed/abOKwOq?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/abOKwOq'>Centering text (kinda) with Padding</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="2">
<li>不用padding，则可以将<code>line-height</code>和<code>height</code>的值设置相等。该方法比较常用。</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Centering a line with line-height" src="https://codepen.io/huangyisan/embed/yLNEXOg?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/yLNEXOg'>Centering a line with line-height</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<h3 id="多行情况"><a href="#多行情况" class="headerlink" title="多行情况"></a>多行情况</h3><ol>
<li>多行情况也可以用padding填充等量的上下空间。如果不采用这种方式，则可以使用如下模拟table或者直接table元素的方式。<ul>
<li>文字放到table里面进行处理。</li>
<li>使用css，模拟其他元素为table，来达到类似table的效果，但如果用了后者，则需要给<code>vertical-align: middle</code>属性。</li>
</ul>
</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Centering text (kinda) with Padding" src="https://codepen.io/huangyisan/embed/ExjRXgQ?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/ExjRXgQ'>Centering text (kinda) with Padding</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="2">
<li>如果不用table方法，可以使用flexbox的方法。将内容放到一个flex里面，然后采用column的排列方式，并且给<code>justify-content: center;</code>属性居中。<strong>并且父元素要有一个高度</strong>。</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Vertical Center Multi Lines of Text with Flexbox" src="https://codepen.io/huangyisan/embed/oNXywEV?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/oNXywEV'>Vertical Center Multi Lines of Text with Flexbox</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="3">
<li> 如果上面table和flex方式都不使用，则可以使用一种叫做“ghost element”的技术。在容器内设置一个<strong>全高度</strong>的伪元素，且<strong>让文字内容垂直对齐</strong>。</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Ghost Centering Multi Line Text" src="https://codepen.io/huangyisan/embed/zYGazaL?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/zYGazaL'>Ghost Centering Multi Line Text</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<h2 id="块级元素垂直居中"><a href="#块级元素垂直居中" class="headerlink" title="块级元素垂直居中"></a>块级元素垂直居中</h2><ol>
<li>待设定元素<strong>高度已知</strong>的情况下，可以使用绝对定位配合负margin-top的方式实现。<strong>这种方式，即便缩放父元素高度，子元素还是属于居中状态。</strong></li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Center Block with Fixed Height" src="https://codepen.io/huangyisan/embed/vYOrJWy?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/vYOrJWy'>Center Block with Fixed Height</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="2">
<li>待设定元素<strong>高度未知</strong>情况下，可以使用<code>transform: translateY(-50%)</code>来处理居中。<strong>这种方式，即便缩放子元素高度，也是能保持居中的。</strong></li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Center Block with Unknown Height" src="https://codepen.io/huangyisan/embed/RwPJZQK?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/RwPJZQK'>Center Block with Unknown Height</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="3">
<li>如果<strong>不考虑缩放</strong>的时候需要居中，则可以使用table或者用css来达到table的方式来实现。</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Center Block with Table Stretch" src="https://codepen.io/huangyisan/embed/dyoKzgp?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/dyoKzgp'>Center Block with Table Stretch</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="4">
<li>也可以用flex布局来实现，和行级元素垂直居中思想一致。</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Center Block with Unknown Height with Flexbox" src="https://codepen.io/huangyisan/embed/eYNKEQw?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/eYNKEQw'>Center Block with Unknown Height with Flexbox</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ol start="5">
<li>flex布局如果父元素不给<code>justify-content: center</code>属性，则可以在子元素上添加<code>margin: auto</code>来实现居中效果。</li>
</ol>
<iframe height="265" style="width: 100%;" scrolling="no" title="Center Block with Unknown Height with Flexbox" src="https://codepen.io/huangyisan/embed/eYNKEbw?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/eYNKEbw'>Center Block with Unknown Height with Flexbox</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>





<p>ref:</p>
<blockquote>
<p><a href="https://css-tricks.com/centering-css-complete-guide/">https://css-tricks.com/centering-css-complete-guide/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>css居中-水平方向</title>
    <url>/2020/03/14/css%E5%B1%85%E4%B8%AD-%E6%B0%B4%E5%B9%B3%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p><a href="https://iostat.io/2020/03/18/css%E5%B1%85%E4%B8%AD-%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91/">查看如何垂直居中</a></p>
<h2 id="行级元素-inline-inline-类型-水平居中"><a href="#行级元素-inline-inline-类型-水平居中" class="headerlink" title="行级元素(inline inline-*类型)水平居中"></a>行级元素(inline inline-*类型)水平居中</h2><ul>
<li>只需要将需要水平居中的行级元素包裹在<strong>父级块级</strong>元素内，对父级元素设置<code>text-align: center;</code>属性即可。</li>
<li>对<strong>inline, inline-block, inline-table, inline-flex</strong>等属性都适用。</li>
</ul>
<a id="more"></a>

<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="css,result" data-user="huangyisan" data-slug-hash="YzXaRWK" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Centering Inline Elements">
  <span>See the Pen <a href="https://codepen.io/huangyisan/pen/YzXaRWK">
  Centering Inline Elements</a> by huangyisan (<a href="https://codepen.io/huangyisan">@huangyisan</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>



<h2 id="一个块级元素水平居中"><a href="#一个块级元素水平居中" class="headerlink" title="一个块级元素水平居中"></a>一个块级元素水平居中</h2><ul>
<li>给该块级元素width属性，并且设置margin-left和margin-right皆为auto即可。</li>
<li>如果不给width属性，则宽度填满父级元素空间。</li>
</ul>
<iframe height="265" style="width: 100%;" scrolling="no" title="Centering Single Block Level Element" src="https://codepen.io/huangyisan/embed/yLNKQMv?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/yLNKQMv'>Centering Single Block Level Element</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<h2 id="多个块级元素水平居中"><a href="#多个块级元素水平居中" class="headerlink" title="多个块级元素水平居中"></a>多个块级元素水平居中</h2><ul>
<li><strong>方法一：</strong> 若干块级元素在同一行居中，可以给这些块级元素设定相同的display属性(但并不是每个display的属性都适合水平居中)，比如给定<code>inline-block</code>属性</li>
</ul>
<iframe height="265" style="width: 100%;" scrolling="no" title="Centering Row of Blocks" src="https://codepen.io/huangyisan/embed/qBdoLwj?height=265&theme-id=dark&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/qBdoLwj'>Centering Row of Blocks</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>



<ul>
<li><strong>方法二：</strong>也可以给这些块级元素采用flex布局，也就是给其<strong>父级元素</strong>添加<code>display: flex;</code>，然后再给<code>justify-content: center;</code></li>
</ul>
<iframe height="265" style="width: 100%;" scrolling="no" title="Centering Row of Blocks" src="https://codepen.io/huangyisan/embed/qBdoLwj?height=265&theme-id=dark&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/huangyisan/pen/qBdoLwj'>Centering Row of Blocks</a> by huangyisan
  (<a href='https://codepen.io/huangyisan'>@huangyisan</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>




<p>ref:</p>
<blockquote>
<p><a href="https://css-tricks.com/centering-css-complete-guide/">https://css-tricks.com/centering-css-complete-guide/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器权重</title>
    <url>/2019/03/05/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D/</url>
    <content><![CDATA[<h2 id="CSS选择器类型"><a href="#CSS选择器类型" class="headerlink" title="CSS选择器类型"></a>CSS选择器类型</h2><ul>
<li>id选择器<br><code>#id</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;mySelector&quot;&gt;this is id selector&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mySelector</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff4400</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<ul>
<li>class选择器<br><code>.class</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;myClass&quot;&gt;this is class selector&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myClass</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#F10882</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>*选择器<br><code>\*</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素选择器<br><code>element</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">p</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>伪类<br><code>:hover</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;https://www.baidu.com&quot;&gt;www.baidu.com&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父子选择器<br><code>element element</code><br><code>element&gt;element</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">p</span> <span class="selector-tag">in</span> <span class="selector-tag">div</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ff4400</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器<br><code>[attribute=value]</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;myclass&quot;&gt;this is div&lt;/div&gt;</span><br><span class="line"><span class="selector-attr">[class=myclass]</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff4400</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>组选择器<br><code>element,element1,element2</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;<span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">div</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">span</span>&gt;<span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">span</span>&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;<span class="selector-tag">this</span> <span class="selector-tag">is</span> <span class="selector-tag">p</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS选择器优先级"><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h2><p>优先级高的覆盖优先级低的样式。<br>!important &gt; 行间样式(直接元素内写style=xxx的方式) &gt; id &gt; class | 属性 &gt; 标签选择器 &gt; 通配符<br>其规则其实是由选择器权重实现的。</p>
<h2 id="CSS选择器权重"><a href="#CSS选择器权重" class="headerlink" title="CSS选择器权重"></a>CSS选择器权重</h2><p>权重大的覆盖权重小的，不同的选择器有不同的权重。</p>
<ul>
<li>!important  Infinity</li>
<li>行间样式   1000</li>
<li>id        100</li>
<li>class | 属性 | 伪类   10</li>
<li>标签 | 伪元素  1</li>
<li>通配符 0</li>
</ul>
<p><strong>进制据说是265。</strong></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言基本数字类型</title>
    <url>/2019/01/06/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="基本数字类型"><a href="#基本数字类型" class="headerlink" title="基本数字类型"></a>基本数字类型</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>int</li>
<li>long</li>
<li>short</li>
<li>unsigned</li>
<li>char</li>
<li>float</li>
<li>double</li>
<li>signed</li>
<li>_Bool (c99加入的bool类型)</li>
<li>_Complex (c99加入的复数类型)</li>
<li>_Imaginary  (c99加入的虚数类型)</li>
</ul>
<a id="more"></a>

<h3 id="有符号整形"><a href="#有符号整形" class="headerlink" title="有符号整形"></a>有符号整形</h3><p><strong>有符号类型可用于表示正整数和负整数。</strong></p>
<ul>
<li><p>int 系统给定的基本整数类型，c语言规定int类型不小于<code>16位</code>。</p>
</li>
<li><p>short或short int 最大的shrot类型整数小于或等于最大的int类型整数。c语言规定short类型至少占<code>16位</code>。</p>
</li>
<li><p>long或long int 该类型可表示的整数大于或等于最大的int类型整数。c语言规定long类型至少占位<code>32位</code>。</p>
</li>
<li><p>long long或long long int 该类型可以表示的整数大于或等于最大的long类型整数。long long 类型至少占<code>64位</code>。</p>
</li>
</ul>
<p><strong>一般而言，long类型的占用内存比short类型大，int类型的宽度要和和long类型相同，要么和short类型相同。</strong></p>
<h3 id="无符号整形"><a href="#无符号整形" class="headerlink" title="无符号整形"></a>无符号整形</h3><p><strong>无符号整形只能用于表示零和正整数，因此<code>无符号整形可以表示的正整数比有符号整形的大</code>。在整形类型前面加上关键字<code>unsigned</code>表明该类型是无符号整形。单独的unsigned相当于unsigned int。</strong></p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p><strong>char类型实际上存储的是整数，而非字符。ASCII编码范围是<code>0~127</code>，所以只需要<code>7位</code>二进制数表示即可(这里不包含中文日文等特殊字符集)。char类型表示一个字符要占用<code>1个字节</code>内存，出于历史原因，一个字节通常是<code>8位</code>，但是如果要表示基本字符集，也可以是16位或更大。</strong></p>
<ul>
<li>char 字符类型的关键字，有些编译器使用有符号的char，而有些则使用无符号的char。在需要时，可以在char前面加上关键字signed或unsigned来指明，具体使用哪一种类型。</li>
</ul>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>布尔值表示<code>true</code>和<code>false</code>。c语言用1表示<code>true</code>，0表示<code>false</code></strong></p>
<ul>
<li>_Bool 布尔类型的关键字，c99加入。其类型为无符号int类型，所占用的个空间只要能存储0或者1即可。</li>
</ul>
<h3 id="实浮点类型-实数浮点类型"><a href="#实浮点类型-实数浮点类型" class="headerlink" title="实浮点类型(实数浮点类型)"></a>实浮点类型(实数浮点类型)</h3><p><strong>实浮点类型可以表示正浮点数和负浮点数。</strong></p>
<ul>
<li><p>float 系统基本浮点类型，可精确表示至少6位有效数字。</p>
</li>
<li><p>double 存储浮点数的范围更大，能表示比float类型更多的有效数字(至少15位)和更大的指数。</p>
</li>
<li><p>long long 存储浮点束的范围比double更大，能表示比double更多的有效数字和更大的指数。</p>
</li>
</ul>
<h3 id="复数和虚数浮点数"><a href="#复数和虚数浮点数" class="headerlink" title="复数和虚数浮点数"></a>复数和虚数浮点数</h3><p><strong>虚数类型是可选的类型。复数的实部和虚部类型都基于<code>实浮点类型</code>来构成。</strong></p>
<ul>
<li>float _Complex</li>
<li>double _Complex</li>
<li>long double _Complex</li>
<li>float _Imaginary</li>
<li>double _Imaginary</li>
<li>long double _Imaginary</li>
</ul>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>getchar()存储类型</title>
    <url>/2018/12/20/getchar-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="getchar-返回类型声明为int类型"><a href="#getchar-返回类型声明为int类型" class="headerlink" title="getchar()返回类型声明为int类型"></a>getchar()返回类型声明为int类型</h2><p>getchar()函数从文本流读入下一个输入字符，并且作为结果返回。</p>
<p>一个读取字符，并且打印的程序，当读取end of file(EOF)的时候结束。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c != EOF) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>起先没搞明白为什么对c的声明是int类型，而不是char类型。</p>
<p>后来查阅资料得知，char类型的声明，会根据不同的编译器，或者不同的架构平台，可能成为unsigned char或者是signed char类型。</p>
<p>如果是unsigned char类型，<strong>占8位，一个字节，其范围为0000 0000 ~ 1111 1111，即0 ~ 255</strong>，那么无法存储EOF这个结束符，**EOF可以理解为数值-1(C89, C99, C11并没有给EOF定义一个具体的值，只是说EOF是一个负值常量)**。</p>
<p>而当被作为signed char类型，虽然其取值范围为-128 ~ +127，虽然能够存储EOF这个结束符，看似正常，但在linux的环境，会混淆char 255和EOF，导致输入数据的截断。</p>
<p>在linux平台运行以下程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter characters : &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((c= getchar()) != EOF)&#123;</span><br><span class="line">      <span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果可以发现\0377后面部分没有被打印。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">[root@VM_31_91_centos ~]<span class="comment"># gcc test.c &amp;&amp; echo -e &#x27;Hello world\0377And some more&#x27; | ./a.out</span></span><br><span class="line">Enter characters : Hello world[root@VM_31_91_centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>getchar()和putchar()初始返回的值都为int类型。</strong><br><strong>对于getchar()函数返回值的声明使用int类型</strong></p>
<h2 id="打印出EOF的值"><a href="#打印出EOF的值" class="headerlink" title="打印出EOF的值"></a>打印出EOF的值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    </span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c == EOF) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is the value of EOF:%d&quot;</span>,c);</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行程序，按<strong>CTRL+D发送EOF</strong>，查看得到的数值为-1。</p>
<ul>
<li>refer<blockquote>
<p><a href="https://stackoverflow.com/questions/18013167/why-must-the-variable-used-to-hold-getchars-return-value-be-declared-as-int">https://stackoverflow.com/questions/18013167/why-must-the-variable-used-to-hold-getchars-return-value-be-declared-as-int</a><br><a href="https://stackoverflow.com/questions/35356322/difference-between-int-and-char-in-getchar-fgetc-and-putchar-fputc">https://stackoverflow.com/questions/35356322/difference-between-int-and-char-in-getchar-fgetc-and-putchar-fputc</a><br><a href="https://stackoverflow.com/questions/7119470/int-c-getchar">https://stackoverflow.com/questions/7119470/int-c-getchar</a><br>The C Programming Language - By Kernighan and Ritchie</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>git clean/rm/reset/revert/checkout用法和区别</title>
    <url>/2018/12/22/git-clean-rm-reset-revert-checkout%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="git的工作区和暂存区"><a href="#git的工作区和暂存区" class="headerlink" title="git的工作区和暂存区"></a>git的工作区和暂存区</h2><p>先说下这两个概念：<br><strong>工作区</strong>，就是你git仓库的目录，你进行修改文件的区域。<br><strong>暂存区</strong>，git从库里面有个.git的隐藏目录，里面”有一块”，可以理解为<strong>暂存区</strong>。</p>
<a id="more"></a>

<p>工作区和缓存区如何联系起来？通过提交代码行为的步骤流程来解读:</p>
<ol>
<li>修改代码文件   </li>
<li><code>git add 修改后的代码文件</code>   <strong>此刻的行为将该代码文件从工作区添加到了暂存区</strong></li>
<li><code>git commit -m &#39;commit 内容&#39;</code>  <strong>此刻的行为把暂存区的内容提交到了本地分支上</strong></li>
</ol>
<p>最后的<code>git push</code>操作只是一个将本地分支推送到远端的行为，所以先不考虑进去，只考前面三点。</p>
<p>查看工作区和暂存区常用的命令为<code>git status</code></p>
<p>一般常见的是如下三种情况：</p>
<ol>
<li>在工作区<strong>新建</strong>了文件或目录，但还未将这些文件或目录<code>git add</code>提交到暂存区。这些文件或目录被标记为<strong>untracked files</strong>。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/test $ touch foo bar</span><br><span class="line">huangyisan:~/Desktop/github/test $ ls</span><br><span class="line">bar foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	bar</span><br><span class="line">	foo</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<ol>
<li>对修改后的文件进行了<code>git add</code>操作，将这些文件提交到了暂存区，但未执行<code>git commit -m &#39;xxx&#39;</code>，未提交到本地分支。此时文件属于<code>Changes to be committed</code>状态</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/test $ git add foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   foo</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	bar</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>对已经<code>git add</code>操作，但未提交到本地分支的文件，继续进行了修改，修改完后未进行<code>git add</code>，此时文件属于<code>Changes not staged for commit</code>状态<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">echo</span> <span class="string">&#x27;new line&#x27;</span> &gt;&gt; foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="keyword">file</span>:   foo</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   foo</span><br><span class="line"></span><br><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span><br><span class="line"></span><br><span class="line">	bar</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>已经commit到本地分支的文件，且该文件在工作区没被修改之前，其不会在git status中出现。</li>
</ol>
<h2 id="git-checkout-–-file"><a href="#git-checkout-–-file" class="headerlink" title="git checkout – file"></a>git checkout – file</h2><p>两种情况</p>
<ol>
<li><p>若被checkout的文件在暂存区，但工作区修改了，也就是上面的<strong>第三种</strong>情况，此时执行该命令，被checkout的文件变成和暂存区一样的状态和内容。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">echo</span> <span class="string">&#x27;first line&#x27;</span> &gt; foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git <span class="built_in">add</span> foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	modified:   foo</span><br><span class="line"></span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">cat</span> foo</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line"></span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">echo</span> <span class="string">&#x27;new line&#x27;</span> &gt;&gt; foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">cat</span> foo</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">line</span></span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	modified:   foo</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git checkout -- foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">cat</span> foo</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br></pre></td></tr></table></figure>
<p>将foo文件写入’first line’内容后，用<code>git add foo</code>，提交到了暂存区，未commit情况下，再写入新内容’new line’,若想还原到暂存区状态，则使用命令<code>git checkout -- foo</code></p>
</li>
<li><p>被修改文件不在暂存区，此时使用<code>git checkout -- file</code>命令，则该文件和当前版本仓库中原先的文件一致。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/<span class="keyword">test</span> $ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">huangyisan:~/Desktop/github/<span class="keyword">test</span> $ <span class="keyword">cat</span> foo</span><br><span class="line">first <span class="keyword">line</span></span><br><span class="line">huangyisan:~/Desktop/github/<span class="keyword">test</span> $ echo &#x27;new <span class="keyword">line</span>&#x27; &gt;&gt; foo</span><br><span class="line">huangyisan:~/Desktop/github/<span class="keyword">test</span> $ <span class="keyword">cat</span> foo</span><br><span class="line">first <span class="keyword">line</span></span><br><span class="line">new <span class="keyword">line</span></span><br><span class="line">huangyisan:~/Desktop/github/<span class="keyword">test</span> $ git checkout -- foo</span><br><span class="line">huangyisan:~/Desktop/github/<span class="keyword">test</span> $ <span class="keyword">cat</span> foo</span><br><span class="line">first <span class="keyword">line</span></span><br></pre></td></tr></table></figure>
<p>干净的工作区，修改了foo文件，然后进行checkout操作之后，foo文件还原成了仓库中该文件原先的状态和内容。</p>
</li>
</ol>
<h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><p>git clean 的对象为<strong>untracked files</strong>，也就是在工作区<strong>新建</strong>，但还未执行<code>git add</code>命令提交到暂存区的文件或目录。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ ls</span><br><span class="line">bar foo</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ touch new1 new2</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ <span class="class">mkdir </span>&#123;tmp1,tmp2&#125;</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ ls</span><br><span class="line">bar  foo  new1 new2 tmp1 tmp2</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ git clean -n</span><br><span class="line">Would remove new1</span><br><span class="line">Would remove new2</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ git clean -f new1</span><br><span class="line">Removing new1</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ git clean -df tmp1</span><br><span class="line">Removing tmp1/</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ ls</span><br><span class="line">bar  foo  new2 tmp2</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ git clean -f</span><br><span class="line">Removing new2</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ ls</span><br><span class="line">bar  foo  tmp2</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ git clean -df</span><br><span class="line">Removing tmp2/</span><br><span class="line"><span class="symbol">huangyisan:</span>~/Desktop<span class="meta-keyword">/github/</span>test $ ls</span><br><span class="line">bar foo</span><br></pre></td></tr></table></figure>
<p><code>git clean -n</code>，干跑模式，可以列出哪些文件会被清除，但不会列出哪些目录会被清除。<br><code>git clean -f</code>，若指定文件，则该文件被清除，若不指定文件，则所有未被提交到暂存区的文件都被清除。<br><code>git clean -df</code>，若指定目录，则该目录被清除，若不指定目录，则所有未被提交到暂存区的目录都被清除。</p>
<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p><code>git rm</code>等价于<code>rm xxx &amp;&amp; git add .</code>。<br>如果一个文件是被rm删除，则可以使用<code>git checkout -- file</code>将文件还原回来，而如果是用<code>git rm</code>删除，则该文件不可以被<code>git checkout -- file</code>。当然，如果是rm文件，然后git add操作，也是不能被<code>git checkout -- file</code>还原回来的。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ ls</span><br><span class="line">bar foo</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ rm foo</span><br><span class="line">remove foo? y</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ ls</span><br><span class="line">bar</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ git checkout foo</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ ls</span><br><span class="line">bar foo</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ git rm foo</span><br><span class="line">rm <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ git checkout foo</span><br><span class="line">error: pathspec <span class="string">&#x27;foo&#x27;</span> did not match <span class="keyword">any</span> <span class="keyword">file</span>(s) known to git.</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ ls</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>foo文件起先被rm删除，并未提交到暂存区，所以是可以被checkout还原，后来执行了git rm，所以当使用checkout还原的时候就报错了。</p>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>三种模式</p>
<ol>
<li>–mixed 默认方式，将暂存区内容清空，回退到工作区，并且保留工作区的修改内容。</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">cat</span> foo</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">echo</span> <span class="string">&#x27;new line&#x27;</span> &gt;&gt; foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git <span class="built_in">add</span> foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	modified:   foo</span><br><span class="line"></span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">cat</span> foo</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">line</span></span><br><span class="line">huangyisan:~/Desktop/github/test $ git reset HEAD</span><br><span class="line">Unstaged <span class="keyword">changes</span> after rese<span class="variable">t:</span></span><br><span class="line">M	foo</span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">cat</span> foo</span><br><span class="line"><span class="keyword">first</span> <span class="built_in">line</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">line</span></span><br><span class="line">huangyisan:~/Desktop/github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">changes</span> added <span class="keyword">to</span> commit (use <span class="string">&quot;git add&quot;</span> <span class="built_in">and</span>/<span class="built_in">or</span> <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>暂存区被清空，工作区的更变被保留下来，foo文件存在new line这行内容。</p>
<ol start="2">
<li>–soft  暂存区内容，工作区内容都被保留，HEAD指向指定的commit号，该commit号原先的文件若有变动，则直接被add到暂存区。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ ls</span><br><span class="line">foo</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ cat foo</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ echo <span class="string">&#x27;new line&#x27;</span> &gt; foo</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ git add foo</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be <span class="attr">committed:</span></span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	<span class="symbol">modified:</span>   foo</span><br><span class="line"></span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ git log --oneline</span><br><span class="line">e5ca64a (HEAD -&gt; master) <span class="number">1</span></span><br><span class="line"><span class="number">0</span>ba0aa5 <span class="number">1</span></span><br><span class="line">ebaa828 <span class="number">1</span></span><br><span class="line">a2f32c5 <span class="number">1</span></span><br><span class="line"><span class="number">8</span>f89d40 update</span><br><span class="line">be60bed <span class="number">1</span></span><br><span class="line">bb51c34 .</span><br><span class="line">df8f824 update</span><br><span class="line"><span class="number">4</span>dbd952 update</span><br><span class="line"><span class="number">9e683</span>fb <span class="number">1</span></span><br><span class="line"><span class="number">79</span>dfad8 <span class="number">1</span></span><br><span class="line"><span class="number">3e58</span>cef add <span class="number">1</span></span><br><span class="line"><span class="number">94e5</span>bf4 remove</span><br><span class="line"><span class="number">02</span>aadbb ok</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ git reset --soft <span class="number">8</span>f89d40</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ ls</span><br><span class="line">foo</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ cat foo</span><br><span class="line"><span class="keyword">new</span> line</span><br><span class="line"><span class="attr">huangyisan:</span><span class="regexp">~/Desktop/</span>github/test $ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be <span class="attr">committed:</span></span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">	<span class="symbol">deleted:</span>    bar</span><br><span class="line">	<span class="keyword">new</span> <span class="attr">file:</span>   foo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将foo的改动add到暂存区后，使用<code>git reset --soft 8f89d40</code>，8f89d40这个commit号原先是存在bar这个文件，且foo文件不存在，因为reset之前的内容和之后的比较出现了差异，则这些差异被add到了新的暂存区中。</p>
<ol start="3">
<li>–hard  HEAD重置到指定commit号，且清空暂存区，工作区的内容和该commit号版本仓库的内容一致。</li>
</ol>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ git reset --hard HEAD</span><br><span class="line">HEAD is now at <span class="number">14</span>d3892 <span class="number">1</span></span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ ls</span><br><span class="line">foo</span><br><span class="line">huangyisan:~<span class="regexp">/Desktop/gi</span>thub/test $ cat foo</span><br><span class="line">first line</span><br></pre></td></tr></table></figure>
<p>暂存区被清空，工作区内容成了当前commit号版本仓库的内容，也就是没修改之前的内容，foo文件不存在new line行。<br><strong>但若工作区存在Untracked files，则这些Untracked files会携带进入到指定的commit号版本仓库的工作区中，所以要恢复到和某个commit号完全一致，还需要git clean -f清空Untracked files。</strong></p>
<p><strong>git reset会将HEAD指向的分支指向reset对应的commit，而git checkout是HEAD直接指向对应的commit。</strong><br><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1fyiqk5xn2gj20dw0a6aa3.jpg"></p>
<h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>仅将某个commit号提交分支的内容撤销，且将此次撤销作为一个新的提交。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">huangyisan:~/Desktop/github/test $ git <span class="built_in">log</span> --oneline</span><br><span class="line"><span class="number">145</span>af31 (HEAD -&gt; master) <span class="built_in">add</span> <span class="keyword">new</span></span><br><span class="line">edf54e3 <span class="built_in">add</span> foo</span><br><span class="line">c11842d <span class="built_in">add</span> bar</span><br><span class="line"><span class="number">5</span>f4b280 <span class="built_in">remove</span> <span class="keyword">all</span></span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">ls</span></span><br><span class="line">bar  foo  <span class="keyword">new</span>  new1</span><br><span class="line">huangyisan:~/Desktop/github/test $ git revert c11842d</span><br><span class="line">[master <span class="number">19</span>e736c] Revert <span class="string">&quot;add bar&quot;</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">0</span> insertions(+), <span class="number">0</span> deletions(-)</span><br><span class="line"> <span class="keyword">delete</span> <span class="keyword">mode</span> <span class="number">100644</span> bar</span><br><span class="line">huangyisan:~/Desktop/github/test $ <span class="keyword">ls</span></span><br><span class="line">foo  <span class="keyword">new</span>  new1</span><br><span class="line">huangyisan:~/Desktop/github/test $ git <span class="built_in">log</span> --oneline</span><br><span class="line"><span class="number">19</span>e736c (HEAD -&gt; master) Revert <span class="string">&quot;add bar&quot;</span></span><br><span class="line"><span class="number">145</span>af31 <span class="built_in">add</span> <span class="keyword">new</span></span><br><span class="line">edf54e3 <span class="built_in">add</span> foo</span><br><span class="line">c11842d <span class="built_in">add</span> bar</span><br><span class="line"><span class="number">5</span>f4b280 <span class="built_in">remove</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<p>c11842d是将bar文件提交到了分支，当执行<code>git revert c11842d</code>,则撤销了提交bar文件到分支，所以执行完后，bar文件不见了，但foo文件依旧存在，所以revert只影响了被撤销的commit的变更内容，而且看git log，多了一个新的commit提交号19e736c。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git rebase操作</title>
    <url>/2019/03/26/git-rebase%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="同一分支-不同文件-无冲突情况"><a href="#同一分支-不同文件-无冲突情况" class="headerlink" title="同一分支 不同文件 无冲突情况"></a>同一分支 不同文件 无冲突情况</h2><ol>
<li>本地修改master，远端(模拟其他协同开发人员)修改remote_change</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">master  remote_change</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<ol start="2">
<li>查看当前git log信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan@huangyisan-PC MINGW64 ~/Desktop/github/pingan/testgit (master)</span><br><span class="line"><span class="meta">$</span><span class="bash">  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">* aed5259 (HEAD -&gt; master, origin/master) local change 2</span><br><span class="line">* d327114 local change 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前分支指向master，且和远程对齐。</p>
<ol start="3">
<li><p>非本地进行提交<br>比如使用web页面gitlab提交，模拟协同操作仓库，修改remote_change内容</p>
</li>
<li><p>然后本地进行提交<br>修改master文件内容两次，并且commit，进行push</p>
</li>
</ol>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;local change 3&#x27;</span></span><br><span class="line">[master d327114] local change 3</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+), 1 deleti<span class="meta">on(</span>-)</span><br><span class="line"></span><br><span class="line"> $ git commit -m <span class="string">&#x27;local change 4&#x27;</span></span><br><span class="line">[master aed5259] local change 4</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+), 1 deleti<span class="meta">on(</span>-)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进行push，此时因为非本地端已经被提交，当前仓库不是最新代码，push被rejected，查看git log内容</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* <span class="number">8</span>dd9d20 (HEAD -&gt; master) <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">4</span></span><br><span class="line">* f6b8c95 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">3</span></span><br><span class="line">* aed5259 (origin/master) <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">2</span></span><br><span class="line">* d327114 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">1</span></span><br><span class="line">* d0e5f73 <span class="built_in">change</span> <span class="keyword">local</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>当前位置比远程仓库快2个位置。由于远程已经有提交内容，本地仓库不是最新代码，需要git pull.</p>
<ol start="5">
<li>仓库重新pull，并查看git log</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   <span class="number">5</span>b4b59f (HEAD -&gt; master) <span class="built_in">Merge</span> branch <span class="string">&#x27;master&#x27;</span> of http://gitlab.ptest.cdn.pingan.com.cn:<span class="number">19090</span>/huangyisan/testgit</span><br><span class="line">|\</span><br><span class="line">| * <span class="number">3</span>fb5469 (origin/master) 更新 remote_change <span class="number">1</span></span><br><span class="line">* | <span class="number">8</span>dd9d20 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">4</span></span><br><span class="line">* | f6b8c95 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">3</span></span><br><span class="line">|/</span><br><span class="line">* aed5259 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">2</span></span><br><span class="line">* d327114 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时出现了’分叉’，本地指向的是和远程merge的内容，但远程是指向3fb5469位置，还没更新本地的两个commit提交内容。</p>
<ol start="6">
<li>使用rebase，查看git log</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top <span class="keyword">of</span> <span class="keyword">it</span>...</span><br><span class="line">Applying: <span class="keyword">local</span> change <span class="number">3</span></span><br><span class="line">Applying: <span class="keyword">local</span> change <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>查看git log</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* c10a76b (HEAD -&gt; master) <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">4</span></span><br><span class="line">* <span class="number">4101717</span> <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">3</span></span><br><span class="line">* <span class="number">3</span>fb5469 (origin/master) 更新 remote_change <span class="number">1</span></span><br><span class="line">* aed5259 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">2</span></span><br><span class="line">* d327114 <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>此时git log变成了一条直线。查看git log内容更加清晰明了。</strong><br>本地指向c10a76b 远端仓库指向3fb5469，还需要对本地进行git push</p>
<ol start="7">
<li>git push提交更变内容<br>由于只是rebase，并没有git push，所以还需要把本地的量词修改提交到远端仓库</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating <span class="attr">objects:</span> <span class="number">8</span>, done.</span><br><span class="line">Counting <span class="attr">objects:</span> <span class="number">100</span>% (<span class="number">8</span>/<span class="number">8</span>), done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads</span><br><span class="line">Compressing <span class="attr">objects:</span> <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</span><br><span class="line">Writing <span class="attr">objects:</span> <span class="number">100</span>% (<span class="number">6</span><span class="regexp">/6), 569 bytes | 569.00 KiB/</span>s, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To <span class="attr">http:</span><span class="comment">//xxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line">   <span class="number">3</span>fb5469..c10a76b  master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="同一分支-相同文件-有冲突情况"><a href="#同一分支-相同文件-有冲突情况" class="headerlink" title="同一分支 相同文件 有冲突情况"></a>同一分支 相同文件 有冲突情况</h2><ol>
<li>查看git log信息</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> <span class="comment">--graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">* d01191c (HEAD -&gt; master, origin/master) <span class="keyword">local</span> change <span class="number">1</span></span><br><span class="line">* <span class="number">6</span>b113ef <span class="built_in">remove</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>本地和远端都修改master文件，让其产生冲突</li>
</ol>
<p>本地:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ cat <span class="literal">master</span></span><br><span class="line">local change <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>远端:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">change</span> <span class="number">1</span></span><br><span class="line">remote <span class="built_in">change</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>远端提交，然后本地也push</li>
</ol>
<p>本地不是指向最新的commit，本地需要先pull</p>
<ol start="4">
<li>本地pull操作，出现了冲突</li>
</ol>
<p>git status内容</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On <span class="keyword">branch </span>master</span><br><span class="line">Your <span class="keyword">branch </span><span class="keyword">and </span><span class="string">&#x27;origin/master&#x27;</span> have <span class="keyword">diverged,</span></span><br><span class="line"><span class="keyword">and </span>have <span class="number">1</span> <span class="keyword">and </span><span class="number">1</span> <span class="keyword">different </span>commits each, respectively.</span><br><span class="line">  (use <span class="string">&quot;git pull&quot;</span> to merge the remote <span class="keyword">branch </span>into yours)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts <span class="keyword">and </span>run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">both </span>modified:   master</span><br><span class="line"></span><br><span class="line">no changes <span class="keyword">added </span>to commit (use <span class="string">&quot;git add&quot;</span> <span class="keyword">and/or </span><span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>冲突内容</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">$ cat master</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">local change 2</span><br><span class="line">=======</span><br><span class="line">local change 1</span><br><span class="line">remote change 2</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2497b92a10abea64a2cfc7072039bbf497cc11e0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>add commit冲突内容</li>
</ol>
<p><strong>此时如果修改冲突内容然后rebase，则修改的内容又会还原，所以先add commit</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git commit -m &#x27;conficlit&#x27;</span><br><span class="line">[<span class="keyword">master</span> <span class="title">a252b15</span>] conficlit</span><br></pre></td></tr></table></figure>
<p>查看git log，发现出现分叉了</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   a252b15 (HEAD -&gt; master) conficlit</span><br><span class="line">|\</span><br><span class="line">| * <span class="number">2497b92</span> (<span class="built_in">origin</span>/master) 更新 master</span><br><span class="line">* | 92bf8fc <span class="built_in">local</span> change <span class="number">2</span></span><br><span class="line">|/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>此时进行git rebase操作<br>查看git log 之前的分叉没了</li>
</ol>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* <span class="number">2497b92</span> (HEAD, <span class="built_in">origin</span>/master) 更新 master</span><br><span class="line">* d01191c <span class="built_in">local</span> change <span class="number">1</span></span><br><span class="line">* 6b113ef <span class="built_in">remove</span></span><br><span class="line">*   f6e9fe8 update</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>然后修复冲突，并且进行add</li>
</ol>
<p>修复冲突后 add，<strong>但不commit</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> master</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>进行git rebase –continue操作</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">$ git rebase --<span class="keyword">continue</span></span><br><span class="line">Applying: <span class="keyword">local</span> <span class="built_in">change</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>查看git log, 此时本地HEAD比远端快，所以需要push</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* <span class="number">455b381</span> (HEAD -&gt; master) <span class="built_in">local</span> change <span class="number">2</span></span><br><span class="line">* <span class="number">2497b92</span> (<span class="built_in">origin</span>/master) 更新 master</span><br><span class="line">* d01191c <span class="built_in">local</span> change <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>最后进行git push</li>
</ol>
<p>查看git log 测试及本地HEAD和远端对齐commit号了</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$  git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* <span class="number">455b381</span> (HEAD -&gt; master, <span class="built_in">origin</span>/master) <span class="built_in">local</span> change <span class="number">2</span></span><br><span class="line">* <span class="number">2497b92</span> 更新 master</span><br><span class="line">* d01191c <span class="built_in">local</span> change <span class="number">1</span></span><br><span class="line">* 6b113ef <span class="built_in">remove</span></span><br><span class="line">*   f6e9fe8 update</span><br></pre></td></tr></table></figure>
<h2 id="不同分支-无冲突情况"><a href="#不同分支-无冲突情况" class="headerlink" title="不同分支 无冲突情况"></a>不同分支 无冲突情况</h2><ol>
<li>dog cat两个基于master checkout出来的分支，当前git log出现分叉</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/9f0d15f3ly1g1hsqriytzj20gn068wes.jpg"></p>
<ol start="2">
<li>在cat分支上进行git rebase dog</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rebase dog</span><br><span class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top of it...</span><br><span class="line">Applyin<span class="variable">g:</span> <span class="keyword">cat</span></span><br><span class="line">Applyin<span class="variable">g:</span> <span class="keyword">cat</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看git log ，cat和dog的分叉合并了<br><img src="http://ww1.sinaimg.cn/large/9f0d15f3ly1g1hsp6ghkfj20fz08hgm5.jpg"></li>
</ol>
<h2 id="不同分支-有冲突情况"><a href="#不同分支-有冲突情况" class="headerlink" title="不同分支 有冲突情况"></a>不同分支 有冲突情况</h2><ol>
<li>dog cat两个基于master checkout出来的分支，当前git log出现分叉</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/9f0d15f3ly1g1ht0t2p82j20hv08wjrx.jpg"></p>
<ol start="2">
<li>在cat分支上进行git rebase dog 出现了冲突</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rebase dog</span><br><span class="line">First, rewinding head <span class="keyword">to</span> replay your work <span class="keyword">on</span> top of it...</span><br><span class="line">Applyin<span class="variable">g:</span> <span class="keyword">cat</span></span><br><span class="line">Applyin<span class="variable">g:</span> <span class="keyword">cat</span></span><br><span class="line">Applyin<span class="variable">g:</span> <span class="built_in">remove</span> <span class="keyword">cat</span> dog</span><br><span class="line">Using <span class="built_in">index</span> info <span class="keyword">to</span> reconstruct <span class="keyword">a</span> base tree...</span><br><span class="line">A       dog</span><br><span class="line">Falling back <span class="keyword">to</span> patching base <span class="built_in">and</span> <span class="number">3</span>-way merge...</span><br><span class="line">Removing <span class="keyword">cat</span></span><br><span class="line">Applyin<span class="variable">g:</span> <span class="keyword">cat</span></span><br><span class="line">Using <span class="built_in">index</span> info <span class="keyword">to</span> reconstruct <span class="keyword">a</span> base tree...</span><br><span class="line">Falling back <span class="keyword">to</span> patching base <span class="built_in">and</span> <span class="number">3</span>-way merge...</span><br><span class="line">Auto-merging annimal</span><br><span class="line">CONFLICT (<span class="built_in">add</span>/<span class="built_in">add</span>): Merge conflict in annimal</span><br><span class="line">error: Failed <span class="keyword">to</span> merge in the <span class="keyword">changes</span>.</span><br><span class="line">hin<span class="variable">t:</span> Use <span class="string">&#x27;git am --show-current-patch&#x27;</span> <span class="keyword">to</span> see the failed patch</span><br><span class="line">Patch failed at <span class="number">0004</span> <span class="keyword">cat</span></span><br><span class="line"></span><br><span class="line">Resolve <span class="keyword">all</span> conflicts manually, <span class="keyword">mark</span> them <span class="keyword">as</span> resolved with</span><br><span class="line"><span class="string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, then run <span class="string">&quot;git rebase --continue&quot;</span>.</span><br><span class="line">You can instead skip this commi<span class="variable">t:</span> run <span class="string">&quot;git rebase --skip&quot;</span>.</span><br><span class="line">To abort <span class="built_in">and</span> <span class="built_in">get</span> back <span class="keyword">to</span> the state before <span class="string">&quot;git rebase&quot;</span>, run <span class="string">&quot;git rebase --abort&quot;</span>.</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>解决冲突后，git add ，然后<code>git rebase --continue</code> 无需git commit</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">add</span> annimal</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="keyword">continue</span></span><br><span class="line">Applyin<span class="variable">g:</span> <span class="keyword">cat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>查看git log已经解决分叉情况</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/9f0d15f3ly1g1ht138yvwj20g807pq3b.jpg"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><strong>只对</strong><code>尚未推送</code><strong>或分享给别人的本地修改执行变基操作清理历史</strong></li>
<li><strong>从不对已推送至别处的提交执行变基操作</strong></li>
<li>如果存在冲突，则解决完冲突后，进行git add，之后不需要git commit，直接使用<code>git rebase --continue</code></li>
<li>rebase目的就是让协同开发同事看log更加清晰明了。</li>
</ol>
<p>refer</p>
<blockquote>
<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000#0">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000#0</a><br><a href="http://gitbook.liuhui998.com/4_2.html">http://gitbook.liuhui998.com/4_2.html</a><br><a href="https://www.youtube.com/watch?v=HeF7dwVyzow&amp;feature=player_embedded">https://www.youtube.com/watch?v=HeF7dwVyzow&amp;feature=player_embedded</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab cicd的使用01 -- 环境部署和demo运行</title>
    <url>/2021/06/14/gitlab-cicd%E7%9A%84%E4%BD%BF%E7%94%A801-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%92%8Cdemo%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>17年那会当时选型gitlab cicd或者jenkins做持续集成，因为不需要重复造轮子，就用了gitlab cicd，这几天重温文档，看到了gitlab-ci更新了相当多的feature，所以趁着端午期间重新回顾下，并且记录下一些feature的使用。</p>
<a id="more"></a>

<h2 id="gitlab-runner"><a href="#gitlab-runner" class="headerlink" title="gitlab-runner"></a>gitlab-runner</h2><ol>
<li>gitlab的cicd是通过gitlab-runner进行实现的。</li>
<li>gitlab-runner一般是建议部署在和gitlab处于不同的服务器上。</li>
<li>gitlab-runner可以通过docker或者本地二进制文件的方式进行部署。详细部署过程不赘述，可以查看文末的refer，我的环境是使用二进制方式部署的。</li>
</ol>
<h3 id="让gitlab-runner连接gitlab"><a href="#让gitlab-runner连接gitlab" class="headerlink" title="让gitlab-runner连接gitlab"></a>让gitlab-runner连接gitlab</h3><p>既然安装了gitlab-runner，那怎么才能让gitlab-runner连接到gitlab，从而执行gitlab派发的任务呢，就需要对gitlab-runner进行配置。</p>
<p>配置的关键主要有两个参数，<code>Register url</code>和<code>registration token</code>，这两个参数可以在gitlab的Admin Area页面下的Runners页面找到。</p>
<p>在gitlab-runner机器上执行<code>gitlab-runner register</code>命令，就会出现交互式输入，填写<code>Register url</code>, <code>Registration token</code>,<code>tag</code>,<code>executor</code>等信息后，就可以在刚才Admin Area的Runners页面看到已经注册了的gitlab-runner了。(后面我又添加了一个<strong>tag为shared</strong>的runner，执行器为docker)</p>
<p><img src="https://assets.iostat.io/image/gitlab-runner-register.jpg" alt="gitlab-runner注册页面"></p>
<p>有关<code>executor</code>的信息，当前支持这些，<code>docker-ssh+machine, kubernetes, custom, docker, parallels, ssh, virtualbox, docker+machine, docker-ssh, shell</code>，我使用过的有docker和shell，前者为将pipeline置于docker中进行运行，后者则在本机环境进行运行pipeline定义的内容。</p>
<h3 id="gitlab-runner的几种状态"><a href="#gitlab-runner的几种状态" class="headerlink" title="gitlab-runner的几种状态"></a>gitlab-runner的几种状态</h3><ol>
<li><strong>shared</strong> 该状态下的gitlab-runner可以让任何项目的pipeline运行使用。</li>
<li><strong>group</strong> </li>
<li><strong>specific</strong> 只能让某个指定的项目使用该runner，<strong>如果你将一个shared runner变更为specific，该过程不可逆</strong></li>
<li><strong>locked</strong> 任何项目都不可以使用该runner</li>
<li><strong>paused</strong> 无法使用的runner</li>
</ol>
<h3 id="尝试运行一个小的demo"><a href="#尝试运行一个小的demo" class="headerlink" title="尝试运行一个小的demo"></a>尝试运行一个小的demo</h3><ol>
<li>要运行pipeline，则需要在仓库里面创建.gitlab-ci.yml文件，并且定义其pipeline内容。</li>
<li>将代码提交到仓库，自动触发pipeline运行构建。</li>
<li>pipeline内容<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">helloworld:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line"><span class="attr">stage:</span></span><br><span class="line">  <span class="string">build</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>进入项目<strong>CI/CD</strong> -&gt; <strong>Pipeline</strong>就能看到刚刚执行的pipeline了。点击进去还能看到详细步骤。</li>
</ol>
<p><img src="https://assets.iostat.io/image/pipeline-excute-01.png"></p>
<p><img src="https://assets.iostat.io/image/pipeline-excute-02.png"></p>
<p>refer:</p>
<blockquote>
<p><a href="https://docs.gitlab.com/runner/install/linux-manually.html">https://docs.gitlab.com/runner/install/linux-manually.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab cicd的使用02 -- pipeline介绍和编写</title>
    <url>/2021/06/14/gitlab-cicd%E7%9A%84%E4%BD%BF%E7%94%A802-pipeline%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h2 id="gitlab-ci-yml文件"><a href="#gitlab-ci-yml文件" class="headerlink" title=".gitlab-ci.yml文件"></a>.gitlab-ci.yml文件</h2><p>.gitlab-ci.yml文件是gitlab cicd灵魂所在。</p>
<p>该文件通过yaml方式进行编写，有其特有的关键字，遵循一定的章法结构。</p>
<p>里面定义一个个的job，来实现pipeline具体的编排内容。</p>
<a id="more"></a>

<h2 id="gitlab-ci-yml-job-关键字"><a href="#gitlab-ci-yml-job-关键字" class="headerlink" title=".gitlab-ci.yml job 关键字"></a>.gitlab-ci.yml job 关键字</h2><p>官方给出的关键字很多，可以查看: <a href="https://docs.gitlab.com/ee/ci/yaml/README.html">https://docs.gitlab.com/ee/ci/yaml/README.html</a></p>
<p>但并不是每个都常用，常用的主要有以下这几个，根据官方顺序：</p>
<ul>
<li><code>artifacts</code>定义 job成功后制品的产出。</li>
<li><code>cache</code> 可对指定的路径进行缓存操作，使得在其他job里面继续使用这些缓存，比如nodejs，npm install构建生成的node_modules目录，php composer构建生成的vendor目录等。</li>
<li><code>image</code> 当gitlab-runner为docker执行器的时候，可以使用image变更某个job使用何种容器进行执行构建。</li>
<li><code>include</code> 引入其他pipeline的时候使用</li>
<li><code>interruptible</code> 定义了当新的pipeline被提交触发构建，老的正在运行的pipeline是否可以被打断的参数，为了构建一致性。</li>
<li><code>only</code> 指定某个branch或者tag有提交的时候，才构建。<strong>only不可以使用变量指定</strong>。</li>
<li><code>retry</code> 某个job失败后的重试次数，最大为2。</li>
<li><code>resource_group</code> 有该标记的所有pipeline的job，只有执行完一个，下一个才会被执行。</li>
<li><code>script</code> 定义执行的命令，shell命令的方式。</li>
<li><code>stages</code> 重新定义pipeline的stage，默认stage为五个 <code>.pre</code>,<code>build</code>,<code>test</code>,<code>deploy</code>,<code>.post</code>。</li>
<li><code>tags</code> 指定哪个tag的gitlab-runner来运行pipeline。</li>
<li><code>timeout</code>  定义job任务的超时。</li>
<li><code>trigger</code> 在父子pipeline的时候使用，定义触发哪一个pipeline执行。</li>
<li><code>variables</code> 定义pipeline里面的变量。</li>
<li><code>when</code> 定义何时执行job。</li>
</ul>
<h2 id="gitlab-ci-yml-变量"><a href="#gitlab-ci-yml-变量" class="headerlink" title=".gitlab-ci.yml 变量"></a>.gitlab-ci.yml 变量</h2><ol>
<li>可以使用variable关键在在pipeline里面自定义变量。</li>
<li>同时，gitlab-ci内置了许多变量: <a href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html">https://docs.gitlab.com/ee/ci/variables/predefined_variables.html</a></li>
</ol>
<h2 id="gitlab-ci-yml-编写"><a href="#gitlab-ci-yml-编写" class="headerlink" title=".gitlab-ci.yml 编写"></a>.gitlab-ci.yml 编写</h2><ol>
<li>.gitlab-ci.yml文件采用yaml的格式，关键字有其特有的上下文等。</li>
<li>编写可以使用页面上<strong>CI/CD</strong> -&gt; <strong>Editor</strong>进行编写，这里会对pipeline语法的合法性进行校验。</li>
</ol>
<h2 id="gitlab-ci-yml-一个简单的go编写需求样例"><a href="#gitlab-ci-yml-一个简单的go编写需求样例" class="headerlink" title=".gitlab-ci.yml 一个简单的go编写需求样例"></a>.gitlab-ci.yml 一个简单的go编写需求样例</h2><ol>
<li>仓库存放的为go代码。</li>
<li>要求对指定分支进行构建，其他分支不进行构建。</li>
<li>构建得到的二进制文件可以下载。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义变量</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">    <span class="attr">BIN_PATH:</span> <span class="string">bin/</span></span><br><span class="line">    <span class="attr">BIN_NAME:</span> <span class="string">hello_world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局定义使用哪个镜像，如果在stage里面没有单独定义image，则使用全局定义的镜像</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">golang:latest</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义stage，总共三个 build  test export</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">export</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局定义cache， $&#123;CI_COMMIT_REF_SLUG&#125;为内置变量，作为key， 需要缓存的路径为$BIN_PATH</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">$BIN_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="attr">go:build:</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">build</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">go</span> <span class="string">build</span> <span class="string">-o</span> <span class="string">$&#123;BIN_PATH&#125;$&#123;BIN_NAME&#125;</span> <span class="string">./main.go</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">120</span></span><br><span class="line">    <span class="comment"># only里面定义哪个分支进行运行job，不可以使用变量</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="comment"># 当有多个pipeline运行的时候，当该阶段还未执行完毕的时候，其他定义了resource_group: go_build的pipeline都会处于 wait 状态。</span></span><br><span class="line">    <span class="attr">resource_group:</span> <span class="string">go_build</span></span><br><span class="line">    <span class="comment"># 如果执行失败，或者stuck，或者超时，则进行重试，最多2次。</span></span><br><span class="line">    <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">max:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">when:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">runner_system_failure</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">stuck_or_timeout_failure</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">go:test:</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">test</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="comment"># 在job里面单独定义了image，则表示这个job使用alpine:latest来作为环境</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine:latest</span></span><br><span class="line">    <span class="comment"># 定义了执行脚本前的动作</span></span><br><span class="line">    <span class="attr">before_script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">$&#123;BIN_PATH&#125;$&#123;BIN_NAME&#125;</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./$&#123;BIN_PATH&#125;$&#123;BIN_NAME&#125;</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-i</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="comment"># 定义该job超时时间为20s</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">go:export:</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">export</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="string">ls</span> <span class="string">$&#123;BIN_PATH&#125;$&#123;BIN_NAME&#125;</span></span><br><span class="line">    <span class="comment"># 定义了制品的产出</span></span><br><span class="line">    <span class="attr">artifacts:</span></span><br><span class="line">        <span class="comment"># 制品名称</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">$&#123;BIN_PATH&#125;</span></span><br><span class="line">        <span class="comment"># 将哪个路径进行制品归档</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">bin</span></span><br><span class="line">        <span class="comment"># 制品保留一周</span></span><br><span class="line">        <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>最后的制品产出可以通过pipeline页面下载。</p>
<p><img src="https://assets.iostat.io/image/artifacts-download.png"></p>
<p>refer:</p>
<blockquote>
<p><a href="https://docs.gitlab.com/ee/ci/yaml/README.html">https://docs.gitlab.com/ee/ci/yaml/README.html</a><br><a href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html">https://docs.gitlab.com/ee/ci/variables/predefined_variables.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab cicd的使用03 -- pipeline类型 DAG类型</title>
    <url>/2021/06/14/gitlab-cicd%E7%9A%84%E4%BD%BF%E7%94%A803-pipeline%E7%B1%BB%E5%9E%8B-DAG%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Pipeline-DAG类型"><a href="#Pipeline-DAG类型" class="headerlink" title="Pipeline DAG类型"></a>Pipeline DAG类型</h2><p>除了最常见的Pipeline类型，按顺序执行，还存在其他类型的pipeline。</p>
<ol>
<li>DAG类型，这种类型突破了传统的按顺序执行，可以直接根据依赖关系执行，使用关键字<code>needs</code></li>
</ol>
<a id="more"></a>

<h3 id="DAG类型解决的问题"><a href="#DAG类型解决的问题" class="headerlink" title="DAG类型解决的问题"></a>DAG类型解决的问题</h3><p>假设把pipeline划分为三个阶段，build,test,deploy。在build阶段，存在两个job，然后test一个job，deploy也是一个job，目前build阶段的其中一个job（job_b）只是暂时编写进去，是否执行不会影响后面的test和deploy阶段。而test和deploy真正关心的是job_a，那么其实只需要job_b执行完后，就可以执行test和deploy阶段，而无需等待job_a执行完毕。</p>
<p>还有一种情形，比如用多端框架编写的代码，在build阶段会进行多平台编译，有IOS，有Android，有PC端，然后test阶段也存在根据不同的平台进行测试的job，此时test阶段关于IOS的测试其实只需要在build阶段IOS的job跑完即可，而无需等待另外两个端的build完成。</p>
<h3 id="DAG类型需求场景"><a href="#DAG类型需求场景" class="headerlink" title="DAG类型需求场景"></a>DAG类型需求场景</h3><ol>
<li>假设存在IOS, Android,PC三个端。</li>
<li>需要各自build，并且进行测试。</li>
<li>最后再分发到不同的平台。</li>
</ol>
<h3 id="DAG类型pipeline编写"><a href="#DAG类型pipeline编写" class="headerlink" title="DAG类型pipeline编写"></a>DAG类型pipeline编写</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ios_build:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">build</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Build on ios&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">android_build:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">build</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Build on android&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pc_build:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">build</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Build on pc&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ios_test:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">test</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Test for ios&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">10</span></span><br><span class="line">    <span class="comment"># 当ios_build执行完，则执行本job</span></span><br><span class="line">    <span class="attr">needs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ios_build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">android_test:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">test</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Test for android&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">needs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">android_build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pc_test:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">test</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Test for pc&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sleep</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">needs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">pc_build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ios_deploy:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">deploy</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Deploy for ios&quot;</span></span><br><span class="line">    <span class="comment"># 当执行完ios_build和ios_test，则执行本job</span></span><br><span class="line">    <span class="attr">needs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ios_build</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ios_test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">android_deploy:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">deploy</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Deploy for android&quot;</span></span><br><span class="line">    <span class="attr">needs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">android_build</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">android_test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pc_deploy:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">deploy</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Deploy for pc&quot;</span></span><br><span class="line">    <span class="attr">needs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">pc_build</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">pc_test</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述任务需要开启gitlab-runner的多任务，<code>concurrent</code>大于1。</p>
<p>pipeline运行后不再是之前的根据stages顺序执行，而是通过needs关键字指定的关系，进行执行。<br><img src="https://assets.iostat.io/image/dag-pipeline.png"></p>
<p>refer:</p>
<blockquote>
<p><a href="https://docs.gitlab.com/ee/ci/directed_acyclic_graph/">https://docs.gitlab.com/ee/ci/directed_acyclic_graph/</a><br><a href="https://about.gitlab.com/blog/2020/05/12/directed-acyclic-graph/">https://about.gitlab.com/blog/2020/05/12/directed-acyclic-graph/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab cicd的使用04 -- pipeline类型 Multi-project</title>
    <url>/2021/06/15/gitlab-cicd%E7%9A%84%E4%BD%BF%E7%94%A804-pipeline%E7%B1%BB%E5%9E%8B%20Multi-project/</url>
    <content><![CDATA[<h2 id="Pipeline-Multi-project"><a href="#Pipeline-Multi-project" class="headerlink" title="Pipeline Multi-project"></a>Pipeline Multi-project</h2><ol>
<li>Multi-project类型可以让你当前的pipeline触发另外一个项目的pipeline运行，使用关键字<code>trigger</code></li>
</ol>
<a id="more"></a>

<h3 id="Multi-project类型解决的问题"><a href="#Multi-project类型解决的问题" class="headerlink" title="Multi-project类型解决的问题"></a>Multi-project类型解决的问题</h3><p>当两个或者多个project存在相互关系，但又因为.gitlab-ci.yml文件是分开放置，所以用Multi-project的方式可以做project pipeline的调用。</p>
<p>pipeline之间还可以进行变量的传递。</p>
<h3 id="Multi-project类型需求场景"><a href="#Multi-project类型需求场景" class="headerlink" title="Multi-project类型需求场景"></a>Multi-project类型需求场景</h3><ol>
<li>假设存在project today和yesterday。</li>
<li>运行today的pipeline后触发yesterday的pipeline。</li>
</ol>
<h3 id="Multi-project类型pipeline编写"><a href="#Multi-project类型pipeline编写" class="headerlink" title="Multi-project类型pipeline编写"></a>Multi-project类型pipeline编写</h3><ol>
<li><p>today project</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">yesterday_trigger</span></span><br><span class="line"></span><br><span class="line"><span class="attr">today_build:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">build</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;this is today project build&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">today_deploy:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">deploy</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;this is today project deploy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">trigger_yesterday:</span></span><br><span class="line">    <span class="comment"># 使用variable指定环境变量，可以将该变量downstream到被trigger的pipeline</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">        <span class="attr">ENVIRONMENT:</span> <span class="string">today</span></span><br><span class="line">    <span class="comment"># 这个步骤并不需要指定tag，因为其只是为了触发yesterday项目</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">yesterday_trigger</span></span><br><span class="line">    <span class="attr">trigger:</span></span><br><span class="line">        <span class="comment"># yesterday项目为http://192.168.65.135/root/yesterday.git, 所以为root/yesterday</span></span><br><span class="line">        <span class="attr">project:</span> <span class="string">root/yesterday</span></span><br><span class="line">        <span class="comment"># 触发构建的分支为master</span></span><br><span class="line">        <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">        <span class="comment"># 这个表示，如果下游失败了，则表示该trigger_yesterday job也失败，如果成功了，则表示trigger_yesterday也成功。如果取消了该条配置，则下游失败与否和当前job无关。</span></span><br><span class="line">        <span class="attr">strategy:</span> <span class="string">depend</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>yesterday project</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">yesterday_build:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">build</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;this is yesterday project build&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">yesterday_deploy:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">shared</span></span><br><span class="line">    <span class="attr">stage:</span></span><br><span class="line">        <span class="string">deploy</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;this is yesterday project deploy&quot;</span></span><br><span class="line">        <span class="comment"># $ENVIRONMENT从today传递过来，所以会打印出来</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;$ENVIRONMENT&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>today project的pipeline就会出现<strong>Downstream</strong>的图，示意触发了yesterday项目。</p>
<p><img src="https://assets.iostat.io/image/mulit-pipeline.png"></p>
</li>
</ol>
<p>refer:</p>
<blockquote>
<p><a href="https://docs.gitlab.com/ee/ci/multi_project_pipelines.html">https://docs.gitlab.com/ee/ci/multi_project_pipelines.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>go无缓存channel出现deadlock</title>
    <url>/2020/12/17/go%E6%97%A0%E7%BC%93%E5%AD%98channel%E5%87%BA%E7%8E%B0deadlock/</url>
    <content><![CDATA[<h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    chanStr := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    chanStr &lt;<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    a := &lt;- chanStr</span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<ol>
<li>创建一个无缓存channel chanStr</li>
<li>往chanStr放入int类型1</li>
<li>从chanStr读取内容至变量a</li>
<li>打印变量a</li>
</ol>
<p>看着没有什么问题，逻辑也很正确，但结果发生了报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:</span><br><span class="line">main.main()</span><br></pre></td></tr></table></figure>
<h2 id="产生报错的原因"><a href="#产生报错的原因" class="headerlink" title="产生报错的原因"></a>产生报错的原因</h2><p><a href="https://golang.org/doc/effective_go.html#channels">官方</a>在这边说明了：</p>
<ol>
<li>Receivers always block until there is data to receive. (直到channel内存在数据，消费端才会解除block状态)</li>
<li>If the channel is unbuffered, the sender blocks until the receiver has received the value.(如果是无buff的channel，直到消费者消费了数据，发送者才会解除block状态)</li>
<li>If the channel has a buffer, the sender blocks only until the value has been copied to the buffer.(如果是有buff的channel，那么在发送者发送数据到channel之前是block状态)</li>
<li>if the buffer is full, this means waiting until some receiver has retrieved a value.(如果buff满了，则当消费者消费数据之前，会一直等待)</li>
</ol>
<p>产生的问题是第二点，main本身就是个goroutine，所以执行到<code>chanStr &lt;-1</code>因为没有对应的消费者消费数据，所以被block，下面的代码也就无法执行，导致deadlock错误。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>将<code>a := &lt;- chanStr</code>单独作为一个goroutine，这样就存在两个goroutine，一个main，还有一个是匿名函数，接受者和发送者在不同goroutine上，就不会出现deadlock了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chanStr := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		chanStr &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	a := &lt;- chanStr</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言defer细节</title>
    <url>/2020/06/27/go%E8%AF%AD%E8%A8%80defer%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h3 id="go语言中的defer"><a href="#go语言中的defer" class="headerlink" title="go语言中的defer"></a>go语言中的defer</h3><ol>
<li>当执行defer时，会将defer后面的语句压入到单独的栈(defer栈)。</li>
<li>当函数执行完毕后（遇到return，panic或者函数顺序执行完），在从defer栈中，按照先入后出的方式，执行。</li>
<li>如果函数的定义为匿名返回值,则defer无法修改。</li>
<li>如果函数的定义为具名返回值,则defer会进行修改。</li>
<li>在函数中，需要创建资源，文件句柄，数据库连接等，在执行完毕后，关闭这些资源。go提供了defer(延时机制)。</li>
</ol>
<a id="more"></a>

<h3 id="顺序执行遇到defer情况"><a href="#顺序执行遇到defer情况" class="headerlink" title="顺序执行遇到defer情况"></a>顺序执行遇到defer情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第一个数为&quot;</span>, n1) <span class="comment">// 最后第一执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第二个数为&quot;</span>, n2) <span class="comment">// 最后第二执行</span></span><br><span class="line">	res := n1+n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为&quot;</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印先输出fmt.Println里面的内容，接着输出最后一个defer内容，最后输出第一个defer的内容。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">结果为 <span class="number">3</span></span><br><span class="line">第二个数为 <span class="number">2</span></span><br><span class="line">第一个数为 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="defer遇到return的情况"><a href="#defer遇到return的情况" class="headerlink" title="defer遇到return的情况"></a>defer遇到return的情况</h3><ul>
<li>当defer遇到return，在return之前，会执行defer的内容，然后再进行return。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第一个数为&quot;</span>, n1) <span class="comment">// 最后第一执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第二个数为&quot;</span>, n2) <span class="comment">// 最后第二执行</span></span><br><span class="line">	res := n1+n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;结果为&quot;</span>,res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虽然有return, 但defer在栈里面，在return之前会先进行执行defer内容</strong></p>
<p>输出内容为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结果为 3</span><br><span class="line">第二个数为 2</span><br><span class="line">第一个数为 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>但如果defer在return后面, 则不会执行defer内容，遇到return就返回了。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">3</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;我是if&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;我是if return后面的defer&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出内容只有”我是if”,因为在if里面直接return了，不会触发defer。</p>
<h3 id="defer遇到匿名返回值情况"><a href="#defer遇到匿名返回值情况" class="headerlink" title="defer遇到匿名返回值情况"></a>defer遇到匿名返回值情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">string</span></span><br><span class="line">	result = <span class="string">&quot;ccc&quot;</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		result = <span class="string">&quot;Change World&quot;</span> <span class="comment">// change value at the very last moment</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(foo())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ccc</span><br></pre></td></tr></table></figure>
<p>因为没有指定返回值，只指定了返回类型(string)，所以defer内容无法修改result内容，打印出来的result为”ccc”。</p>
<h3 id="defer遇到具名返回值情况"><a href="#defer遇到具名返回值情况" class="headerlink" title="defer遇到具名返回值情况"></a>defer遇到具名返回值情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(result <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	result = <span class="string">&quot;ccc&quot;</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		result = <span class="string">&quot;Change World&quot;</span> <span class="comment">// change value at the very last moment</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Change World</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为指定了返回值result， 所以defer的内容可以影响result，结果为Change World.</p>
<p>refer:</p>
<blockquote>
<p><a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a><br><a href="https://golang.org/ref/spec#Defer_statements">https://golang.org/ref/spec#Defer_statements</a><br><a href="https://stackoverflow.com/questions/37248898/how-does-defer-and-named-return-value-work">https://stackoverflow.com/questions/37248898/how-does-defer-and-named-return-value-work</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基本类型以及之间的转换</title>
    <url>/2020/06/14/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="go语言基本类型"><a href="#go语言基本类型" class="headerlink" title="go语言基本类型"></a>go语言基本类型</h2><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p><strong>1. 有符号整型</strong></p>
<p><img src="https://assets.iostat.io/image/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B.png" alt="有符号型"></p>
<a id="more"></a>

<p><strong>2. 无符号整型</strong></p>
<p><img src="https://assets.iostat.io/image/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B.png" alt="无符号型"></p>
<p><strong>3. byte和rune类型</strong></p>
<ol>
<li><p>byte类型实则为unit8类型，他用来存放ASCII字符。</p>
</li>
<li><p>rune类型实则为int32类型，他用来存放以utf-8编码的unicode字符类型。</p>
</li>
<li><p>byte和rune都是用单引号引起来，比如’A’, ‘黄’。</p>
</li>
<li><p><strong>如果没有指定类型，则默认为rune类型</strong>，比如var char = ‘A’, 此时char是rune类型。</p>
</li>
<li><p><strong>如果要用byte类型，则需要声明的时候指定byte类型</strong>，比如var char byte = ‘A’，此时char是byte类型。</p>
</li>
<li><p>因为byte和rune类型，实际是整数，所以如果对于’A’的存放使用byte，则是存了65这个值。</p>
</li>
</ol>
<p><strong>4. 浮点型</strong></p>
<p><img src="https://assets.iostat.io/image/%E6%B5%AE%E7%82%B9%E5%9E%8B.png" alt="浮点型"></p>
<p>​    <strong>float32</strong></p>
<p>​    单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数。</p>
<p><img src="https://assets.iostat.io/%E5%8D%95%E7%B2%BE%E5%BA%A6" alt="单精度"></p>
<p>​    <strong>float64</strong></p>
<p>​    双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数。</p>
<p><img src="https://assets.iostat.io/%E5%8F%8C%E7%B2%BE%E5%BA%A6" alt="双精度"></p>
<p>​       </p>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ol>
<li><p>字符类型strings是一串byte，使用双引号，或者单反引号来表示，<code>&quot;hello&quot;</code>, `hello`。</p>
</li>
<li><p>双引号内的字符串，不可以跨行，且会受到转义字符的影响，比如\n,\t，如果想要不受影响，则使用单反引号。</p>
</li>
</ol>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><ol>
<li>bool类型只有false和true两种，且不可以像python那样存在隐式转换。</li>
</ol>
<h2 id="类型之间的转换"><a href="#类型之间的转换" class="headerlink" title="类型之间的转换"></a>类型之间的转换</h2><ol>
<li>go语言不存在类型之间的隐式转换，都需要进行显式转换。</li>
<li>转换可以从小范围往大范围转换，也可以大范围往小范围转换，<strong>但大范围转小范围往往会导致结果溢出</strong>。</li>
</ol>
<h3 id="数字类型之间的转换"><a href="#数字类型之间的转换" class="headerlink" title="数字类型之间的转换"></a>数字类型之间的转换</h3><h4 id="只需要进行T-v-的方式即可"><a href="#只需要进行T-v-的方式即可" class="headerlink" title="只需要进行T(v)的方式即可"></a>只需要进行T(v)的方式即可</h4><ol>
<li><p>int32转int64</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num32 <span class="keyword">int32</span> = <span class="number">123</span></span><br><span class="line">	num64 := <span class="keyword">int64</span>(num32)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换前的值为%d, 类型为%T\n转换后的值为%d, 类型为%T\n&quot;</span>, num32, num32, num64, num64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">转换前的值为<span class="number">123</span>, 类型为<span class="keyword">int32</span></span><br><span class="line">转换后的值为<span class="number">123</span>, 类型为<span class="keyword">int64</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>int32转float32</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num32 <span class="keyword">int32</span> = <span class="number">123</span></span><br><span class="line">	num64 := <span class="keyword">float32</span>(num32)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换前的值为%d, 类型为%T\n转换后的值为%f, 类型为%T\n&quot;</span>, num32, num32, num64, num64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">转换前的值为<span class="number">123</span>, 类型为<span class="keyword">int32</span></span><br><span class="line">转换后的值为<span class="number">123.000000</span>, 类型为<span class="keyword">float32</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>float64转int64，<strong>会把小数部分掐掉</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num32 <span class="keyword">float64</span> = <span class="number">123.756</span></span><br><span class="line">	num64 := <span class="keyword">int64</span>(num32)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换前的值为%f, 类型为%T\n转换后的值为%d, 类型为%T\n&quot;</span>, num32, num32, num64, num64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">转换前的值为<span class="number">123.756000</span>, 类型为<span class="keyword">float64</span></span><br><span class="line">转换后的值为<span class="number">123</span>, 类型为<span class="keyword">int64</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="4">
<li><p>大范围转小范围容易产生结果溢出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num32 <span class="keyword">int64</span> = <span class="number">999999</span></span><br><span class="line">	num64 := <span class="keyword">int8</span>(num32) <span class="comment">//转换成了小范围int8</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换前的值为%d, 类型为%T\n转换后的值为%d, 类型为%T\n&quot;</span>, num32, num32, num64, num64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output 结果溢出导致不是期望的结果</span><br><span class="line">转换前的值为<span class="number">999999</span>, 类型为<span class="keyword">int64</span></span><br><span class="line">转换后的值为<span class="number">63</span>, 类型为<span class="keyword">int8</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><ol>
<li><p>使用<code>fmt.Sprintf</code>方式进行转换, 该方法传入对象，以及对象所属类型，然后转换成string类型返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num32 <span class="keyword">int32</span> = <span class="number">64</span></span><br><span class="line">	<span class="keyword">var</span> flo32 <span class="keyword">float32</span> = <span class="number">12.34</span></span><br><span class="line">	<span class="keyword">var</span> Bool <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> Byte <span class="keyword">byte</span> = <span class="string">&#x27;h&#x27;</span></span><br><span class="line">	<span class="keyword">var</span> Rune <span class="keyword">rune</span> = <span class="string">&#x27;黄&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传入类型以及内容</span></span><br><span class="line">	str := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, num32) <span class="comment">// num32是%d类型，转换为string类型返回给str</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">	str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, flo32) <span class="comment">// %f, 表示浮点类型, 这里会对精度补足0，所以如果要作为字符串的话，还需要把末尾的0去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">	str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>, Bool) <span class="comment">// %t，表示false或者true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">	str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>, Byte) <span class="comment">// %c，表示字符类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">	str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>, Rune) <span class="comment">// %c，表示字符类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">转换后得到的内容为<span class="number">64</span>, 类型为<span class="keyword">string</span></span><br><span class="line">转换后得到的内容为<span class="number">12.340000</span>, 类型为<span class="keyword">string</span></span><br><span class="line">转换后得到的内容为<span class="literal">false</span>, 类型为<span class="keyword">string</span></span><br><span class="line">转换后得到的内容为h, 类型为<span class="keyword">string</span></span><br><span class="line">转换后得到的内容为黄, 类型为<span class="keyword">string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>使用<code>strconv</code>进行转换</p>
<p><a href="https://studygolang.com/pkgdoc">strconv使用文档</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num32 <span class="keyword">int32</span> = <span class="number">64</span></span><br><span class="line">	<span class="keyword">var</span> flo32 <span class="keyword">float32</span> = <span class="number">12.34</span></span><br><span class="line">	<span class="keyword">var</span> Bool <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传入类型以及内容</span></span><br><span class="line">	str := strconv.FormatInt(<span class="keyword">int64</span>(num32), <span class="number">10</span>) <span class="comment">// 告诉带转换的num32为10进制。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">	str = strconv.FormatFloat(<span class="keyword">float64</span>(flo32), <span class="string">&#x27;f&#x27;</span>, <span class="number">3</span>, <span class="number">32</span>) <span class="comment">//格式为float类型，保留10位小数，原数据是float64类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">	str = strconv.FormatBool(Bool) <span class="comment">// 只需要传入布尔类型即可， 根据内容返回true还是false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换后得到的内容为%v, 类型为%T\n&quot;</span>,str,str)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="转换为Bool类型"><a href="#转换为Bool类型" class="headerlink" title="转换为Bool类型"></a>转换为Bool类型</h3><p>   <code>func ParseBool</code></p>
<p>   <a href="https://github.com/golang/go/blob/master/src/strconv/atob.go?name=release#10">func ParseBool参考</a></p>
<p>   返回字符串表示的Bool值。<strong>它接受字符串1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</strong>返回两个值，一个是转换后的值，一个是err。</p>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;false&quot;</span></span><br><span class="line">	<span class="keyword">var</span> numTrue <span class="keyword">string</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line">	strBool, _ := strconv.ParseBool(str)</span><br><span class="line">	numBool, _ := strconv.ParseBool(numTrue)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;strBool值为%t, numBool值为%t\n&quot;</span>, strBool, numBool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="字符串转换为数字类型"><a href="#字符串转换为数字类型" class="headerlink" title="字符串转换为数字类型"></a>字符串转换为数字类型</h3><ol>
<li><p><code>strconv.ParseInt()</code>方式转换为有符号int类型</p>
<ul>
<li><strong>strconv.ParseInt()的bitSize参数不会将字符串转换为您选择的类型, 而只是在此处将结果限制为特定的“位”，如果想要得到你要的int类型必须手动转换类型。</strong></li>
<li>接受正负号。</li>
<li>具体参考<a href="https://studygolang.com/static/pkgdoc/pkg/strconv.htm#pkg-index">func ParseInt</a></li>
<li>strconv.ParseUint()该方法转换为无符号int类型，<strong>不接受正负号</strong></li>
</ul>
</li>
</ol>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">    num, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">    unum, _ := strconv.ParseUint(str, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num值为%d, num类型为%T\n&quot;</span>, num,num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unum值为%d, unum类型为%T\n&quot;</span>, unum,unum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">num值为<span class="number">123</span>, num类型为<span class="keyword">int64</span></span><br><span class="line">unum值为<span class="number">123</span>, unum类型为<span class="keyword">uint64</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p><code>strconv.ParseFloat()</code>将转换为float类型</p>
<ul>
<li>得到的</li>
<li>具体参考<a href="https://github.com/golang/go/blob/master/src/strconv/atof.go?name=release#533">func ParseFloat</a> </li>
<li>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;123.33&quot;</span></span><br><span class="line"></span><br><span class="line">    num, _ := strconv.ParseFloat(str, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num值为%f, num类型为%T\n&quot;</span>, num,num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">num值为<span class="number">123.330000</span>, num类型为<span class="keyword">float64</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="String类型和byte类型互转"><a href="#String类型和byte类型互转" class="headerlink" title="String类型和byte类型互转"></a>String类型和byte类型互转</h3><ol>
<li><p>string无法直接转换为byte，<strong>需要转换为[]byte进行处理</strong>。</p>
</li>
<li><p>byte转换成string，可以直接使用<code>string()</code>方法转换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;huangyisan&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换成byte数组, 可以处理英文和数组 ,[]byte按照字节来处理,而汉字占用3个字节</span></span><br><span class="line">	arr1 := []<span class="keyword">byte</span>(str)</span><br><span class="line">	arr1[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">    fmt.Println(arr1)</span><br><span class="line">	str = <span class="keyword">string</span>(arr1) <span class="comment">// 将[]byte转换为string类型</span></span><br><span class="line">	fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[<span class="number">122</span> <span class="number">117</span> <span class="number">97</span> <span class="number">110</span> <span class="number">103</span> <span class="number">121</span> <span class="number">105</span> <span class="number">115</span> <span class="number">97</span> <span class="number">110</span>] <span class="comment">// 因为byte的实现是uint8, 所以这边打印出来的是数字。</span></span><br><span class="line">zuangyisan</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="string类型和rune类型互转"><a href="#string类型和rune类型互转" class="headerlink" title="string类型和rune类型互转"></a>string类型和rune类型互转</h3><ol>
<li><p>string类型转换成rune类型，跟byte一样，<strong>需要先作为切片</strong>。</p>
</li>
<li><p>rune类型转string类型，可以直接使用<code>string()</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;huangyisan&quot;</span></span><br><span class="line">    <span class="comment">//转换成rune数组, 可以处理中文</span></span><br><span class="line">    arr2 := []<span class="keyword">rune</span>(str)</span><br><span class="line">    fmt.Println(arr2)</span><br><span class="line">    arr2[<span class="number">0</span>] = <span class="string">&#x27;黄&#x27;</span></span><br><span class="line">    str = <span class="keyword">string</span>(arr2) <span class="comment">// 使用string将rune切片转换为string类型。</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line">[<span class="number">104</span> <span class="number">117</span> <span class="number">97</span> <span class="number">110</span> <span class="number">103</span> <span class="number">121</span> <span class="number">105</span> <span class="number">115</span> <span class="number">97</span> <span class="number">110</span>]  <span class="comment">// 因为byte的实现是int32, 所以这边打印出来的是数字。</span></span><br><span class="line">黄uangyisan</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Helm的简单使用</title>
    <url>/2020/06/21/helm%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="HELM基本介绍"><a href="#HELM基本介绍" class="headerlink" title="HELM基本介绍"></a>HELM基本介绍</h1><p>helm是一个可以让k8s上的应用服务进行简便安装，方便管理的工具。可以理解对yum/apt等包管理工具，只不过他是k8s特有的。</p>
<p>目前helm有v2以及v3版本。v2版本需要客户端和服务端相互配合，服务端成为tiller，而v3的版本则不需要服务端的支持了。对于helm的命令，v2和v3也有许些区别。</p>
<p>为什么要有helm? 通常我们一个k8s应用服务有pods, depolyment, services，ingress等等若干组件来组成，且部分组件还有相互调用的关系，你可以需要编写很多个yaml文件来处理其中之间的关系。你自己对这些文件了如指掌，但如果进行交付给他人维护，或者要做ci/cd的话，可能就不是很方便了。使用helm，编写chart，或者使用互联网上已经存在的现存chart，通过命令，非常便捷的部署和管理应用服务。</p>
<p><strong>本篇使用的是v3版本。</strong></p>
<a id="more"></a>

<h1 id="HELM的三个概念"><a href="#HELM的三个概念" class="headerlink" title="HELM的三个概念"></a>HELM的三个概念</h1><ul>
<li><p><strong>Chart</strong>，chart类似yum list 所看到的包。安装后则在k8s上进行运行。</p>
</li>
<li><p><strong>Repository</strong>，则是helm的源，和yum源类似，可以配置多个，但刚安装完毕的helm没有默认源，需要手工配置。</p>
</li>
<li><p><strong>Release</strong>，则是安装了chart后，在k8s上运行的服务，称之为release。简单理解就是，某个应用还未部署在k8s上，称之为chart，部署后称之为release。</p>
</li>
</ul>
<h1 id="HELM的使用"><a href="#HELM的使用" class="headerlink" title="HELM的使用"></a>HELM的使用</h1><h3 id="HELM的安装"><a href="#HELM的安装" class="headerlink" title="HELM的安装"></a>HELM的安装</h3><p>常用的三个平台(linux, mac, win)都有对应的二进制包，可以去github下载。<a href="https://github.com/helm/helm">github地址</a></p>
<h3 id="配置HELM源"><a href="#配置HELM源" class="headerlink" title="配置HELM源"></a>配置HELM源</h3><p>跟yum类似，但helm一开始是不存在默认的源，需要手工配置。</p>
<p>配置命令为<code>helm repo add 源名称 源地址</code>。国内可以添加微软的源，谷歌的基本上被墙。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hysan\Desktop&gt; helm repo add google https://kubernetes<span class="literal">-charts</span>.storage.googleapis.com/</span><br><span class="line"><span class="string">&quot;google&quot;</span> has been added to your repositories</span><br></pre></td></tr></table></figure>


<p>可以使用<code>helm repo list</code>查看当前存在的helm repo。 添加完后对repo更新<code>helm repo update</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hysan\Desktop&gt; helm repo list</span><br><span class="line">NAME            URL</span><br><span class="line">concourse       https://concourse<span class="literal">-charts</span>.storage.googleapis.com/</span><br><span class="line">stable          http://mirror.azure.cn/kubernetes/charts/</span><br><span class="line">google          https://kubernetes<span class="literal">-charts</span>.storage.googleapis.com/</span><br></pre></td></tr></table></figure>


<p>查看指定repo内的包(称之为chart), 被列出来的都是源里面的chart，使用命令<code>helm search repo repo名称</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hysan\Desktop&gt; helm search repo google</span><br><span class="line">NAME                                    CHART VERSION   APP VERSION             DESCRIPTION</span><br><span class="line"></span><br><span class="line">google/acs<span class="literal">-engine</span><span class="literal">-autoscaler</span>            <span class="number">2.2</span>.<span class="number">2</span>           <span class="number">2.1</span>.<span class="number">1</span>                   DEPRECATED Scales worker nodes within agent pools</span><br><span class="line">google/aerospike                        <span class="number">0.3</span>.<span class="number">2</span>           v4.<span class="number">5.0</span>.<span class="number">5</span>                A Helm chart <span class="keyword">for</span> Aerospike <span class="keyword">in</span> Kubernetes</span><br><span class="line"></span><br><span class="line">google/airflow                          <span class="number">7.1</span>.<span class="number">5</span>           <span class="number">1.10</span>.<span class="number">10</span>                 Airflow is a platform to programmatically autho...</span><br><span class="line">google/ambassador                       <span class="number">5.3</span>.<span class="number">2</span>           <span class="number">0.86</span>.<span class="number">1</span>                  DEPRECATED A Helm chart <span class="keyword">for</span> Datawire Ambassador</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>


<h3 id="查看指定的chart"><a href="#查看指定的chart" class="headerlink" title="查看指定的chart"></a>查看指定的chart</h3><p>使用<code>helm search repo chart名称</code>便会列出所有repo中符合的chart。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">PS</span> C:\Users\hysan\Desktop&gt; helm search  repo concourse</span><br><span class="line"><span class="attribute">NAME</span>                    CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line"><span class="attribute">concourse</span>/concourse     <span class="number">11</span>.<span class="number">2</span>.<span class="number">1</span>          <span class="number">6</span>.<span class="number">3</span>.<span class="number">0</span>           Concourse is a simple and scalable CI system.</span><br><span class="line"><span class="attribute">google</span>/concourse        <span class="number">8</span>.<span class="number">3</span>.<span class="number">7</span>           <span class="number">5</span>.<span class="number">6</span>.<span class="number">0</span>           DEPRECATED Concourse is a simple and scalable C...</span><br><span class="line"><span class="attribute">stable</span>/concourse        <span class="number">8</span>.<span class="number">3</span>.<span class="number">7</span>           <span class="number">5</span>.<span class="number">6</span>.<span class="number">0</span>           DEPRECATED Concourse is a simple and scalable C...</span><br></pre></td></tr></table></figure>


<p>查看一个具体的chart信息，使用<code>helm show chart chat名称</code></p>
<p>比如我查看google/mysql这个chart</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hysan\Desktop&gt; helm show chart google/mysql</span><br><span class="line">apiVersion: v1</span><br><span class="line">appVersion: <span class="number">5.7</span>.<span class="number">30</span></span><br><span class="line">description: Fast, reliable, scalable, and easy to use <span class="built_in">open-source</span> relational database</span><br><span class="line">  system.</span><br><span class="line">home: https://www.mysql.com/</span><br><span class="line">icon: https://www.mysql.com/common/logos/logo<span class="literal">-mysql</span><span class="literal">-170x115</span>.png</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>


<p>查看<strong>更加具体</strong>的chart信息，使用<code>helm show all chart名称</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hysan\Desktop&gt; helm show  all google/mysql</span><br><span class="line">apiVersion: v1</span><br><span class="line">appVersion: <span class="number">5.7</span>.<span class="number">30</span></span><br><span class="line">description: Fast, reliable, scalable, and easy to use <span class="built_in">open-source</span> relational database</span><br><span class="line">  system.</span><br><span class="line">home: https://www.mysql.com/</span><br><span class="line">icon: https://www.mysql.com/common/logos/logo<span class="literal">-mysql</span><span class="literal">-170x115</span>.png</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>


<p>查看<strong>全部可用版本</strong>，使用<code>-l</code>或者<code>--versions</code></p>
<p>例如查看google/mariadb 各种版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm search repo google/mariadb --versions</span><br><span class="line">NAME            CHART VERSION   APP VERSION             DESCRIPTION</span><br><span class="line">google/mariadb  7.3.14          10.3.22                 DEPRECATED Fast, reliable, scalable, and easy t...</span><br><span class="line">google/mariadb  7.3.13          10.3.22                 DEPRECATED Fast, reliable, scalable, and easy t...</span><br><span class="line">google/mariadb  7.3.12          10.3.22                 Fast, reliable, scalable, and easy to use open-...</span><br><span class="line">google/mariadb  7.3.11          10.3.22                 Fast, reliable, scalable, and easy to use open-...</span><br><span class="line">google/mariadb  7.3.10          10.3.22                 Fast, reliable, scalable, and easy to use open-...</span><br><span class="line">google/mariadb  7.3.9           10.3.22                 Fast, reliable, scalable, and easy to use open-...</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>




<h2 id="安装-删除一个Chart"><a href="#安装-删除一个Chart" class="headerlink" title="安装/删除一个Chart"></a>安装/删除一个Chart</h2><p>安装一个chart，使用<code>helm install 在k8s上定义的release名 chart名</code></p>
<p>这边要注意的是，如果k8s在远程，则需要使用–kubeconfig k8s文件来使用。</p>
<p><strong>如果要指定某个版本，则可以使用<code>--verison vx.y</code>方式，例如<code>helm install prometheus --version v6.7.4 </code></strong></p>
<p>比如远程安装一个concourse的服务。<em>在上面选择concourse/concourse这个chart安装</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install --kubeconfig C:\Users\hysan\Desktop\k3s.yaml my-concourse concourse/concourse</span><br></pre></td></tr></table></figure>


<p>如果不想自己取名，则可以使用<code>--generate-name</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install --kubeconfig C:\Users\hysan\Desktop\k3s.yaml  concourse/concourse --generate-name`</span><br></pre></td></tr></table></figure>


<p>使用<code>kubectl get all</code>可以查看k8s是否安装了concourse。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uangyisan@k3s-master:~$ sudo ./k3s kubectl get all</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/my-nginx-9b596c8c4-62gm2            1/1     Running   1          22h</span><br><span class="line">pod/my-concourse-worker-1               1/1     Running   0          117s</span><br><span class="line">pod/my-concourse-worker-0               1/1     Running   0          117s</span><br><span class="line">pod/my-concourse-postgresql-0           1/1     Running   0          117s</span><br><span class="line">pod/my-concourse-web-7bb67d8c8c-v26lm   1/1     Running   0          117s</span><br><span class="line"></span><br><span class="line">NAME                                       TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">service/kubernetes                         ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP          3d4h</span><br><span class="line">service/web-proxy                          NodePort    10.43.166.153   &lt;none&gt;        8080:30080/TCP   2d5h</span><br><span class="line">service/my-concourse-postgresql-headless   ClusterIP   None            &lt;none&gt;        5432/TCP         118s</span><br><span class="line">service/my-concourse-worker                ClusterIP   None            &lt;none&gt;        &lt;none&gt;           118s</span><br><span class="line">service/my-concourse-web                   ClusterIP   10.43.184.42    &lt;none&gt;        8080/TCP         118s</span><br><span class="line">service/my-concourse-web-worker-gateway    ClusterIP   10.43.96.157    &lt;none&gt;        2222/TCP         118s</span><br><span class="line">service/my-concourse-postgresql            ClusterIP   10.43.215.201   &lt;none&gt;        5432/TCP         118s</span><br><span class="line"></span><br><span class="line">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/my-nginx           1/1     1            1           22h</span><br><span class="line">deployment.apps/my-concourse-web   1/1     1            1           118s</span><br><span class="line"></span><br><span class="line">NAME                                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/my-nginx-9b596c8c4            1         1         1       22h</span><br><span class="line">replicaset.apps/my-concourse-web-7bb67d8c8c   1         1         1       118s</span><br><span class="line"></span><br><span class="line">NAME                                       READY   AGE</span><br><span class="line">statefulset.apps/my-concourse-worker       2/2     118s</span><br><span class="line">statefulset.apps/my-concourse-postgresql   1/1     118s</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>使用<code>helm list</code>可以查看当前k8s部署了的chart，也就是列出release。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm list --kubeconfig C:\Users\hysan\Desktop\k3s.yaml</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART          APP VERSION</span><br><span class="line">my-concourse    default         1               2020-06-21 22:15:46.0507691 +0800 CST   deployed        concourse-11.2.6.3.0</span><br></pre></td></tr></table></figure>


<p>删除命令也很简单，install修改为uninstall，指定release名称即可。<code>helm uninstall release名称</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm uninstall --kubeconfig C:\Users\hysan\Desktop\k3s.yaml my-concourse</span><br><span class="line">manifest-0</span><br><span class="line"></span><br><span class="line">release &quot;my-concourse&quot; uninstalled</span><br></pre></td></tr></table></figure>


<h3 id="自定义变量安装"><a href="#自定义变量安装" class="headerlink" title="自定义变量安装"></a>自定义变量安装</h3><ol>
<li>如果编写过自己的chart，则能知道其其实是由一个个yaml，或其他文件组成。</li>
<li>自己编写的chart，可以将value抽取出来，放到Values.yaml文件中。那么在安装的时候可以改写变量，或者指定某个变量的值进行安装。</li>
</ol>
<h4 id="打印出指定chart的value内容"><a href="#打印出指定chart的value内容" class="headerlink" title="打印出指定chart的value内容"></a>打印出指定chart的value内容</h4><p>其实打印的就是values.yaml文件的内容，使用命令<code>helm show values chart名称</code></p>
<p>比如查看concourse/concourse这个chart的values</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm  --kubeconfig C:\Users\hysan\Desktop\k3s.yaml  show values concourse/concourse</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Default values for Concourse Helm Chart.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># This is a YAML-formatted file.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Declare variables to be passed into your templates.</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Provide a name in place of `concourse` for `app:` labels</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line">nameOverride:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Provide a name to substitute for the full names of resources</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line">fullnameOverride:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Concourse image to use in both Web and Worker containers.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line">image: concourse/concourse</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure>


<p><strong>我们可以把这个文件定向到一个yaml文件，然后修改里面需要修改的值，在使用-f指定该修改后的yaml文件进行安装。</strong></p>
<p>进行重定向到一个文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm  --kubeconfig C:\Users\hysan\Desktop\k3s.yaml  show values concourse/concourse &gt; C:\Users\hysan\Desktop\concourse.yml</span><br></pre></td></tr></table></figure>


<h4 id="覆盖变量进行安装"><a href="#覆盖变量进行安装" class="headerlink" title="覆盖变量进行安装"></a>覆盖变量进行安装</h4><p>使用-f或者–values指定该concourse.yaml进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm --kubeconfig .\k3s.yaml install -f .\concourse.yml concourse concourse/concourse</span><br></pre></td></tr></table></figure>


<p><strong>如果只需要修改一个值，嫌导出麻烦，则可以使用–set name=value的方式修改并安装。如果同时存在–set方式和-f指定yaml文件的方式，–set的修改内容会覆盖-f指定的yaml文件内容</strong></p>
<h3 id="HELM进行更新和回退"><a href="#HELM进行更新和回退" class="headerlink" title="HELM进行更新和回退"></a>HELM进行更新和回退</h3><p>当需要对HELM部署的应用进行更新的时候，先修改yaml文件，然后使用upgrade进行更新。<code>helm upgrade -f .\concourse.yml  release名称 chart名称</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm --kubeconfig .\k3s.yaml upgrade -f .\concourse.yml  concourse concourse/concourse</span><br><span class="line">Release &quot;concourse&quot; has been upgraded. Happy Helming!</span><br><span class="line">NAME: concourse</span><br><span class="line">LAST DEPLOYED: Sun Jun 21 22:48:05 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 2</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">* Concourse can be accessed:</span><br></pre></td></tr></table></figure>


<p>upgrade操作后，可以使用<code>helm get values release名称</code>命令查看更新的value是否更新。</p>
<p>通过<code>helm list</code>命令可以看到concourse此时的<code>REVISION</code>更新为<strong>2</strong>了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm --kubeconfig .\k3s.yaml list</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART          APP VERSION</span><br><span class="line">concourse       default         2               2020-06-21 22:48:05.9812653 +0800 CST   deployed        concourse-11.2.6.3.0</span><br></pre></td></tr></table></figure>


<p>如果要回退到<strong>REVISION 1 时候的状态</strong>，则可以使用rollback命令，<code>helm rollback release名称 回退的版本</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm --kubeconfig .\k3s.yaml rollback concourse 1</span><br><span class="line">Rollback was a success! Happy Helming!</span><br></pre></td></tr></table></figure>


<p><strong>这边回滚了，但千万不要认为REVISION变成了1，当前只是回到了曾经1的状态，但REVISION一直都是递增的，也就是之前的2+1=3。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\Desktop&gt; helm --kubeconfig .\k3s.yaml list</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART          APP VERSION</span><br><span class="line">concourse       default         3               2020-06-21 22:54:03.8030572 +0800 CST   deployed        concourse-11.2.6.3.0</span><br></pre></td></tr></table></figure>


<h1 id="HELM其他一些命令"><a href="#HELM其他一些命令" class="headerlink" title="HELM其他一些命令"></a>HELM其他一些命令</h1><ul>
<li><a href="https://helm.sh/docs/helm/helm_get_manifest/">helm get manifest release名称</a> 用来获取release的mainfest文件</li>
<li><a href="https://helm.sh/docs/helm/helm_pull/">helm pull chart名称</a> 下载指定chart，查看其编写文件</li>
<li>很多命令可以配合<code>--flag</code>内容来做更多的展现，<a href="https://helm.sh/docs/helm/">更多参考</a></li>
</ul>
<p>refer:</p>
<blockquote>
<p><a href="https://helm.sh/docs/">https://helm.sh/docs/</a></p>
</blockquote>
<p>Helm的一些缺点</p>
<blockquote>
<p><a href="https://winderresearch.com/7-reasons-why-you-shouldnt-use-helm-in-production/#value-proposition">https://winderresearch.com/7-reasons-why-you-shouldnt-use-helm-in-production/#value-proposition</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title>is和==比较区别</title>
    <url>/2019/01/17/is%E5%92%8C==%E6%AF%94%E8%BE%83%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><p>** is比较的对象为内存地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140379285741320</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140379285738696</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><p>** ==比较的对象是值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140379285741320</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140379285738696</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="关于int类型的缓存"><a href="#关于int类型的缓存" class="headerlink" title="关于int类型的缓存"></a>关于int类型的缓存</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">9322464</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">9322464</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">140379285517520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">140379285517584</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>上述当ab都等于1的时候，两者指向的内存地址一致，但当ab赋值了999后，两者指向的内存地址不一致。</p>
<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><p><strong>python对于int类型进行缓存，当int属于[-5, 256]范围的时候，会被缓存，倘若在这个区间进行赋值，则指向的内存地址都是一致的。</strong></p>
<p>这个产生的原因比较复杂，<strong>倘若a和b都赋值在同一行，则两者is比较也是True</strong>，具体可以看refer。</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/15171695/whats-with-the-integer-cache-inside-python">https://stackoverflow.com/questions/15171695/whats-with-the-integer-cache-inside-python</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s拉取私有镜像</title>
    <url>/2020/08/06/k8s%E6%8B%89%E5%8F%96%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="部署流程图"><a href="#部署流程图" class="headerlink" title="部署流程图"></a>部署流程图</h1><h2 id="生产遇到的问题"><a href="#生产遇到的问题" class="headerlink" title="生产遇到的问题"></a>生产遇到的问题</h2><p>k8s环境在一个阿里账号下，但阿里镜像仓库在另外的一个阿里账号下。</p>
<p>在k8s环境中部署服务的时候，发现镜像拉取失败，使用<code>kubectl describe pod xxx</code>在event字段发现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason     Age                From                Message</span><br><span class="line">  ----     ------     ----               ----                -------</span><br><span class="line">  Normal   Scheduled  &lt;unknown&gt;          default-scheduler   Successfully assigned default/nginx to k3s-node2</span><br><span class="line">  Warning  Failed     59s                kubelet, k3s-node2  Error: ErrImagePull</span><br><span class="line">  Warning  Failed     59s                kubelet, k3s-node2  Failed to pull image &quot;registry.cn-shanghai.aliyuncs.com/huangyisan/nginx:latest&quot;: rpc error: code = Unknown desc = failed to pull and unpack image &quot;registry.cn-shanghai.aliyuncs.com/huangyisan/nginx:latest&quot;: failed to resolve reference &quot;registry.cn-shanghai.aliyuncs.com/huangyisan/nginx:latest&quot;: pull access denied, repository does not exist or may require authorization: server message: insufficient_scope: authorization failed</span><br><span class="line">  Warning  Failed     59s                kubelet, k3s-node2  Error: ImagePullBackOff</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>报错信息表明了镜像不存在，或者需要认证后才能拉取。</p>
<p>然后上阿里云控制台检查了下，发现仓库是私有类型，当时改成了公有类型，的确可以拉取镜像了。</p>
<p><strong>但是如果镜像是根据公司业务定制化，包含了公司敏感信息，那么此时就不适合作为公有类型了</strong>。</p>
<h2 id="两种方法解决拉取私有镜像的问题"><a href="#两种方法解决拉取私有镜像的问题" class="headerlink" title="两种方法解决拉取私有镜像的问题"></a>两种方法解决拉取私有镜像的问题</h2><h3 id="方法一：通过Docker-credentials创建K8S-Secret资源"><a href="#方法一：通过Docker-credentials创建K8S-Secret资源" class="headerlink" title="方法一：通过Docker credentials创建K8S Secret资源"></a>方法一：通过Docker credentials创建K8S Secret资源</h3><ol>
<li><p>使用docker login ${registry-addr}。</p>
</li>
<li><p>输入用户名和密码。</p>
</li>
<li><p>认证通过后docker会把认证信息以明文的方式默认存放到<code>/root/.docker/config.json</code>文件内。<strong>该文件存放了所有认证通过的镜像仓库，并且使用base64编码了用户名和密码，所以如果要查看用户名和密码，只需要base64 decode即可。</strong></p>
</li>
<li><p>使用一下命令就可以在k8s的secret资源中添加一条记录了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic $&#123;secret-name&#125; \</span><br><span class="line">    --from-file=.dockerconfigjson=&lt;path/to/.docker/config.json&gt; \</span><br><span class="line">    --type=kubernetes.io/dockerconfigjson</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="方法二：使用命令行的方式添加K8S-Secret资源"><a href="#方法二：使用命令行的方式添加K8S-Secret资源" class="headerlink" title="方法二：使用命令行的方式添加K8S Secret资源"></a>方法二：使用命令行的方式添加K8S Secret资源</h2><ol>
<li><p>使用如下命令就可以在k8s的secret资源中添加一条记录了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</span><br></pre></td></tr></table></figure>
<p>其中your-email可以任意填写</p>
</li>
</ol>
<h2 id="验证镜像拉取"><a href="#验证镜像拉取" class="headerlink" title="验证镜像拉取"></a>验证镜像拉取</h2><ol>
<li><p>修改yaml文件，添加imagePullSecrets字段，使用name: ${secret-name}来指定使用哪个secret资源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: registry.cn-shanghai.aliyuncs.com/huangyisan/nginx:latest</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">  - name: ali-hys</span><br></pre></td></tr></table></figure></li>
<li><p>删除pod后重新部署，查看event字段发现已经可以正常拉取了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From                Message</span><br><span class="line">  ----    ------     ----       ----                -------</span><br><span class="line">  Normal  Scheduled  &lt;unknown&gt;  default-scheduler   Successfully assigned default/nginx to k3s-node2</span><br><span class="line">  Normal  Pulling    6s         kubelet, k3s-node2  Pulling image &quot;registry.cn-shanghai.aliyuncs.com/huangyisan/nginx:latest&quot;</span><br><span class="line">  Normal  Pulled     6s         kubelet, k3s-node2  Successfully pulled image &quot;registry.cn-shanghai.aliyuncs.com/huangyisan/nginx:latest&quot;</span><br><span class="line">  Normal  Created    6s         kubelet, k3s-node2  Created container nginx</span><br><span class="line">  Normal  Started    5s         kubelet, k3s-node2  Started container nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="查看secret资源"><a href="#查看secret资源" class="headerlink" title="查看secret资源"></a>查看secret资源</h2><ol>
<li><p>kubectl get secret -n &lt;namespace&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@test ~&#x2F;k8s] # kubectl get secret</span><br><span class="line">NAME                                 TYPE                                  DATA   AGE</span><br><span class="line">default-token-jktlx                  kubernetes.io&#x2F;service-account-token   3      48d</span><br><span class="line">my-release-ingress-nginx-admission   Opaque                                3      26h</span><br><span class="line">ali-hys                              kubernetes.io&#x2F;dockerconfigjson        1      55m</span><br><span class="line">ali-json                             kubernetes.io&#x2F;dockerconfigjson        1      31m</span><br><span class="line">You have new mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过get指定的secret名称，-o yaml导出，其实也可以看到base64编码后的信息，只要decode就能看到明文</strong></p>
</li>
</ol>
<p>refer:</p>
<blockquote>
<p><a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s配置多集群接入</title>
    <url>/2020/07/24/k8s%E9%85%8D%E7%BD%AE%E5%A4%9A%E9%9B%86%E7%BE%A4%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h1 id="情景和思路"><a href="#情景和思路" class="headerlink" title="情景和思路"></a>情景和思路</h1><p>当需要接入多个kubernetes集群的情况，如果使用--kubeconfig进行指定config file后执行kubectl命令会比较麻烦。可以使用<code>kubectl config use-context $&#123;context_name&#125;</code>命令进行切换context，从而实现一个config file文件能连接多个cluster的功能，当然一个时间段内是只能连接一个的。</p>
<h1 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h1><p>配置文件一般名称为<code>config</code>，放置路径为<code>$HOME/.kube/</code>目录下。</p>
<a id="more"></a>

<ul>
<li><p><strong>cluster</strong>，定义cluster名称，认证信息等。</p>
</li>
<li><p><strong>users</strong>，定义users的名称，认证信息等。</p>
</li>
<li><p><strong>contexts</strong>，关联了cluster和user的信息。</p>
</li>
</ul>
<h1 id="在原有集群上追加额外集群信息"><a href="#在原有集群上追加额外集群信息" class="headerlink" title="在原有集群上追加额外集群信息"></a>在原有集群上追加额外集群信息</h1><h3 id="原有配置信息"><a href="#原有配置信息" class="headerlink" title="原有配置信息"></a>原有配置信息</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://server1.com</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">secret_info==</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&quot;340933575320448663&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="number">340933575320448663</span><span class="string">-c1d785b5c421249d798362081b10830a6</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="number">340933575320448663</span><span class="string">-c1d785b5c421249d798362081b10830a6</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;340933575320448663&quot;</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">secret_info==</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">secret_info==</span></span><br></pre></td></tr></table></figure>


<h3 id="追加第二个集群的信息"><a href="#追加第二个集群的信息" class="headerlink" title="追加第二个集群的信息"></a>追加第二个集群的信息</h3><ol>
<li>在<code>clusters</code>字段内定义了<code>name</code>字段，区分了两个不同的集群，一个是<code>k3s</code>，一个是<code>kubernetes</code>。</li>
<li>在<code>users</code>字段内定义了两个user，一个是<code>340933575320448663</code>，一个是<code>default</code>。可以看出第一个user信息使用密钥方式登录；第二个使用用户名和密码登录</li>
<li>通过<code>contexts</code>字段内可以看到将<code>cluster</code>和<code>name</code>进行了关联，<code>kubernetes</code>集群指定user采用<code>340933575320448663</code>上下文信息；<code>k3s</code>集群指定user使用<code>default</code>的上下文。</li>
<li>还有一个独立的字段是<code>current-context</code>，表示当前配置文件采用哪个context，下面配置文件是使用的<code>k3s</code>，<strong>那么此时当使用命令<code>kubectl</code>操作集群的时候，是去连接k3s这个集群</strong>。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">secret_info==</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://server1.com</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k3s</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">insecure-skip-tls-verify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://server2.com</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&quot;340933575320448663&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span> <span class="comment">#切换使用的context_name</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">k3s</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k3s</span> <span class="comment">#切换使用的context_name</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">k3s</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> &#123;&#125;</span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;340933575320448663&quot;</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> <span class="string">secret_info==</span></span><br><span class="line">    <span class="attr">client-key-data:</span> <span class="string">secret_info==</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">da25a8668cd6b469df139351c74c9eda</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure>


<h2 id="切换成另外一个集群"><a href="#切换成另外一个集群" class="headerlink" title="切换成另外一个集群"></a>切换成另外一个集群</h2><p>使用命令<code>kubectl config use-context $&#123;context_name&#125;</code></p>
<p>比如当前我的context_name为k3s，要切换成配置中的kubernetes，则使用命令<code>kubectl config use-context kubernetes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\hysan\.kube&gt; kubectl config use-context kubernetes</span><br><span class="line">Switched to context &quot;kubernetes&quot;.</span><br></pre></td></tr></table></figure>
<p>此时使用kubectl命令，则连接到了kubernetes这个集群。</p>
<h2 id="手动命令行进行配置三大件"><a href="#手动命令行进行配置三大件" class="headerlink" title="手动命令行进行配置三大件"></a>手动命令行进行配置三大件</h2><p>查看refer官方文档。</p>
<p>refer:</p>
<blockquote>
<p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kill -9 不起作用</title>
    <url>/2019/02/02/kill-9%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>在公司压测，因为担心磁盘读写影响性能，所以磁盘通过nfs挂载。之后发现挂载内容无法进行读取，于是乎想重新挂载，<code>umount</code>命令下去，提示<code>Device is busy</code>，那就是铁定挂载目录或者文件被进程占用了，随之查询到了进程，打算用kill pid让进程暂停，但发现没有成功，随后用kill -9 pid强制暂停，但发现也没成功，进程pid一直存在，进程也未退出。</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>谷歌查询了下，得到了一个准确的回答。原文见refer。</p>
<p>kill不论发送任何信号，都是异步传递信号，内核传递信号给pid存在非常小的时间，但即便如此小的时间，也是需要进程腾出这么个时间点来接受，并处理，<strong>但如果进程当时处于阻止信号状态，那么发送过去的信号会被队列，等进程不在阻止信号后再传入，并且执行信号。</strong></p>
<p>通常情况下，进程不会阻止信号，但是如果此时进程调用内核代码(系统调用)，而内核代码是可以阻止信号传入的。当中断系统调用会导致内核中某处形成错误的数据结构，或者内核一些不变量被违反的时候，内核代码会阻塞所有信号传入。<strong>所以，若出现bug或其他异常情况触发了无限期的系统调用阻塞，那么就无法传递kill发送的信号。</strong></p>
<p>在系统调用中被阻塞的进程，一般称为不可中断进程，通过ps或者top，查看状态为D的进程，一般磁盘读写数据的时候是处于不可中断进程状态。</p>
<p>一个典型的例子就是nfs挂载的情况，当server没有响应的时候，往往会一直处于不可中断情况。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>暂停server端和clinet端的nfs进程，重新挂载解决。</p>
<h2 id="top-ps查看不可中断进程"><a href="#top-ps查看不可中断进程" class="headerlink" title="top ps查看不可中断进程"></a>top ps查看不可中断进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -eo pid,ppid,<span class="built_in">stat</span>,pri,uid</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="进程状态常见标记符"><a href="#进程状态常见标记符" class="headerlink" title="进程状态常见标记符"></a>进程状态常见标记符</h2><ol>
<li>R 表示进程正在Cpu的就绪队列中，正在运行或者<strong>正在等待运行。</strong></li>
<li>D 是disk sleep缩写，也就是不可中断状态睡眠，一般表示进程正在和硬件交互，而交互过程不允许被其他进程或中断打断。</li>
<li>Z 僵尸进程，实际上进程已经结束，但是父进程没有回收他的资源，比如进程描述符，pid等。</li>
<li>S 是interruptible sleep缩写，表示可中断状态睡眠，表示进程因为等待某个事件而被挂起，当进程等到事件发生时，他会被唤醒进入R状态。</li>
<li>I 是idle缩写，也是空闲状态，用在不可中断睡眠的内核线程上。前面的D是表示硬件交互导致的不可中断，但对某些内核线程来说，他们有可能实际上并没有任何负载，这边用Idle为了区分这种情况。<strong>D状态进程会导致平均负载升高，I状态的进程却不会。</strong></li>
<li>T 表示stopped状态，表示进程处于暂停状态(十字符病毒，一般都先对进程stop，然后排查问题)，发送SIGSTP就可以让进程暂停，再发送SIGCONT信号，则恢复运行。</li>
<li>t 表示跟踪状态。比如用gdb调试进程。</li>
<li>X 表示Dead，进程已经消亡，所以在ps或者top里面无法看到。</li>
</ol>
<p>refer:</p>
<blockquote>
<p><a href="https://cis.temple.edu/~ingargio/cis307/readings/signals.html">https://cis.temple.edu/~ingargio/cis307/readings/signals.html</a><br><a href="https://unix.stackexchange.com/questions/5642/what-if-kill-9-does-not-work">https://unix.stackexchange.com/questions/5642/what-if-kill-9-does-not-work</a><br><a href="https://www.cnblogs.com/my_life/articles/5630903.html">https://www.cnblogs.com/my_life/articles/5630903.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>system</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux平均负载</title>
    <url>/2019/02/05/linux%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="linux平负载定义"><a href="#linux平负载定义" class="headerlink" title="linux平负载定义"></a>linux平负载定义</h2><ol>
<li>单位时间内，处于<strong>运行或者准备运行(R)**，以及</strong>不可中断睡眠进程(D)**数量的平均值(指数平滑法)。</li>
<li>和cpu使用率没有直接关系。</li>
<li>负载上升，可能是cpu使用率过高，也可能是磁盘io问题。</li>
</ol>
<a id="more"></a>

<h2 id="平均负载算法"><a href="#平均负载算法" class="headerlink" title="平均负载算法"></a>平均负载算法</h2><p>其算法为<code>指数平滑法</code>，内核因为不可以直接做浮点运算，而选择<strong>定点运算</strong>的方式来计算指数平滑法。</p>
<p>指数平滑法公式：</p>
<ol>
<li><p>linux 2.6.18内核 load<sub>t</sub> = load<sub>t-1</sub> * α + n * (1 – α)，[0 &lt; α &lt; 1]</p>
</li>
<li><p>linux 3.12内核 load<sub>t</sub> = load<sub>t-1</sub> * α + n * (1 – α) + z，[0 &lt; α &lt; 1]    <em>3.12内核增加了修正值z。</em></p>
</li>
</ol>
<p>load<sub>t</sub>表示当前时刻一段时间内的平滑均值。<br>load<sub>t-1</sub>表示上一时间段的平滑均值。<br>α Linux Kernel要计算的是前1min, 5min, 15min的Load 均值，α需要分别选取。Linux Kernel选取的是: e<sup>-5/(60*m)</sup><br>5:表示5s，作分子。<br>60:表示60s。<br>m: 表示分钟，1, 5, 15。 60 * m作为分母。<br>把m带入到公式计算，分别能计算出0.920044415，0.983471454，0.994459848</p>
<p>参考文档:</p>
<blockquote>
<p><a href="http://brytonlee.github.io/blog/2014/05/07/linux-kernel-load-average-calc/">http://brytonlee.github.io/blog/2014/05/07/linux-kernel-load-average-calc/</a></p>
</blockquote>
<h2 id="multi-core-vs-multi-processor"><a href="#multi-core-vs-multi-processor" class="headerlink" title="multi-core vs multi-processor"></a>multi-core vs multi-processor</h2><ol>
<li>load关注机器有多少个processor<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">此公式包含超线程数。</span><br><span class="line">[root<span class="symbol">@leanote</span> ~]<span class="meta"># cat /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | wc -l</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root<span class="symbol">@leanote</span> ~]<span class="meta"># </span></span><br></pre></td></tr></table></figure></li>
<li>core可以理解为核心数，也就是cpu核心总数，而processor理解为逻辑cpu个数，而非真实cpu个数，这个逻辑cpu个数等于top后按1查看到的结果。</li>
</ol>
<h2 id="linux查看cpu信息"><a href="#linux查看cpu信息" class="headerlink" title="linux查看cpu信息"></a>linux查看cpu信息</h2><p>总核数 = 物理CPU个数 X 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p>
<p>查看物理CPU个数<br>cat /proc/cpuinfo| grep “physical id”| sort| uniq| wc -l</p>
<p>查看每个物理CPU中core的个数(即核数)<br>cat /proc/cpuinfo| grep “cpu cores”| uniq</p>
<p>查看逻辑CPU的个数<br>cat /proc/cpuinfo| grep “processor”| wc -l</p>
<p>refer</p>
<blockquote>
<p><a href="http://brytonlee.github.io/blog/2014/05/07/linux-kernel-load-average-calc/">http://brytonlee.github.io/blog/2014/05/07/linux-kernel-load-average-calc/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql字符集字符序</title>
    <url>/2019/01/10/mysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AD%97%E7%AC%A6%E5%BA%8F/</url>
    <content><![CDATA[<p>Emmmm….数据库默认配置，建库没指定字符集，然后你懂得，所有库，表，部分字段字符集都是latin1。</p>
<a id="more"></a>

<p>MariaDB version 10.1.36</p>
<p><strong>数据库分字符集(character)和字符序(collation)</strong></p>
<ul>
<li>character定义了字符以及字符的编码。</li>
<li>collation定义了字符的比较规则。</li>
</ul>
<p><strong>有四个地方涉及到字符集和字符序</strong></p>
<ul>
<li>服务器端(server level)</li>
<li>数据库(database level)</li>
<li>表(table level)</li>
<li>char varchar text类型的字段(column level)</li>
</ul>
<p><strong>如果都未进行指定，采用何种character和collation，则默认情况为character=latin1, collation=latin1_swedish_ci</strong></p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><ol>
<li><p>查看当前支持的字符集<code>SHOW charsets</code>，Default collation字段告知了，该字符集所用的默认字符序。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW charset;</span><br><span class="line">+----------+-----------------------------+---------------------+--------+</span><br><span class="line">|<span class="string"> Charset  </span>|<span class="string"> Description                 </span>|<span class="string"> Default collation   </span>|<span class="string"> Maxlen </span>|</span><br><span class="line">+----------+-----------------------------+---------------------+--------+</span><br><span class="line">|<span class="string"> big5     </span>|<span class="string"> Big5 Traditional Chinese    </span>|<span class="string"> big5_chinese_ci     </span>|<span class="string">      2 </span>|</span><br><span class="line">|<span class="string"> dec8     </span>|<span class="string"> DEC West European           </span>|<span class="string"> dec8_swedish_ci     </span>|<span class="string">      1 </span>|</span><br><span class="line">|<span class="string"> cp850    </span>|<span class="string"> DOS West European           </span>|<span class="string"> cp850_general_ci    </span>|<span class="string">      1 </span>|</span><br><span class="line">|<span class="string"> hp8      </span>|<span class="string"> HP West European            </span>|<span class="string"> hp8_english_ci      </span>|<span class="string">      1 </span>|</span><br><span class="line">|<span class="string"> koi8r    </span>|<span class="string"> KOI8-R Relcom Russian       </span>|<span class="string"> koi8r_general_ci    </span>|<span class="string">      1 </span>|</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure></li>
<li><p>查看server level当前的字符集<code>SHOW VARIABLES LIKE &quot;character_set_server&quot;</code>，查看server level当前的字符序<code>SHOW VARIABLES LIKE &quot;collation_server&quot;</code></p>
</li>
<li><p>修改server level字符集的方法:</p>
</li>
</ol>
<ul>
<li>修改配置文件</li>
<li>编译的时候</li>
<li>set 全局变量命令。但这种情况重启会失效。</li>
</ul>
<ol start="2">
<li>如果创建库，或者表，或者字段，或者配置文件my,cnf中只指定了字符集，则默认的字符序为该字符集所对应的默认字符序。</li>
</ol>
<h2 id="字符序"><a href="#字符序" class="headerlink" title="字符序"></a>字符序</h2><ol>
<li>查看当前支持的字符序<code>SHOW collation</code>, Default字段存在Yes的，表示该字符集默认的default值。比如latin1默认的字符序为latin1_swedish_ci</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW collation;</span><br><span class="line">+--------------------------+----------+-----+---------+----------+---------+</span><br><span class="line">|<span class="string"> Collation                </span>|<span class="string"> Charset  </span>|<span class="string"> Id  </span>|<span class="string"> Default </span>|<span class="string"> Compiled </span>|<span class="string"> Sortlen </span>|</span><br><span class="line">+--------------------------+----------+-----+---------+----------+---------+</span><br><span class="line">|<span class="string"> big5_chinese_ci          </span>|<span class="string"> big5     </span>|<span class="string">   1 </span>|<span class="string"> Yes     </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> big5_bin                 </span>|<span class="string"> big5     </span>|<span class="string">  84 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> dec8_swedish_ci          </span>|<span class="string"> dec8     </span>|<span class="string">   3 </span>|<span class="string"> Yes     </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> dec8_bin                 </span>|<span class="string"> dec8     </span>|<span class="string">  69 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> cp850_general_ci         </span>|<span class="string"> cp850    </span>|<span class="string">   4 </span>|<span class="string"> Yes     </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> cp850_bin                </span>|<span class="string"> cp850    </span>|<span class="string">  80 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> hp8_english_ci           </span>|<span class="string"> hp8      </span>|<span class="string">   6 </span>|<span class="string"> Yes     </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> hp8_bin                  </span>|<span class="string"> hp8      </span>|<span class="string">  72 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> koi8r_general_ci         </span>|<span class="string"> koi8r    </span>|<span class="string">   7 </span>|<span class="string"> Yes     </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> koi8r_bin                </span>|<span class="string"> koi8r    </span>|<span class="string">  74 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> latin1_german1_ci        </span>|<span class="string"> latin1   </span>|<span class="string">   5 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> latin1_swedish_ci        </span>|<span class="string"> latin1   </span>|<span class="string">   8 </span>|<span class="string"> Yes     </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br><span class="line">|<span class="string"> latin1_danish_ci         </span>|<span class="string"> latin1   </span>|<span class="string">  15 </span>|<span class="string">         </span>|<span class="string"> Yes      </span>|<span class="string">       1 </span>|</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>如果创建库，或者表，或者字段，或者配置文件my,cnf中只指定了字符序，则默认的字符集为该字符序所对应的字符集。</p>
</li>
<li><p>字符序表示的含义</p>
</li>
</ol>
<ul>
<li>一般来说分为三段，也存在一段或者两段的情况，常见的三段如<code>utf8mb4_general_ci</code>,两段的如<code>utf8mb4_bin</code>(<strong>这类情况，其实只存在第一段和第三段，第二段不存在</strong>)</li>
<li>第一段代表字符集。</li>
<li>第二段代表语言(chinese,swedish),也有general这种通用的，或者unicode类型。</li>
<li>第三段代表是否敏感，是否为bin。</li>
</ul>
<ol start="4">
<li>对于第三段的解释<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_ai</span>	Accent insensitive</span><br><span class="line"><span class="variable">_as</span>	Accent sensitive</span><br><span class="line"><span class="variable">_ci</span>	<span class="keyword">Case</span> insensitive</span><br><span class="line"><span class="variable">_cs</span>	<span class="keyword">case</span>-sensitive</span><br><span class="line"><span class="variable">_bin</span>	Binary</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>Accent是否为sensitive表现为，如果为sensitive，则比较a和á是不同的，如果为insensitive则a和á比较为相同。</li>
<li>Case insensitive为大小写不敏感，case-sensitive为大小写敏感。</li>
</ul>
<h2 id="字符集和字符序的继承顺序"><a href="#字符集和字符序的继承顺序" class="headerlink" title="字符集和字符序的继承顺序"></a>字符集和字符序的继承顺序</h2><ol>
<li>数据库服务，建库，建表，建字段，倘若其中有指定character和collation，则<code>字段</code>继承<code>表</code>，<code>表</code>继承<code>库</code>，<code>库</code>继承<code>数据库服务</code>。比如建库指定了字符集为utf8，那么该库下面的表如果不指定字符集，则表的字符集也为utf8，char、varchar、text的字段字符集也是utf8。</li>
<li><strong>有个例外，如果修改了表， 那么该表下面的字段的字符集和字符序也会变成表的字符集和字符序。</strong></li>
</ol>
<h2 id="修改查看字符集命令："><a href="#修改查看字符集命令：" class="headerlink" title="修改查看字符集命令："></a>修改查看字符集命令：</h2><ul>
<li><p>修改运行环境：</p>
  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SET</span> character_set_server = utf<span class="number">8</span>mb<span class="number">4</span></span><br><span class="line"><span class="attribute">set</span> character_set_connection = utf<span class="number">8</span>mb<span class="number">4</span></span><br><span class="line"><span class="attribute">set</span> character_set_database = utf<span class="number">8</span>mb<span class="number">4</span></span><br><span class="line"><span class="attribute">set</span> character_set_results = utf<span class="number">8</span>mb<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改库:</p>
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> dbname <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span>  utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">验证语句 </span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> dbname;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表:</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> dir <span class="type">varchar</span>(<span class="number">255</span>) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type">varchar</span>(<span class="number">191</span>)  mysql5<span class="number">.6</span>的版本需要修改。不保证所有版本都需要修改。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dir_stats MODIFY dir <span class="type">VARCHAR</span>(<span class="number">191</span>);</span><br><span class="line"><span class="number">2.</span> 修改字段类型utf8mb4</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">convert</span> <span class="keyword">to</span> <span class="type">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">验证语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> COLUMNS <span class="keyword">FROM</span> dbname.tablename;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>refer:</p>
<blockquote>
<p><a href="https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html">https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html</a><br><a href="https://mariadb.com/kb/zh-cn/setting-character-sets-and-collations">https://mariadb.com/kb/zh-cn/setting-character-sets-and-collations</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/charset-database.html">https://dev.mysql.com/doc/refman/8.0/en/charset-database.html</a><br><a href="http://zarez.net/?p=719">http://zarez.net/?p=719</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nonlocal的用法</title>
    <url>/2019/02/20/nonlocal%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>nonlocal允许对嵌套的函数作用域中的名称进行赋值，并且把这样的名称的作用域查找限制在嵌套的函数内。</strong><br><strong>nonlocal限制查找在嵌套的函数域内，且可以在函数域内进行赋值修改。</strong></p>
<a id="more"></a>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">def tester(start):</span><br><span class="line">    <span class="keyword">state</span> = start</span><br><span class="line">    def nested(<span class="keyword">label</span>):</span><br><span class="line">        print(<span class="keyword">label</span>,<span class="keyword">state</span>)</span><br><span class="line">    return nested</span><br><span class="line"></span><br><span class="line">F=tester(<span class="number">0</span>)</span><br><span class="line">F(&#x27;spam&#x27;)</span><br><span class="line">F(&#x27;ham&#x27;)</span><br><span class="line"></span><br><span class="line">执行结果为</span><br><span class="line">spam <span class="number">0</span></span><br><span class="line">ham <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>函数nested中print方法内的state变量引用了上一层tester函数中的state。</p>
<p>如果仅仅是引用变量，则不会出现问题，若是不使用nonlocal情况下对<code>变量进行赋值操作</code>，则出现报错:</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">def tester(start):</span><br><span class="line">    <span class="keyword">state</span> = start</span><br><span class="line">    def nested(<span class="keyword">label</span>):</span><br><span class="line">        print(<span class="keyword">label</span>,<span class="keyword">state</span>)</span><br><span class="line">        <span class="keyword">state</span> += <span class="number">1</span>   <span class="comment"># 对state变量进行了赋值操作，在nested函数中并没有单独定义state变量。</span></span><br><span class="line">    return nested</span><br><span class="line"></span><br><span class="line">F=tester(<span class="number">0</span>)</span><br><span class="line">F(&#x27;spam&#x27;)</span><br><span class="line">F(&#x27;ham&#x27;) </span><br><span class="line"></span><br><span class="line">报错如下：</span><br><span class="line">huangyisan:~/Desktop/Python_project/Mage_edu $ python3 nonlocalfunc.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;nonlocalfunc.py&quot;</span>, line <span class="number">18</span>, <span class="keyword">in</span> <span class="variable">&lt;module&gt;</span></span><br><span class="line">    F(&#x27;spam&#x27;)</span><br><span class="line">  File <span class="string">&quot;nonlocalfunc.py&quot;</span>, line <span class="number">13</span>, <span class="keyword">in</span> nested</span><br><span class="line">    print(<span class="keyword">label</span>,<span class="keyword">state</span>)</span><br><span class="line">UnboundLocalError: local variable &#x27;<span class="keyword">state</span>&#x27; referenced before assignment</span><br></pre></td></tr></table></figure>
<p><strong>state因为在nested中没有被定义，所以无法被赋值，但可以引用上一层tester函数。</strong></p>
<p>如果要定义，则需要用nonlocal函数对其进行声明：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">def tester(start):</span><br><span class="line">    <span class="keyword">state</span> = start</span><br><span class="line">    def nested(<span class="keyword">label</span>):</span><br><span class="line">        nonlocal <span class="keyword">state</span></span><br><span class="line">        print(<span class="keyword">label</span>,<span class="keyword">state</span>)</span><br><span class="line">        <span class="keyword">state</span> += <span class="number">1</span></span><br><span class="line">    return nested</span><br><span class="line"></span><br><span class="line">F=tester(<span class="number">0</span>)</span><br><span class="line">F(&#x27;spam&#x27;)</span><br><span class="line">F(&#x27;ham&#x27;)</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">spam <span class="number">0</span></span><br><span class="line">ham <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><ol>
<li>nonlocal对象必须已经在一个嵌套的def作用域中被赋值过，否则会报错。(global则不需要预先对变量进行赋值。)</li>
</ol>
<p>报错代码如下：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">def tester(start):</span><br><span class="line">    def nested(<span class="keyword">label</span>):</span><br><span class="line">        nonlocal <span class="keyword">state</span>  <span class="comment"># 在nested外层函数，也就是tester函数中并没有对state变量进行赋值。</span></span><br><span class="line">        <span class="keyword">state</span> = <span class="number">1</span></span><br><span class="line">        print(<span class="keyword">label</span>,<span class="keyword">state</span>) </span><br><span class="line">        <span class="keyword">state</span> += <span class="number">1</span></span><br><span class="line">    return nested</span><br><span class="line"></span><br><span class="line">F=tester(<span class="number">0</span>)</span><br><span class="line">F(&#x27;spam&#x27;)</span><br><span class="line">F(&#x27;ham&#x27;) </span><br></pre></td></tr></table></figure>
<p><strong>因为在state被nonlocal处理之前并没有对state进行赋值！</strong></p>
<ol start="2">
<li><p>nonlocal只会在嵌套def的作用域内查找，查找范围永远不会出def作用域范围，即便在最外层全局有了定义这个变量，也不会去查找。如果要去全局变量查询，则使用global。</p>
</li>
<li><p>nonlocal查询会<code>逐级往上</code>查询，查询到一个<code>立马返回</code>,也就是会<strong>就近查询</strong>。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">state</span> = <span class="number">0</span></span><br><span class="line">def tester(start):</span><br><span class="line">    <span class="keyword">state</span> = <span class="number">1</span></span><br><span class="line">    def cisco(middle):</span><br><span class="line">        <span class="keyword">state</span> = <span class="number">2</span></span><br><span class="line">        def nested(<span class="keyword">label</span>):</span><br><span class="line">            nonlocal <span class="keyword">state</span></span><br><span class="line">            print(<span class="keyword">label</span>, <span class="keyword">state</span>)</span><br><span class="line">        return nested</span><br><span class="line">    return cisco</span><br><span class="line"></span><br><span class="line">F=tester(<span class="number">0</span>)</span><br><span class="line">F(<span class="number">1</span>)(&#x27;spam&#x27;)</span><br><span class="line"></span><br><span class="line">输出结果为</span><br><span class="line">spam <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>因为在cisco这个函数中已经存在了state=2的赋值，所以不会再查询cisco上一层tester中的state。<strong>就近返回了state=2。</strong></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>position属性relative和absolute</title>
    <url>/2019/03/06/position%E5%B1%9E%E6%80%A7relative%E5%92%8Cabsolute/</url>
    <content><![CDATA[<p>我还记得那个调整了3个多小时才把确认按钮移动到table右边的夜晚。以至于前端给我的错觉就是，我写出我的思路，但它却不这么去展现。。mmp..<br>至此拾起来，从把relative和absolute两个属性搞清楚开始。</p>
<a id="more"></a>

<h2 id="非嵌套在标签的情形"><a href="#非嵌套在标签的情形" class="headerlink" title="非嵌套在标签的情形"></a>非嵌套在标签的情形</h2><p>初始代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">title</span>&gt;<span class="selector-tag">Title</span>&lt;/<span class="selector-tag">title</span>&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;position.css&quot;&gt;</span><br><span class="line">&lt;/<span class="selector-tag">head</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;div class=&quot;first&quot;&gt;class first&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;second&quot;&gt;class second&lt;/div&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.first</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#5060ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.second</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff7276</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个div挨在一起。<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tcqq5yyej20la0j0aam.jpg"></p>
<ul>
<li>relative</li>
</ul>
<p><strong>添加position:relative等属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#5060ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>蓝色背景的div根据top和left参数，位置上发生了改变。而红色div位置没有改变。<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tctv6lmzj20g00iy3yr.jpg"></p>
<ul>
<li>absolute</li>
</ul>
<p><strong>添加position:absolute等属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#5060ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>蓝色背景div根据top和left参数，位置上发生了改变，并且红色的div位置也发生了改变，和页面的顶部左边靠紧。<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0td19sj58j20fm0dkaaf.jpg"></p>
<h2 id="嵌套在标签的情形"><a href="#嵌套在标签的情形" class="headerlink" title="嵌套在标签的情形"></a>嵌套在标签的情形</h2><p>初始代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;position.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;third&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.first&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: #5060ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.second&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: #ff7276;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.third&#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: #ffe43e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个方块重叠在一起<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0td9z1ae5j20do0dcwel.jpg"></p>
<ul>
<li>relative</li>
</ul>
<p><strong>给third添加relative等属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.third</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe43e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>黄色背景div基于原来位置根据top和left参数，位置上发生了改变。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tdblwdp4j20dq0dy74a.jpg"></p>
<p><strong>再给second添加属性，去掉之前third的属性</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.second</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff7276</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.third</span>&#123;</span><br><span class="line">&lt;!--     <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">70px</span>;</span><br><span class="line"> --&gt;    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe43e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>黄色背景div跟随红色背景div移动。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tdpkuy6uj20ds0dkt8p.jpg"></p>
<p><strong>恢复third的属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.second</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff7276</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.third</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe43e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>黄色背景div在基于原来位置的基础上根据top和left参数，发生了改变。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tdgy62lej20do0du0sq.jpg"></p>
<ul>
<li>absolute</li>
</ul>
<p><strong>给third添加absolute等属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.third</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe43e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>黄色背景div根据top和left参数，发生了变化。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tdvj48azj20dq0deaa2.jpg"></p>
<p><strong>再给second添加属性</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff7276</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.third</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe43e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>黄色背景div依据红色背景div再根据top和left参数，发生了变化。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0tdwx0ux4j20d00dojrd.jpg"></p>
<p><strong>去除second的属性，给first添加属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.first</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#5060ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.second</span>&#123;</span><br><span class="line">    <span class="comment">/*position: relative;*/</span></span><br><span class="line">    <span class="comment">/*top: 30px;*/</span></span><br><span class="line">    <span class="comment">/*left: 30px;*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff7276</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.third</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe43e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>黄色背景div依据蓝色背景div再根据top和left参数，发生了变化。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1g0te1vr00wj20hu0hyq30.jpg"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>absolute</li>
</ul>
<ol>
<li>脱离原来的位置(<strong>因为脱离原来的位置，所以其他元素可能会对原有位置进行占用</strong>)进行移动定位。</li>
<li>如果最近有父级，则根据父级定位，如果没有，则根据文档定位(因为body是最大的父级)</li>
</ol>
<ul>
<li>relative</li>
</ul>
<ol>
<li>保留原来的位置，进行移动定位。</li>
<li>即便存在父级，也是相对(父级元素位置变动，相对位置也会变动)原来的位置进行移动定位。</li>
</ol>
<h2 id="absolute和relative配合"><a href="#absolute和relative配合" class="headerlink" title="absolute和relative配合"></a>absolute和relative配合</h2><ol>
<li>一般父级用relative做架子参照物，子级用absolute进行定位。</li>
</ol>
<h2 id="static和fixed"><a href="#static和fixed" class="headerlink" title="static和fixed"></a>static和fixed</h2><ol>
<li>static定位为默认情况，不会参照任何元素进行定位，按照浏览器预设的配置自动排版在页面上。</li>
<li>fixed相对浏览器视窗定位，一直固定一个相同的位置，不会受到浏览器滚动条的影响。</li>
</ol>
<p>refer</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/f946aca4d6b0">https://www.jianshu.com/p/f946aca4d6b0</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus曲线救国添加hostname</title>
    <url>/2019/03/07/prometheus%E6%B7%BB%E5%8A%A0hostname/</url>
    <content><![CDATA[<h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><ol>
<li>prometheus scrape_configs采用的是file_sd_configs，通过这种方式获取到的node_exporter的metric，元数据不存在hostname信息。</li>
<li>只看ip，无法知道该机器的用户。</li>
<li>grafana展现的时候，能根据hostname进行选择，展现机器数据。</li>
</ol>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>node_exporter中启用textfile采集的方式。</li>
<li>在textfile目录下，写入hostname。</li>
<li>通过表达式获取hostname。</li>
</ol>
<h2 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h2><ol>
<li>如何做到hostname的更变。</li>
<li>表达式hostname只和写入的metric有关，如何关联到不存在hostname的metric中。</li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>针对hostname的更变，让node_exporter启动的时候就进行自动读取当前hostname，并且写入。如果是配合supervisord或者systemd，则很好实现，比如用systemd守护的方式的时候，可以启用<code>ExecStartPre</code>方法，启动之前执行命令。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ExecStartPre=/opt/scripts/gethostname.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/scripts/gethostname.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo -e &quot;# HELP hardware_status check hardware status.\n# TYPE machine_role gauge\nmachine_role&#123;role=\&quot;`/usr/bin/hostname`\&quot;&#125; 0&quot; &gt; /app/local/node_exporter/collect/hostname.prom</span><br><span class="line">echo 1 &gt; /dev/null</span><br></pre></td></tr></table></figure></li>
<li>让不存在metric的hostname关联，则需要一个共同的<strong>连接点</strong>，类似sql中的两表查询。<br>先看hostname的metric<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># HELP machine_role Metric <span class="keyword">read</span> <span class="keyword">from</span> <span class="regexp">/app/</span>local<span class="regexp">/node_exporter/</span><span class="keyword">collect</span>/hostname.prom</span><br><span class="line"># TYPE machine_role gauge</span><br><span class="line">machine_role&#123;role=<span class="string">&quot;postfix01&quot;</span>&#125; <span class="number">0</span></span><br></pre></td></tr></table></figure>
其label是role，value是postfix01，也就是hostname</li>
</ol>
<p>prometheus中执行执行<code>machine_role</code>,可以得到element为：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">machine_role</span>&#123;instance=<span class="string">&quot;10.1.11.1:9100&quot;</span>,<span class="built_in">ip</span>=<span class="string">&quot;10.1.11.1&quot;</span>,job=<span class="string">&quot;L3&quot;</span>,role=<span class="string">&quot;ShangHai-SJ-L3-LC-Flume-01&quot;</span>,service=<span class="string">&quot;L3&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这边有role和instance这个两个label，其中role为hostname的label，而instance则作为连接点的label。</p>
<p>在grafana中的变量配置中就可以根据machine_role，先获取role，作为$hostname的值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">label<span class="constructor">_values(<span class="params">machine_role</span>&#123;<span class="params">service</span>=<span class="string">&quot;$job&quot;</span>&#125;,<span class="params">role</span>)</span></span><br></pre></td></tr></table></figure>
<p>然后再根据$hostname，来获取instance,作为$node的值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">label<span class="constructor">_values(<span class="params">machine_role</span>&#123;<span class="params">role</span>=<span class="string">&quot;$hostname&quot;</span>&#125;,<span class="params">instance</span>)</span></span><br></pre></td></tr></table></figure>
<p>此时对grafana的表达式就可以使用$node值了，比如如下表达式，虽然node_cpu_seconds_total方法里面是不存在hostname的，但因为曲线救国的方式，通过$hostname取得$node，然后传入node_cpu_seconds_total方法中，则可以出现数据了。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">count</span>(<span class="keyword">count</span>(node_cpu_seconds_total&#123;instance=~<span class="string">&quot;$node&quot;</span>, mode=<span class="string">&#x27;system&#x27;</span>&#125;) <span class="keyword">by</span> (cpu))</span><br></pre></td></tr></table></figure>
<h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><ul>
<li><p>先获取hostname。<br><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g0udfxseayj20k20hzq3x.jpg"></p>
</li>
<li><p>再根据hostname获取node。隐藏了label，这个无所谓是否隐藏，我只是想知道具体ip是什么。<br><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g0udggcklej20j50eymxx.jpg"></p>
</li>
<li><p>下拉通过hostname就可以选择机器了。<br><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g0udhov6xnj20t00jn401.jpg"></p>
</li>
</ul>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><ul>
<li>如果是通过dns方式发现，则是可以把hostname变成元label的。</li>
<li>通过consul发现，则可以在consul客户端上报hostname，也可以把hostname变成元label。</li>
</ul>
<h2 id="待解决问题第二点解决方法"><a href="#待解决问题第二点解决方法" class="headerlink" title="待解决问题第二点解决方法"></a>待解决问题第二点解决方法</h2><p><strong>promSQL可以使用on ignore group_left group_right配合来把hostname拼凑进去。</strong></p>
<p>machine_role查询得到的结果:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">machine_role</span>&#123;instance=<span class="string">&quot;10.1.11.1:9100&quot;</span>,ip=<span class="string">&quot;10.1.11.1&quot;</span>,job=<span class="string">&quot;L3&quot;</span>,role=<span class="string">&quot;zabbix&quot;</span>,service=<span class="string">&quot;L3&quot;</span>&#125;  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>up查询得到的结果:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">up</span>&#123;instance=<span class="string">&quot;10.1.11.1:9100&quot;</span>,<span class="built_in">ip</span>=<span class="string">&quot;10.1.11.1&quot;</span>,job=<span class="string">&quot;L3&quot;</span>,service=<span class="string">&quot;L3&quot;</span>&#125;  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>machine_role里面的role标签包含了主机名，但up没有，此时通过将两个方法结合在一起。<br>使用on方法，<em>可以理解为mysql的两表查询join</em> 两者的有共同的instance,job,service,ip标签</p>
<p>不一定要全部都选择，但选择的多则相互匹配更加精确，<code>on(instance,job,service,ip)</code></p>
<p>使用group_left或者group_right标记”多”的标签,这边多出来的标签是role，所以为<code>group_left(role)</code></p>
<p>表达式架构为:</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="variable">&lt;vector expr&gt;</span> <span class="variable">&lt;bin-op&gt;</span> <span class="keyword">on</span>(<span class="variable">&lt;label list&gt;</span>) group_left(<span class="variable">&lt;label list&gt;</span>) <span class="variable">&lt;vector expr&gt;</span></span><br></pre></td></tr></table></figure>
<p><bin-op>指加减乘除余幂</p>
<p>所以将up和machine_role拼凑和可以写为</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">up + <span class="keyword">on</span><span class="params">(instance, job,ip,service)</span> group_left(role) machine_role</span><br><span class="line">&#123;instance=<span class="string">&quot;10.1.11.1:9100&quot;</span>,ip=<span class="string">&quot;10.1.11.1&quot;</span>,job=<span class="string">&quot;L3&quot;</span>,role=<span class="string">&quot;zabbix&quot;</span>,service=<span class="string">&quot;L3&quot;</span>&#125;  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果用group_right，则把up和machine_role反一下即可</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">machine_role + <span class="keyword">on</span><span class="params">(instance, job,ip,service)</span> group_right(role) up </span><br></pre></td></tr></table></figure>
<p>此时得到的结果包含了role，如果作为告警，由于up为1表示正常，machine_role设置的是0，两者相加，若为0，则表示机器down。<br>告警表达式可以写成:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">up + <span class="keyword">on</span><span class="params">(instance, job,ip,service)</span> group_left(role) machine_role == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>此时如果告警，则会包含role这个标签，就可以传递给alertmanager，获取到role了。</p>
<p>refer</p>
<blockquote>
<p><a href="https://www.robustperception.io/how-to-have-labels-for-machine-roles">https://www.robustperception.io/how-to-have-labels-for-machine-roles</a><br><a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-operators-v2">https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-operators-v2</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>python增删可迭代对象</title>
    <url>/2019/03/08/python%E5%A2%9E%E5%88%A0%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul>
<li>直接迭代对象删除列表中所有的数字4。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        w.remove(i)</span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>输出结果中，并没有删除所有的数字4。</p>
<ul>
<li>使用len()方式删除列表中所有的数字4。</li>
</ul>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">w = [1,2,3,4,4,5,6]</span><br><span class="line">for i <span class="meta">in</span><span class="meta"> range(</span>l<span class="meta">en(</span>w)):</span><br><span class="line">    <span class="meta">if</span> w[i] == 4:</span><br><span class="line">        w.<span class="meta">remove</span>(w[i])</span><br><span class="line">p<span class="meta">rint(</span>w)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IndexError: <span class="meta">list</span> <span class="meta">index</span> <span class="meta">out</span> of range</span><br></pre></td></tr></table></figure>
<p>出现<code>IndexError</code>错误。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ul>
<li><p>第一种是因为数组长度变小，迭代时候，指向出现了偏差，使用调试模式就能发现，当删除第一个”4”后，指针指向了第二个4，然后从第二个4开始迭代，此时跳过了第二个4的存在。</p>
</li>
<li><p>第二种是因为数组长度变小了，但len()记录的长度没变，所以导致了后面迭代的时候out of index。</p>
</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>如果能保证迭代的时候的对象不会因为原对象的改变而改变，就可以解决，也就是说对原对象进行copy，而不是引用。</strong></p>
<p>列举两种处理方法：</p>
<ol>
<li>使用[:]的方式<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">w = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> w[:]:</span><br><span class="line">    <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">4</span>:</span><br><span class="line">        w.remove(i)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(w)</span></span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li>
<li>使用deepcopy的方式<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">w = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> copy.deepcopy(w):</span><br><span class="line">    <span class="keyword">if</span> <span class="selector-tag">i</span> == <span class="number">4</span>:</span><br><span class="line">        w.remove(i)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(w)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>sed的一些操作</title>
    <url>/2019/02/27/sed%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="原始文件redis-conf内容："><a href="#原始文件redis-conf内容：" class="headerlink" title="原始文件redis.conf内容："></a>原始文件redis.conf内容：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    host =&gt; &quot;127.0.0.1:6379&quot;</span><br><span class="line">    key =&gt; &quot;logstash:demo&quot;</span><br><span class="line">    data_type =&gt; &quot;list&quot;</span><br><span class="line">    codec =&gt; &quot;json&quot;</span><br><span class="line">    type =&gt; &quot;logstash-redis-demo&quot;</span><br><span class="line">    tags =&gt; [&quot;logstashdemo&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    host =&gt; &quot;127.0.0.1:9200&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="获取sed匹配内容的下一行"><a href="#获取sed匹配内容的下一行" class="headerlink" title="获取sed匹配内容的下一行"></a>获取sed匹配内容的下一行</h2><p>原始文件redis.conf内容:</p>
<ul>
<li><p>思路：<br>若要只抓取<code>tags =&gt; [&quot;logstashdemo&quot;]</code>内容，则需要匹配<code>type =&gt; &quot;logstash-redis-demo&quot;</code>这一行内容。</p>
</li>
<li><p>sed匹配内容下一行写法:<br><code>sed -n &#39;/matchString/&#123;n;p&#125;&#39; filename</code></p>
</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[root@leanote ~]</span><span class="comment"># sed -n &#x27;/logstash-redis-demo/&#123;n;p&#125;&#x27; redis.conf </span></span><br><span class="line">    <span class="attr">tags</span> =&gt; [<span class="string">&quot;logstashdemo&quot;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="替换sed匹配行内容的下一行的指定内容"><a href="#替换sed匹配行内容的下一行的指定内容" class="headerlink" title="替换sed匹配行内容的下一行的指定内容"></a>替换sed匹配行内容的下一行的指定内容</h2><ul>
<li><p>思路：<br>先匹配到<code>tags =&gt; [&quot;logstashdemo&quot;]</code>内容，然后对该内容下一行内容<code>tags =&gt; [&quot;logstashdemo&quot;]</code>的<code>logstashdemo</code>改为<code>replacedemo</code></p>
</li>
<li><p>sed替换匹配行下一行内容写法:<br><code>sed -i &#39;/查询匹配的内容/&#123;n;s/下一行内要被替换的内容/替换内容/;&#125;&#39; filename</code></p>
</li>
</ul>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]<span class="comment"># sed -i &#x27;/logstash-redis-demo/&#123;n;s/logstashdemo/replacedemo/;&#125;&#x27; redis.conf </span></span><br><span class="line">[root@leanote ~]<span class="comment"># cat redis.conf </span></span><br><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1:6379&quot;</span></span><br><span class="line">    <span class="attr">key</span> =&gt; <span class="string">&quot;logstash:demo&quot;</span></span><br><span class="line">    <span class="attr">data_type</span> =&gt; <span class="string">&quot;list&quot;</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">&quot;json&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;logstash-redis-demo&quot;</span></span><br><span class="line">    <span class="attr">tags</span> =&gt; [<span class="string">&quot;replacedemo&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1:9200&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sed内容存在变量情况"><a href="#sed内容存在变量情况" class="headerlink" title="sed内容存在变量情况"></a>sed内容存在变量情况</h2><ul>
<li>方法一，将外部单引号用双引号替代<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]<span class="comment"># echo $beitihuan</span></span><br><span class="line">list</span><br><span class="line">[root@leanote ~]<span class="comment"># echo $tihuan   </span></span><br><span class="line">str</span><br><span class="line">[root@leanote ~]<span class="comment"># sed -e &quot;/key/&#123;n;s/$&#123;beitihuan&#125;/$&#123;tihuan&#125;/;&#125;&quot; redis.conf </span></span><br><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1:6379&quot;</span></span><br><span class="line">    <span class="attr">key</span> =&gt; <span class="string">&quot;logstash:demo&quot;</span></span><br><span class="line">    <span class="attr">data_type</span> =&gt; <span class="string">&quot;str&quot;</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">&quot;json&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;logstash-redis-demo&quot;</span></span><br><span class="line">    <span class="attr">tags</span> =&gt; [<span class="string">&quot;replacedemo&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1:9200&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二，不修改外部单引号，将变量用单引号引起来<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]<span class="comment"># sed -e &#x27;/key/&#123;n;s/&#x27;$&#123;beitihuan&#125;&#x27;/&#x27;$&#123;tihuan&#125;&#x27;/;&#125;&#x27; redis.conf </span></span><br><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1:6379&quot;</span></span><br><span class="line">    <span class="attr">key</span> =&gt; <span class="string">&quot;logstash:demo&quot;</span></span><br><span class="line">    <span class="attr">data_type</span> =&gt; <span class="string">&quot;str&quot;</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; <span class="string">&quot;json&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;logstash-redis-demo&quot;</span></span><br><span class="line">    <span class="attr">tags</span> =&gt; [<span class="string">&quot;replacedemo&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1:9200&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意点</li>
<li>*如果变量存在特殊符号，比如<code>/</code>，那么此时这个符号会影响sed的分隔符，需要将sed分隔符替换成其他的。**</li>
</ul>
<h2 id="sed对软连文件进行操作"><a href="#sed对软连文件进行操作" class="headerlink" title="sed对软连文件进行操作"></a>sed对软连文件进行操作</h2><p><strong>sed对<code>软连文件</code>进行操作，倘若不指定<code>--follow-symlinks</code>，则软连文件和原始文件会被拆分,原始文件不会被修改，而软连的文件会被修改，且变成一个独立文件。</strong></p>
<p>sed操作没有指定<code>--follow-symlinks</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[root@leanote <span class="keyword">conf</span>]# <span class="keyword">ll</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">16</span> Feb <span class="number">27</span> <span class="number">10</span>:<span class="number">58</span> redis.<span class="keyword">conf</span> -&gt; /root/redis.<span class="keyword">conf</span></span><br><span class="line">[root@leanote <span class="keyword">conf</span>]# sed -i <span class="string">&#x27;/key/&#123;n;s/&#x27;</span>$&#123;beitihuan&#125;<span class="string">&#x27;/&#x27;</span>$&#123;tihuan&#125;<span class="string">&#x27;/;&#125;&#x27;</span> redis.<span class="keyword">conf</span> </span><br><span class="line">[root@leanote <span class="keyword">conf</span>]# <span class="keyword">ll</span></span><br><span class="line">total <span class="number">4</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">248</span> Feb <span class="number">27</span> <span class="number">11</span>:<span class="number">00</span> redis.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>sed操作指定<code>--follow-symlinks</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[root@leanote <span class="keyword">conf</span>]# sed -i --follow-symlinks <span class="string">&#x27;/key/&#123;n;s/&#x27;</span>$&#123;beitihuan&#125;<span class="string">&#x27;/&#x27;</span>$&#123;tihuan&#125;<span class="string">&#x27;/;&#125;&#x27;</span> redis.<span class="keyword">conf</span></span><br><span class="line">[root@leanote <span class="keyword">conf</span>]# <span class="keyword">ll</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">16</span> Feb <span class="number">27</span> <span class="number">11</span>:<span class="number">02</span> redis.<span class="keyword">conf</span> -&gt; /root/redis.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>setdefault方法传入函数</title>
    <url>/2019/02/01/setdefault%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault()方法"></a>setdefault()方法</h2><p>myvalue = dict_a.setdefault(a,b)</p>
<p>从dict_a中获取a的值，如果没有，则新增一个value为b，key为a的键值对。</p>
<a id="more"></a>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>请求获取一个数值，如果字典中存在这个值，则从字典内获取，如果不存在，则从api函数调用。</p>
<p>于是用了setdefault()方法，代码大致如下:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">dict_a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="symbol">xxxx:</span></span><br><span class="line">    myvalue = dict_a.set<span class="function"><span class="keyword">def</span><span class="title">ault</span><span class="params">(a,func_api()</span></span>)</span><br><span class="line">    xxxxx</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure>
<p>因为func_api()函数会请求线上，调用接口。</p>
<p>但是实现的时候，却发现，每次对myvalue赋值的时候，都会调用线上api接口。</p>
<p>猜测setdefault的逻辑，即便能通过指定的key获取到value，其default行为还是被执行。</p>
<h2 id="验证猜测"><a href="#验证猜测" class="headerlink" title="验证猜测"></a>验证猜测</h2><p><strong>同时也验证了字典get方法</strong></p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="function"><span class="keyword">def</span> <span class="title">b</span>():</span></span></span><br><span class="line"><span class="meta">...</span> <span class="python">  print(<span class="number">2</span>)</span></span><br><span class="line"><span class="meta">...</span> <span class="python">  <span class="keyword">return</span> <span class="number">1</span></span></span><br><span class="line"><span class="meta">...</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a_dict = &#123;&#125;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a_dict=&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a_dict.setdefault(<span class="string">&quot;a&quot;</span>,b())</span></span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a_dict.get(<span class="string">&quot;a&quot;</span>,b())</span></span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>虽然a_dict字典已经存在”a”:1,但，依旧执行了b()</p>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>先进行get，若返回为None，则进行setdefault</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">groupid = groupid_templateid_dict.get(tmp_groupname)</span><br><span class="line"><span class="keyword">if</span> groupid:</span><br><span class="line">    pass</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    groupid = groupid_templateid_dict.setdefault(tmp_groupname,zhg.get<span class="constructor">_customer_hostgroups(<span class="params">name</span>=<span class="params">groupname</span>,<span class="params">output_data</span>=<span class="params">output_data</span>)</span>)</span><br></pre></td></tr></table></figure>

<p>这样就避免了重复调用func的问题。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>其实只要把函数作为另外一个函数的参数，那么当调用这个函数的的时候，被传入的函数也会调用。</strong></p>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>sort函数中key的理解</title>
    <url>/2018/12/29/sort%E5%87%BD%E6%95%B0%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">sort(...)</span><br><span class="line">    L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><em>python3中已经取消了sort()函数中cmp参数</em></p>
<p>python中sort()函数用来排序，其中有个key的参数，十分神奇。</p>
<p>我对key参数的理解是：<br><strong>这个key是构造了一个全新的对象，对这些全新的对象进行比较排序，然后再根据结果，对原先的对象进行排序。</strong></p>
<h2 id="字典value排序"><a href="#字典value排序" class="headerlink" title="字典value排序:"></a>字典value排序:</h2><p>比如很常用的，对一个字典进行value排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_value</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">sorted</span>(d.items(), key=sort_value))</span><br></pre></td></tr></table></figure>
<p><code>d.items</code>得到dict_items([(1, ‘c’), (2, ‘d’), (3, ‘b’), (4, ‘a’)])，其挨个传入到key对应的sort_value函数中，返回索引为1的值，也就是value的值，然后对这个新对象进行排序，最终以新对象排序的结果来输出d.items()的排序。</p>
<p>将sort_value函数写成lambda则：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">print(<span class="name">sorted</span>(<span class="name">d</span>.items(), key=lambda x <span class="symbol">:x</span>[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="字符串内容重新排序"><a href="#字符串内容重新排序" class="headerlink" title="字符串内容重新排序:"></a>字符串内容重新排序:</h2><p>对字符串”hUangYisan6749”重新排序，要求:</p>
<ol>
<li>数字在最前面，偶数在奇数前面。</li>
<li>字符串在数字后面，大写字母在小写字母后面。</li>
</ol>
<p>思路：</p>
<ol>
<li>字符串挨个拆出来。</li>
<li>构造一个元组，能够符合上述需求，然后排序的。<strong>元组的排序是从首个元素逐一排序的，碰到首元素一样，则比第二个元素</strong></li>
</ol>
<p>先确定一个通用的元组，总共是四种类型，奇数偶数，大写小写。<br>例：偶数，奇数，大写，小写(1,0,0,0)，比如这样就表示该字符为偶数。</p>
<p><strong>由于默认sorted排序是从小到大，所以根据需求，得写成小写，大写，奇数，偶数的方式(或者加上reverse=True)</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">def</span> custom_order(x):</span><br><span class="line">    <span class="attribute">if</span> x.islower():</span><br><span class="line">        <span class="attribute">return</span> <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,x</span><br><span class="line">    <span class="attribute">if</span> x.isupper():</span><br><span class="line">        <span class="attribute">return</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,x</span><br><span class="line">    <span class="attribute">if</span> x.isdigit() and int(x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="attribute">return</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,x</span><br><span class="line">    <span class="attribute">else</span>:</span><br><span class="line">        <span class="attribute">return</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,x</span><br></pre></td></tr></table></figure>
<p>当对比相同的时候，会索引+1比较，所以return不能漏掉x，因为当前面四位全部相等的时候，要比较x。</p>
<p>那么代码可以写成：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mystring</span> = <span class="string">&quot;hUangYisan6749&quot;</span></span><br><span class="line"><span class="attribute">def</span> custom_order(x):</span><br><span class="line">    <span class="attribute">if</span> x.islower():</span><br><span class="line">        <span class="attribute">return</span> <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,x</span><br><span class="line">    <span class="attribute">if</span> x.isupper():</span><br><span class="line">        <span class="attribute">return</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,x</span><br><span class="line">    <span class="attribute">if</span> x.isdigit() and int(x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="attribute">return</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,x</span><br><span class="line">    <span class="attribute">else</span>:</span><br><span class="line">        <span class="attribute">return</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,x</span><br><span class="line"></span><br><span class="line"><span class="attribute">print</span>(<span class="string">&quot;&quot;</span>.join(sorted(mystring,key=custom_order)))</span><br><span class="line"></span><br><span class="line"><span class="attribute">7946UYaaghinns</span></span><br></pre></td></tr></table></figure>
<p>refer:</p>
<blockquote>
<p><a href="http://python.jobbole.com/85025/">http://python.jobbole.com/85025/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>split函数</title>
    <url>/2018/12/29/split%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="一道领扣的题"><a href="#一道领扣的题" class="headerlink" title="一道领扣的题"></a>一道领扣的题</h2><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。<br>如果不存在最后一个单词，请返回 0 。<br>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p>示例:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: &quot;Hello World&quot;</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>写出的其中一种答案是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        slist = s.split()</span><br><span class="line">        print(slist)</span><br><span class="line">        <span class="keyword">if</span> slist == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(slist[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="split-“-“-和-split"><a href="#split-“-“-和-split" class="headerlink" title="split(“ “) 和 split()"></a>split(“ “) 和 split()</h2><p>起先我认为split(“ “)和split()的作用是一样的，都是以空格进行分割。<br>以至于一开始做上面领扣的题一直都有问题。</p>
<p>然后手工验证了下两者的情况：</p>
<ul>
<li>split(“ “)的情况<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">&quot; a   &quot;</span>.<span class="keyword">split</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li>split()的情况<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot; <span class="selector-tag">a</span>   &quot;<span class="selector-class">.split</span>()</span><br><span class="line"><span class="selector-attr">[<span class="string">&#x27;a&#x27;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>查了下split()的用法<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">S.<span class="built_in">split</span>([sep [,maxsplit]]) -&gt; list <span class="keyword">of</span> strings</span><br><span class="line"></span><br><span class="line">Return <span class="keyword">a</span> list <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">words</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">string</span> S, <span class="keyword">using</span> sep <span class="keyword">as</span> <span class="keyword">the</span> delimiter <span class="keyword">string</span>. If maxsplit is given, <span class="keyword">at</span> most maxsplit splits are done. If sep is <span class="keyword">not</span> specified <span class="keyword">or</span> is None, <span class="keyword">any</span> whitespace <span class="keyword">string</span> is <span class="keyword">a</span> separator <span class="keyword">and</span> <span class="literal">empty</span> strings are removed <span class="built_in">from</span> <span class="keyword">the</span> <span class="built_in">result</span>.</span><br></pre></td></tr></table></figure></li>
<li>*也就是说，如果sep不填写，那么split()执行两个行为：**</li>
</ul>
<ol>
<li>以任何whitespace字符串作为分隔符。</li>
<li>除所有的empty string。</li>
</ol>
<p>empty string就是<code>not xxx</code>返回结果为False的字符串,包括””。</p>
<p>refer:</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/length-of-last-word/">https://leetcode-cn.com/problems/length-of-last-word/</a><br>help(str.split)</p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>wrk的使用</title>
    <url>/2021/06/10/wrk%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><ol>
<li>github项目地址： <a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a></li>
<li>可以配合lua脚本使用</li>
</ol>
<a id="more"></a>

<h3 id="wrk参数"><a href="#wrk参数" class="headerlink" title="wrk参数"></a>wrk参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of test           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file       </span><br><span class="line">    -H, --header      &lt;H&gt;  Add header to request      </span><br><span class="line">        --latency          Print latency statistics   </span><br><span class="line">        --timeout     &lt;T&gt;  Socket/request timeout     </span><br><span class="line">    -v, --version          Print version details      </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>-c 表示并发连接数</p>
</li>
<li><p>-d 持续时间，如果不填写，默认为10s</p>
</li>
<li><p>-t 线程数</p>
</li>
<li><p>-s 指定lua脚本</p>
</li>
<li><p>-H 指定请求头</p>
</li>
<li><p>–latency 最终输出阶段打印出latency信息</p>
</li>
<li><p>–timeout 设置超时时间</p>
</li>
<li><p>-v 查看工具版本</p>
</li>
</ul>
<h3 id="wrk压测样例"><a href="#wrk压测样例" class="headerlink" title="wrk压测样例"></a>wrk压测样例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan@k3s-master:~/learn-lua/wrk$ wrk -t1 -c3 -d1s --timeout 1s --latency https://www.baidu.com</span><br><span class="line">1 Running 1s test @ https://www.baidu.com</span><br><span class="line">2  1 threads and 3 connections</span><br><span class="line">3  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">4    Latency    97.57ms   33.94ms 183.80ms   76.00%</span><br><span class="line">5    Req/Sec    27.75      8.01    40.00     75.00%</span><br><span class="line">6  Latency Distribution</span><br><span class="line">7     50%   81.64ms</span><br><span class="line">8     75%  106.93ms</span><br><span class="line">9     90%  153.27ms</span><br><span class="line">10     99%  183.80ms</span><br><span class="line">11  25 requests in 1.01s, 414.54KB read</span><br><span class="line">12 Requests/sec:     24.85</span><br><span class="line">13 Transfer/sec:    412.03KB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出解释：</p>
<ul>
<li>第一行： 表示请求<a href="https://www.baidu.com/">https://www.baidu.com</a> 持续1s</li>
<li>第二行： 表示1个线程3个并发连接数</li>
<li>第三行：<ul>
<li>Thread Stats：表示类型字段</li>
<li>Avg：单个线程的平均值</li>
<li>Stdev：单个线程标准偏差</li>
<li>Max：单个线程最大值</li>
<li>+/- Stdev：标准偏差以百分数形式表示</li>
</ul>
</li>
<li>第四行：表示请求延迟，越小越好</li>
<li>第五行：表示每秒请求数，越大越好</li>
<li>第六行：唯有在命令行加上–latency 参数才有</li>
<li>第七行至第十行：表示了延迟数据分布，50%的请求在81.64ms中完成，这里面包含了<strong>Coordinated Omission</strong>修正，所以延迟会比服务端打点来的大，因为其包含了用户请求发送的等待时间，具体可以参考:<a href="https://github.com/giltene/wrk2">https://github.com/giltene/wrk2</a> <a href="https://zhuanlan.zhihu.com/p/43602062">https://zhuanlan.zhihu.com/p/43602062</a></li>
<li>第十一行：表示了在固定的1s内完成了25个请求，数据读取414.54KB</li>
<li>第十二行：表示所有请求的均值每秒数据，<strong>这是一个重要的指标</strong>。req/sec和request/sec的差别<a href="https://github.com/wg/wrk/issues/259">https://github.com/wg/wrk/issues/259</a></li>
<li>第十三行：每秒传输的数据量</li>
</ul>
<h3 id="wrk跟lua脚本配合使用"><a href="#wrk跟lua脚本配合使用" class="headerlink" title="wrk跟lua脚本配合使用"></a>wrk跟lua脚本配合使用</h3><ol>
<li>引入lua脚本，可以使压测的行为更加复杂，比如给每个线程创建不同的body，进行压测。</li>
<li>通过-s可以指定传入的脚本名称。</li>
</ol>
<h3 id="lua脚本中可以获取到wrk的变量"><a href="#lua脚本中可以获取到wrk的变量" class="headerlink" title="lua脚本中可以获取到wrk的变量"></a>lua脚本中可以获取到wrk的变量</h3><ol>
<li>scheme </li>
<li>host</li>
<li>port</li>
<li>method</li>
<li>path</li>
<li>headers</li>
<li>body</li>
<li>thread</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span><span class="params">(thread)</span></span></span><br><span class="line">    <span class="built_in">print</span>(thread.method)</span><br><span class="line">    <span class="built_in">print</span>(wrk.scheme)</span><br><span class="line">    <span class="built_in">print</span>(wrk.method)</span><br><span class="line">    <span class="built_in">print</span>(wrk.host)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;path&quot;</span>, wrk.<span class="built_in">path</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;headers&quot;</span>, #wrk.headers)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;body&quot;</span>, wrk.body)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="wrk运行阶段"><a href="#wrk运行阶段" class="headerlink" title="wrk运行阶段"></a>wrk运行阶段</h4><p>wrk的运行可以分为三个阶段，在这三个阶段可以通过lua编写对应的方法，来达到”嵌入”行为的目的。</p>
<ol>
<li><p><strong>Step阶段</strong>，该阶段解析了被压测的地址，并且初始化好了所有的线程，处于等待开始阶段，所以这个阶段编写的脚本的执行开销，其实是不会算入结论输出里面的。在lua脚本定义<strong>setup</strong>函数，传入<code>thread</code>参数。</p>
<p> thread也有自己的一些属性和方法</p>
<ul>
<li>thread.addr，获取当前thread访问的地址，以ip:port的形式</li>
<li>thread:set(key, value)，在线程里面设定key,value</li>
<li>thread:get(key)，指定key获取thread环境里的对应的value</li>
<li>thread:stop()，暂停thread</li>
</ul>
</li>
</ol>
<pre><code><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span><span class="params">(thread)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></code></pre>
<ol start="2">
<li><p><strong>Running阶段</strong>，该阶段又可以细分为四个阶段。</p>
<ul>
<li><p><strong>init阶段</strong>，该阶段可以接受wrk命令传入的额外参数，只需要将额外参数跟随在最末尾，空格分隔即可。在lua脚本定义<strong>init</strong>函数，传入args参数，<strong>当有额外参数传入的时候，args为一个table</strong>，可以使用pairs迭代获取其value。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(args)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">print</span>(i,v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>指定脚本后传入参数打印能看到如下输出,index为0的是压测地址，1为bb，2为cc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan@k3s-master:~/learn-lua/wrk$ wrk -t1 -c1 -d1s --timeout 1s -s init.lua  --latency https://www.baidu.com bb cc</span><br><span class="line">0	https://www.baidu.com</span><br><span class="line">1	bb</span><br><span class="line">2	cc</span><br><span class="line">Running 1s test @ https://www.baidu.com</span><br><span class="line">  1 threads and 1 connections</span><br><span class="line">  .....</span><br><span class="line">  ....</span><br><span class="line">  ...</span><br><span class="line">  ..</span><br><span class="line">  .</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>delay阶段</strong>,该阶段表示两次请求延迟间隔，函数返回一个毫秒为单位的数字。在lua脚本定义<strong>delay</strong>函数，返回数字，该数字单位为<strong>毫秒</strong>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>脚本表示延迟间隔为200ms,当指定延迟脚本和不指定延迟脚本得到的结果很明显，指定了延迟脚本的结果<strong>Requests/sec</strong>明显下降了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan@k3s-master:~/learn-lua/wrk$ wrk -t1 -c2 -d2s  https://www.baidu.com </span><br><span class="line">Running 2s test @ https://www.baidu.com</span><br><span class="line">  1 threads and 2 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    85.89ms   25.21ms 185.38ms   77.78%</span><br><span class="line">    Req/Sec    23.17      7.68    40.00     83.33%</span><br><span class="line">  44 requests in 2.01s, 673.82KB read</span><br><span class="line">Requests/sec:     21.91</span><br><span class="line">Transfer/sec:    335.56KB</span><br><span class="line"></span><br><span class="line">huangyisan@k3s-master:~/learn-lua/wrk$ wrk -t1 -c2 -d2s -s delay.lua https://www.baidu.com </span><br><span class="line">Running 2s test @ https://www.baidu.com</span><br><span class="line">  1 threads and 2 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    53.43ms    8.35ms  81.61ms   92.86%</span><br><span class="line">    Req/Sec     7.00      2.33    10.00     62.50%</span><br><span class="line">  14 requests in 2.01s, 214.40KB read</span><br><span class="line">Requests/sec:      6.96</span><br><span class="line">Transfer/sec:    106.53KB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>request阶段</strong>，该阶段可以对请求进行构造，比如修改请求头，修改body等，最后需要返回<strong>wrk.format()**，建议将一些可以不在该阶段的修改代码放到init()方法里面，让request腾出更多的时间去完成压测请求。一个完整的wrk.format()函数传入的参数</strong>依次<strong>对应为<code>method, path, headers, body</code>。在lua脚本里面定义</strong>request**函数函数即可。如果在function里面并不是修改全局wrk的属性，则需要传入，否则可以不传入，比如下面wrk.method被修改了，则不需要传入，而path为函数内本地属性，需要传入。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">path</span> = <span class="string">&quot;/?x&quot;</span></span><br><span class="line">  wrk.method = <span class="string">&quot;POST&quot;</span></span><br><span class="line"><span class="keyword">return</span> wrk.<span class="built_in">format</span>(<span class="literal">nil</span>,<span class="built_in">path</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>response阶段</strong>，该阶段可以处理请求返回的status,headers,body。在lua脚本中定义<strong>response</strong>函数，传入的参数分别为<code>status,headers,body</code>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span><span class="params">(status,headers,body)</span></span></span><br><span class="line">  <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(headers)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">print</span>(v)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">status</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Done阶段</strong>，该阶段以table的形式接受结果，以及表示每个请求延迟和每线程请求率的两个统计对象，此时可以根据自己的算法需求来编写最后的输出结果。在lua脚本中定义<strong>done</strong>函数，传入参数分别为<code>summary, latency, requests</code>。</p>
<p>其对象有如下这些:</p>
</li>
</ol>
<ul>
<li><p>latency.min 最小值</p>
</li>
<li><p>latency.max 最大值</p>
</li>
<li><p>latency.mean 平均值</p>
</li>
<li><p>latency.stdev 标准偏差</p>
</li>
<li><p>latency:percentile(num) 指定数字百分比的数值</p>
</li>
<li><p>latency(i) : raw value and count</p>
<p>summary:</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">summary</span> = &#123;    </span><br><span class="line">    duration = N,  <span class="comment">-- run duration in microseconds    </span></span><br><span class="line">    requests = N,  <span class="comment">-- total completed requests    </span></span><br><span class="line">    bytes    = N,  <span class="comment">-- total bytes received    </span></span><br><span class="line">    errors   = &#123;      </span><br><span class="line">       <span class="keyword">connect</span> = N, <span class="comment">-- total socket connection errors      </span></span><br><span class="line">       <span class="keyword">read</span>    = N, <span class="comment">-- total socket read errors      </span></span><br><span class="line">       <span class="keyword">write</span>   = N, <span class="comment">-- total socket write errors      </span></span><br><span class="line">       status  = N, <span class="comment">-- total HTTP status codes &gt; 399      </span></span><br><span class="line">       timeout = N  <span class="comment">-- total request timeouts    </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义输出lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">done</span><span class="params">(summary, latency, requests)</span></span></span><br><span class="line">   <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;------------------------------\n&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> _, p <span class="keyword">in</span> <span class="built_in">pairs</span>(&#123; <span class="number">50</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">99.999</span> &#125;) <span class="keyword">do</span></span><br><span class="line">      n = latency:percentile(p)</span><br><span class="line">      <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%g%%,%dms\n&quot;</span>, p, n/<span class="number">1000</span>))</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;--------error requets count--------\n&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(summary[<span class="string">&quot;errors&quot;</span>][<span class="string">&quot;status&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">huangyisan@k3s-master:~/learn-lua/wrk$ wrk -t1 -c2 -d2s -s done.lua --latency https://www.baidu.com </span><br><span class="line">Running 2s test @ https://www.baidu.com</span><br><span class="line">  1 threads and 2 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency    86.47ms   17.21ms 130.38ms   79.07%</span><br><span class="line">    Req/Sec    22.26      8.53    40.00     78.95%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   86.63ms</span><br><span class="line">     75%   96.13ms</span><br><span class="line">     90%  101.42ms</span><br><span class="line">     99%  130.38ms</span><br><span class="line">  43 requests in 2.01s, 658.52KB read</span><br><span class="line">Requests/sec:     21.39</span><br><span class="line">Transfer/sec:    327.57KB</span><br><span class="line">------------------------------</span><br><span class="line"><span class="meta">50%</span><span class="bash">,86ms</span></span><br><span class="line"><span class="meta">90%</span><span class="bash">,101ms</span></span><br><span class="line"><span class="meta">99%</span><span class="bash">,130ms</span></span><br><span class="line">99.999%,130ms</span><br><span class="line">--------error requets count--------</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>自定义了输出，打印了<strong>50,  90,  90,  99.999</strong>百分比的标准偏差，同时打印了请求错误的数量。</p>
</li>
</ul>
<h3 id="wkr另外两个函数"><a href="#wkr另外两个函数" class="headerlink" title="wkr另外两个函数"></a>wkr另外两个函数</h3><p><code>function wrk.lookup(host, service) </code><br>返回主机地址和服务列表。</p>
<p><code>function wrk.connect(addr) </code><br>连接指定addr地址，如果能连接，则返回<code>true</code>，反之则<code>false</code>。</p>
<p>这两个函数并不在生命周期中，但可以在生命周期阶段被调用，例如:<a href="https://github.com/wg/wrk/blob/master/scripts/addr.lua">https://github.com/wg/wrk/blob/master/scripts/addr.lua</a></p>
<p>refer</p>
<blockquote>
<p><a href="https://medium.com/@felipedutratine/intelligent-benchmark-with-wrk-163986c1587f">https://medium.com/@felipedutratine/intelligent-benchmark-with-wrk-163986c1587f</a><br><a href="https://programmer.ink/think/quick-start-for-the-http-pressure-tool-wrk.html">https://programmer.ink/think/quick-start-for-the-http-pressure-tool-wrk.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树种类和遍历</title>
    <url>/2019/02/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A7%8D%E7%B1%BB%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h2><p><strong>二叉树种类定义没有一个标准化，所以不同文档可能有不同解释。</strong></p>
<ol>
<li>rooted binary tree</li>
</ol>
<ul>
<li>存在根节点，并且每个节点都有<strong>2个</strong>子节点。</li>
</ul>
<ol start="2">
<li>full binary tree</li>
</ol>
<ul>
<li>每个节点只有<strong>0个或者2个</strong>子节点。</li>
</ul>
<ol start="3">
<li>complete binary tree</li>
</ol>
<ul>
<li>除去最后一级，其他级都是full状态(0个或者2个子节点)，且最后一级的节点都在左侧子树上。</li>
</ul>
<ol start="4">
<li>perfect binary tree</li>
</ol>
<ul>
<li>内节点都有两个子节点，且所有子叶都处于同一级别。</li>
</ul>
<ol start="5">
<li>infinite complete binary tree</li>
</ol>
<ul>
<li>every node has two children (and so the set of levels is countably infinite). The set of all nodes is countably infinite, but the set of all infinite paths from the root is uncountable, having the cardinality of the continuum</li>
<li>我的理解就是无穷尽的rooted binray tree</li>
</ul>
<ol start="6">
<li>balanced binary tree</li>
</ol>
<ul>
<li>左右子树高度差不超过1</li>
<li>且左右子树各自均为平衡二叉树</li>
</ul>
<ol start="7">
<li>degenerate tree</li>
</ol>
<ul>
<li>每个节点只包含一个子节点。</li>
</ul>
<a id="more"></a>

<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="前序遍历-深度优先"><a href="#前序遍历-深度优先" class="headerlink" title="前序遍历(深度优先)"></a>前序遍历(深度优先)</h3><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g03qhndt0qj20m80izgn3.jpg" alt="preorder" width="200"/>
* 指先访问根，然后访问子树的遍历方式。
* 顺序 `F, B, A, D, C, E, G, I, H.`

<p>堆栈代码实现:</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">class BinTree(object):</span><br><span class="line">    def __init__(self,root):</span><br><span class="line">        <span class="comment"># 所有的点都是子节点，也是父节点的叶子。</span></span><br><span class="line">        self.root = root</span><br><span class="line">        self.<span class="literal">left</span> = None</span><br><span class="line">        self.<span class="literal">right</span> = None</span><br><span class="line"></span><br><span class="line">    def preorder(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        while node or stack:</span><br><span class="line">            while node:</span><br><span class="line">                <span class="comment"># 打印出根节点</span></span><br><span class="line">                <span class="literal">print</span>(node.root)</span><br><span class="line">                <span class="comment"># 然后将根节点放入stack中</span></span><br><span class="line">                stack.append(node)</span><br><span class="line">                <span class="comment"># 重新定义node为左节点</span></span><br><span class="line">                node = node.<span class="literal">left</span></span><br><span class="line">            <span class="comment"># 一个个从栈中弹出，其实是压入栈中的根节点</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 打印跟的右侧子节点</span></span><br><span class="line">            node = node.<span class="literal">right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以下遍历方式通用。           </span></span><br><span class="line">root = BinTree(<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">root.<span class="literal">left</span> = BinTree(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">root.<span class="literal">right</span> = BinTree(<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">root.<span class="literal">left</span>.<span class="literal">left</span> = BinTree(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">root.<span class="literal">left</span>.<span class="literal">right</span> = BinTree(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">root.<span class="literal">left</span>.<span class="literal">right</span>.<span class="literal">left</span> = BinTree(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">root.<span class="literal">left</span>.<span class="literal">right</span>.<span class="literal">right</span> = BinTree(<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">root.<span class="literal">right</span>.<span class="literal">right</span> = BinTree(<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">root.<span class="literal">right</span>.<span class="literal">right</span>.<span class="literal">left</span> = BinTree(<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line"><span class="comment"># 选择执行对应的遍历方法。</span></span><br><span class="line">root.preorder(root)</span><br></pre></td></tr></table></figure>
<p>解释：<br>从最顶层的根进入，然后打印出这个根，并且压入栈，然后获取这个根的左节点，依次循环，直到左节点无法获取到，然后出栈，这边出栈出来的为<strong>最后压入的根</strong>(也就是底层的左节点)，然后开始遍历其右边的子树，右边子树也是从左边开始，也是压入栈，依次循环。</p>
<h3 id="中序遍历-深度优先"><a href="#中序遍历-深度优先" class="headerlink" title="中序遍历(深度优先)"></a>中序遍历(深度优先)</h3><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g03qhndt0qj20m80izgn3.jpg" alt="midorder" width="200"/>
* 指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式。
* 顺序 `A, B, C, D, E, F, G, H, I.`

<p>堆栈代码实现:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">class BinTree(object):</span><br><span class="line">    def __init__(self,root):</span><br><span class="line">        self.root = root</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line">        </span><br><span class="line">    def midorder(self,root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">node</span> <span class="title">= root</span></span><br><span class="line">    while <span class="keyword">node</span> <span class="title">or</span> stack:</span><br><span class="line">        while <span class="keyword">node</span><span class="title">:</span></span><br><span class="line"><span class="title">            # 根压入栈</span></span><br><span class="line"><span class="title">            stack</span>.append(<span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title">            # 赋予左节点</span></span><br><span class="line"><span class="title">            node</span> = node.left</span><br><span class="line">        <span class="comment"># 挨个弹出，从最底层的左节点弹出</span></span><br><span class="line">        <span class="keyword">node</span> <span class="title">= stack</span>.pop()</span><br><span class="line">        <span class="comment"># 打印左节点</span></span><br><span class="line">        print(node.root)</span><br><span class="line">        <span class="comment"># 节点赋予右节点，开始遍历右边部分，也是从最底层开始。</span></span><br><span class="line">        <span class="keyword">node</span> <span class="title">= node</span>.right</span><br></pre></td></tr></table></figure>
<p>解释：因为是左右中的方式，所以root是最迟打印的，则先把左边的都依次压栈，然后压入最后一个，开始逐步弹出，弹出就打印一个，然后遍历弹出的右子树，也是一样的方法，依次循环，直到全部退出，打印出最顶层的root。</p>
<h3 id="后序遍历-深度优先"><a href="#后序遍历-深度优先" class="headerlink" title="后序遍历(深度优先)"></a>后序遍历(深度优先)</h3><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g03qhndt0qj20m80izgn3.jpg" alt="bakorder" width="200"/>
* 指先访问子树，然后访问根的遍历方式。子树先左后右在根节点。
* 顺序 `A, C, E, D, B, H, I, G, F.`

<p>堆栈代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,root</span>):</span></span><br><span class="line">        self.root = root</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mystack1 = []</span><br><span class="line">        <span class="comment"># mystack2中存放的是后序遍历的节点数据。</span></span><br><span class="line">        mystack2 = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="comment"># mystack1压入顶层根</span></span><br><span class="line">        mystack1.append(node)</span><br><span class="line">        <span class="keyword">while</span> mystack1:</span><br><span class="line">            node = mystack1.pop()</span><br><span class="line">            <span class="comment"># 判断是否有左或者右节点，这边控制的是下一次循环压栈到stack2的顺序。</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                mystack1.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                mystack1.append(node.right)</span><br><span class="line">            <span class="comment"># 将该数的根放入stack2中，</span></span><br><span class="line">            mystack2.append(node)</span><br><span class="line">        <span class="keyword">while</span> mystack2:</span><br><span class="line">            <span class="comment"># 此时mystack2中已经存满了节点，挨个pop()出来的顺序就是后序遍历的次序。</span></span><br><span class="line">            print(mystack2.pop().root)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>解释：因为顺序为从<strong>最左节点</strong>开始，且需要判断是否存在根的左右子节点，且不是连续，所以需要用到两个栈。mystack1放入的是当前遍历的节点，然后往mystack2中压入，这个行为之前还对节点进行左右判断，先往stack1中压入左边的节点，然后压入右边的节点，轮到下次循环的时候，后放入stack1中的(右子树)被先pop出来，然后被插入到stack2中，此时stack2中存放的顺序，根节点，然后右节点，接着左节点，依次循环，直到把stack2给压满。最后一个while执行的时候，按照左右根的顺序打印出来，就实现了。</p>
<h3 id="层级遍历-广度优先"><a href="#层级遍历-广度优先" class="headerlink" title="层级遍历(广度优先)"></a>层级遍历(广度优先)</h3><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g03qifft02j20m80hq0tw.jpg" alt="levelorder" width="200"/>
* 广度优先遍历会先访问离根节点最近的节点。二叉树的广度优先遍历又称按层次遍历。算法借助队列实现。
* 顺序 `F, B, G, A, D, I, C, E, H.`

<p>队列代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,root</span>):</span></span><br><span class="line">        self.root = root</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        myqueue = []</span><br><span class="line">        node = root</span><br><span class="line">        myqueue.append(node)</span><br><span class="line">        <span class="keyword">while</span> myqueue:</span><br><span class="line">            <span class="comment"># pop弹出第一个元素，这个是队列。</span></span><br><span class="line">            node = myqueue.pop(<span class="number">0</span>)</span><br><span class="line">            print(node.root)</span><br><span class="line">            <span class="comment"># 左右插入的顺序也是弹出的顺序。所以能保证平级打印输出。</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                myqueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                myqueue.append(node.right)</span><br></pre></td></tr></table></figure>
<p>解释：通过队列方式实现，比较简单，抓到元素append进去，一左一右方式放入，弹出的时候弹出第一个元素，并且打印。</p>
<p>refer</p>
<blockquote>
<p><a href="https://www.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/">https://www.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/</a><br><a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees</a><br><a href="https://blog.yangx.site/2016/07/22/Python-binary-tree-traverse/">https://blog.yangx.site/2016/07/22/Python-binary-tree-traverse/</a><br><a href="https://zh.wikipedia.org/zh-hant/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">https://zh.wikipedia.org/zh-hant/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>互斥锁条件变量</title>
    <url>/2021/02/28/%E4%BA%92%E6%96%A5%E9%94%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一种情景"><a href="#一种情景" class="headerlink" title="一种情景"></a>一种情景</h2><p>虽然互斥锁可以解决资源竞争的问题，但如果有以下一种场景：<strong>生产者并非持续生产，而是在某一段时间内不生产</strong>，此阶段消费者还是会不停的竞争锁，然后发现此时并不需要消费，再释放锁，再竞争获取锁，再释放，会产生服务器资源的消耗。</p>
<a id="more"></a>



<h2 id="使用条件变量"><a href="#使用条件变量" class="headerlink" title="使用条件变量"></a>使用条件变量</h2><p>此时可以引入条件变量，当条件变量满足的时候，通知其他线程进行竞争锁，否则让其他线程进入睡眠状态，这样在条件变量不符的情况下，就不会出现持续竞争的情形了，降低了服务器资源的消耗。</p>
<h3 id="python代码实现condition功能"><a href="#python代码实现condition功能" class="headerlink" title="python代码实现condition功能"></a>python代码实现condition功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&quot;(%(threadName)s) %(message)s&#x27;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">con: threading.Condition</span>):</span></span><br><span class="line">    logging.debug(<span class="string">&quot;Producer thread started&quot;</span>)</span><br><span class="line">    <span class="comment"># with上下文，自动包含了acquire() and release()方法</span></span><br><span class="line">    <span class="keyword">with</span> con:</span><br><span class="line">        logging.debug(<span class="string">&quot;Making resource available, sleep 5s&quot;</span>)</span><br><span class="line">        <span class="comment"># 等待5s。模拟生产</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        logging.debug(<span class="string">&quot;Notify all the consumers&quot;</span>)</span><br><span class="line">        <span class="comment"># 唤醒consumer</span></span><br><span class="line">        con.notify_all()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">con: threading.Condition</span>):</span></span><br><span class="line">    logging.debug(<span class="string">&quot;Consumer thread started&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> con:</span><br><span class="line">        logging.debug(<span class="string">&quot;Consumer waiting&quot;</span>)</span><br><span class="line">        <span class="comment"># wait()方法释放锁，并且进入阻塞等待状态，直到下一次被notify() 或者 notify_all().</span></span><br><span class="line">        con.wait()</span><br><span class="line">        logging.debug(<span class="string">&#x27;Consumer consumed the resource&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 实例化一个condition</span></span><br><span class="line">    condition = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># producer线程创建</span></span><br><span class="line">    pd = threading.Thread(name=<span class="string">&#x27;producer&#x27;</span>, target=producer, args=(condition,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># consumer线程创建</span></span><br><span class="line">    cs_list = []</span><br><span class="line">    cs_num = <span class="number">5</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cs_num):</span><br><span class="line">        cs_list.append(threading.Thread(name=<span class="string">&#x27;consumer_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i), target=consumer, args=(condition,)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># consumer线程启动</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cs_list:</span><br><span class="line">        c.start()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># producer线程启动</span></span><br><span class="line">    pd.start()</span><br></pre></td></tr></table></figure>
<h2 id="condition结合实际情况的用途"><a href="#condition结合实际情况的用途" class="headerlink" title="condition结合实际情况的用途"></a>condition结合实际情况的用途</h2><ol>
<li>引入一个公共变量。</li>
<li>该公共变量作为condition的判断依据</li>
<li>producer判断是否符合condition，如果符合，则唤醒其他进程，此时其他进程进行竞争，抢到锁的进行处理，处理完后释放锁，没抢到锁的，继续进入睡眠状态。</li>
<li>producer加锁操作变量，操作完后通知其他进程，然后解锁。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&quot;(%(threadName)s) %(message)s&#x27;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># resource为公共资源</span></span><br><span class="line">resource = []</span><br><span class="line">sleep_time = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义producer 添加resource</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_resource</span>(<span class="params">num</span>):</span></span><br><span class="line">    logging.debug(<span class="string">&quot;producer add item &#123;&#125; in resource&quot;</span>.<span class="built_in">format</span>(num))</span><br><span class="line">    time.sleep(sleep_time)</span><br><span class="line">    resource.append(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义consumer 消费resource</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume_resource</span>(<span class="params">re</span>):</span></span><br><span class="line">    logging.debug(<span class="string">&quot;consume from resource&quot;</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;consume &#123;&#125;&quot;</span>.<span class="built_in">format</span>(re[<span class="number">0</span>]))</span><br><span class="line">    resource.remove(re[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义consumer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">re, cn: threading.Condition</span>):</span></span><br><span class="line">    <span class="comment"># 获取锁</span></span><br><span class="line">    cn.acquire()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 如果消费失败，则调用wait方法，线程睡眠，且释放锁，等待被notify</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            consume_resource(re)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            logging.debug(<span class="string">&quot;resource is empty&quot;</span>)</span><br><span class="line">            logging.debug(<span class="string">&quot;wait until be notified&quot;</span>)</span><br><span class="line">            cn.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">cn: threading.Condition</span>):</span></span><br><span class="line">    r = random.randint(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">    logging.debug(<span class="string">&quot;random num is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(r))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, r):</span><br><span class="line">        logging.debug(<span class="string">&quot;produce item, add &#123;&#125; in resource in 2s&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        time.sleep(sleep_time)</span><br><span class="line"></span><br><span class="line">        logging.debug(<span class="string">&quot;try to get lock&quot;</span>)</span><br><span class="line">        <span class="comment"># 获取锁</span></span><br><span class="line">        cn.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 尝试添加资源。并且通知所有其他线程</span></span><br><span class="line">            add_resource(i)</span><br><span class="line">            cn.notify_all()</span><br><span class="line">        <span class="comment"># 无论如何最终都释放锁</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            cn.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    pd = threading.Thread(name=<span class="string">&quot;producer&quot;</span>, target=producer, args=(con,))</span><br><span class="line"></span><br><span class="line">    cs_list = []</span><br><span class="line">    cs_num = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cs_num):</span><br><span class="line">        cs_list.append(threading.Thread(name=<span class="string">&quot;cs_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), target=consumer, args=(resource, con,)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cs_list:</span><br><span class="line">        c.start()</span><br><span class="line">        time.sleep(sleep_time)</span><br><span class="line"></span><br><span class="line">    pd.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>多线程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>从无法加载JAVA_HOME说起</title>
    <url>/2018/12/25/%E4%BB%8E%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDJAVA-HOME%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<p>这几天在做jenkins cicd的事儿，用sudo的方式启动tomcat，直接报出无法找到JAVA_HOME。当时挺纳闷的，因为我在/etc/profile里面是添加了JAVA_HOME。</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ccc bin]# sudo ./catalina.sh start</span><br><span class="line">Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</span><br><span class="line">At least one of these environment variable is needed to run this program</span><br><span class="line">[root@ccc bin]# tail -n 5 /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/tool/jdk1.8.0_144</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure>
<p>如此如此，出现了两个疑问。</p>
<ol>
<li>为什么/etc/profile的内容无法被加载？</li>
<li>在/etc/profile里面写入jdk环境变量是否合适？</li>
</ol>
<h2 id="为什么-etc-profile的内容无法被加载？"><a href="#为什么-etc-profile的内容无法被加载？" class="headerlink" title="为什么/etc/profile的内容无法被加载？"></a>为什么/etc/profile的内容无法被加载？</h2><p>先说下一个概念，linux的用户交互模式。在linux中用户交互模式可以分为两类：</p>
<ol>
<li>Interactive Shell</li>
<li>Non-Interactive Shell</li>
</ol>
<p>Interactive Shell 顾名思义，就是登陆用户可以和shell进行交互的，比如你用xshell上一台服务器，出现的terminal就是属于Interactive Shell方式。<br>Non-Interactive Shell 非交互的模式，比如用crontab的方式执行一个shell脚本。</p>
<p>那么问题就来了，这两种模式的环境变量从哪里去获取呢？</p>
<ol>
<li>Interactive Shell登录情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">execute /etc/profile</span><br><span class="line">IF ~/.bash_profile exists THEN</span><br><span class="line">    execute ~/.bash_profile</span><br><span class="line">ELSE</span><br><span class="line">    IF ~/.bash_login exist THEN</span><br><span class="line">        execute ~/.bash_login</span><br><span class="line">    ELSE</span><br><span class="line">        IF ~/.profile exist THEN</span><br><span class="line">            execute ~/.profile</span><br><span class="line">        END IF</span><br><span class="line">    END IF</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>
<p><strong>一目了然，入口为/etc/profile文件</strong>。<br>其中在.bash_profile里面还判断是否存在<del>/.bashrc，如果存在则加载</del>/.bashrc。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">        . ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>还没完，在执行~/.bashrc的时候里面继续判断是否存在/etc/bashrc，如果存在则执行/etc/bashrc。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>顺带一说，当用户退出Interactive Shell的时候，执行~/.bash_logout内容。所以可以在退出的时候定义一些行为。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IF ~/.bash_logout exists THEN</span><br><span class="line">    execute ~/.bash_logout</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>
<h3 id="总结下Interactive-Shell的顺序："><a href="#总结下Interactive-Shell的顺序：" class="headerlink" title="总结下Interactive Shell的顺序："></a>总结下Interactive Shell的顺序：</h3><ol>
<li>/etc/profile</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
<li>~/.bash_logout (当且仅当退出Interactive Shell的时候执行)</li>
</ol>
<ol start="2">
<li>Non-Interactive Shell的情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IF ~/.bashrc exists THEN</span><br><span class="line">    execute ~/.bashrc</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>
<p>直接去执行的~/.bashrc，该文件也会判断是否存在/etc/bashrc，存在则执行/etc/bashrc。</p>
<h3 id="总结下Non-Interactive-Shell的顺序："><a href="#总结下Non-Interactive-Shell的顺序：" class="headerlink" title="总结下Non-Interactive Shell的顺序："></a>总结下Non-Interactive Shell的顺序：</h3><ol>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
</ol>
<p><strong>看似原因好像是因为<code>sudo ./catalina.sh start</code>进入了Non-Interactive Shell，从而没加载/etc/profile，其实并不是这样的。</strong><br><strong>sudo在这边搞出了幺蛾子？</strong></p>
<h3 id="sudo做了啥？"><a href="#sudo做了啥？" class="headerlink" title="sudo做了啥？"></a>sudo做了啥？</h3><p>命令输入visudo，有那么一节内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Preserving HOME has security implications since many programs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use it when searching <span class="keyword">for</span> configuration files. Note that HOME</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is already <span class="built_in">set</span> when the the env_reset option is enabled, so</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> this option is only effective <span class="keyword">for</span> configurations <span class="built_in">where</span> either</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> env_reset is disabled or HOME is present <span class="keyword">in</span> the env_keep list.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash">Defaults    always_set_home</span></span><br><span class="line"></span><br><span class="line">Defaults    env_reset</span><br><span class="line">Defaults    env_keep =  &quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS&quot;</span><br><span class="line">Defaults    env_keep += &quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;</span><br><span class="line">Defaults    env_keep += &quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;</span><br><span class="line">Defaults    env_keep += &quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;</span><br><span class="line">Defaults    env_keep += &quot;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;</span><br></pre></td></tr></table></figure>
<p><strong>其行为会将env reset，但是会保留部分环境变量。这一行为导致了<code>sudo ./catalina.sh start</code>无法寻找到jdk变量。</strong></p>
<p>比较差劲的解决方法：<br>man一下sudo，有个-E的参数，能保留之前的环境变量，但是不推荐这样做，因为有安全隐患：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-E          The -E (preserve environment) option indicates to the security policy that the user wishes to preserve their existing</span><br><span class="line">            environment variables.  The security policy may return an error if the -E option is specified and the user does not have</span><br><span class="line">            permission to preserve the environment.</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ccc bin]# sudo -E ./catalina.sh start</span><br><span class="line">Using CATALINA_BASE:   /opt/mixcdn-tomcat</span><br><span class="line">Using CATALINA_HOME:   /opt/mixcdn-tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /opt/mixcdn-tomcat/temp</span><br><span class="line">Using JRE_HOME:        /tool/jdk1.8.0_144</span><br><span class="line">Using CLASSPATH:       /opt/mixcdn-tomcat/bin/bootstrap.jar:/opt/mixcdn-tomcat/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure>
<p>好的解决方法在下面：</p>
<h2 id="在-etc-profile里面写入jdk环境变量是否合适？"><a href="#在-etc-profile里面写入jdk环境变量是否合适？" class="headerlink" title="在/etc/profile里面写入jdk环境变量是否合适？"></a>在/etc/profile里面写入jdk环境变量是否合适？</h2><p>针对部署tomcat的jdk环境，很多文档，包括我自己，之前也是从别人那边拿来的部署jdk文档，将jdk环境变量写入/etc/profile，等文件中，这个观念基本上贯穿了我整个运维生涯。</p>
<p>其实官方给出了写法，在catalina.sh里面:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Control Script <span class="keyword">for</span> the CATALINA Server</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Environment Variable Prerequisites</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   Do not set the variables in this script. Instead put them into a script</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   setenv.sh <span class="keyword">in</span> CATALINA_BASE/bin to keep your customizations separate.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   CATALINA_HOME   May point at your Catalina &quot;build&quot; directory.</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#   CATALINA_BASE   (Optional) Base directory for resolving dynamic portions</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">                   of a Catalina installation.  If not present, resolves to</span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">.</span><br><span class="line"><span class="meta">#</span><span class="bash"> Ensure that any user defined CLASSPATH variables are not used on startup,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> but allow them to be specified <span class="keyword">in</span> setenv.sh, <span class="keyword">in</span> rare <span class="keyword">case</span> when it is needed.</span></span><br><span class="line">CLASSPATH=</span><br><span class="line"></span><br><span class="line">if [ -r &quot;$CATALINA_BASE/bin/setenv.sh&quot; ]; then</span><br><span class="line">  . &quot;$CATALINA_BASE/bin/setenv.sh&quot;</span><br><span class="line">elif [ -r &quot;$CATALINA_HOME/bin/setenv.sh&quot; ]; then</span><br><span class="line">  . &quot;$CATALINA_HOME/bin/setenv.sh&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">...</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"></span><br><span class="line">就是在tomcat/bin目录下面，写入一个setenv.sh文件里面写入需要的环境变量，当运行catalina.sh启动脚本的时候，其会进行执行该setenv.sh文件，当前我的版本是1.8，非特殊情况其已经不需要写入CLASSPATH。(据说jdk1.5之后就不需要写入CLASSPATH了。)</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">[root@ccc bin]# cat setenv.sh</span><br><span class="line">export JAVA_HOME=/tool/jdk1.8.0_144</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>多看官方文档，多看服务自带脚本还是非常有必要的。</p>
<p>Refer:</p>
<blockquote>
<p><a href="https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/">https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/</a><br><a href="https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/">https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/</a><br><a href="https://stackoverflow.com/questions/8633461/how-to-keep-environment-variables-when-using-sudo">https://stackoverflow.com/questions/8633461/how-to-keep-environment-variables-when-using-sudo</a><br><a href="https://segmentfault.com/q/1010000011528636/a-1020000011538128">https://segmentfault.com/q/1010000011528636/a-1020000011538128</a></p>
</blockquote>
<p>下次写sudo su两个命令。</p>
]]></content>
      <categories>
        <category>system</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>做一个不专业的jenkins回滚</title>
    <url>/2019/04/11/%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%8D%E4%B8%93%E4%B8%9A%E7%9A%84jenkins%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<h2 id="war包回滚思路"><a href="#war包回滚思路" class="headerlink" title="war包回滚思路"></a>war包回滚思路</h2><h3 id="发布期间"><a href="#发布期间" class="headerlink" title="发布期间"></a>发布期间</h3><ol>
<li>对正在提供服务的war包在<em>同目录</em>下，重命名为xxx.warbak</li>
<li>并且对该war归档到指定目录</li>
</ol>
<a id="more"></a>

<h3 id="回滚期间"><a href="#回滚期间" class="headerlink" title="回滚期间"></a>回滚期间</h3><ol>
<li>将同目录下war的备份文件还原成xxx.war</li>
</ol>
<h2 id="用到的组件如下"><a href="#用到的组件如下" class="headerlink" title="用到的组件如下:"></a>用到的组件如下:</h2><ol>
<li>Customized Build Message Plugin（build后可以看到备注等自动传入的信息）</li>
<li>Build With Parameters  (build的时候选填参数)</li>
<li>Git Parameter Plug-In (选择分支，tag等)</li>
<li>Publish Over SSH  (通过ssh方式发包)</li>
</ol>
<h2 id="配置介绍"><a href="#配置介绍" class="headerlink" title="配置介绍"></a>配置介绍</h2><ol>
<li>每个publish over ssh的对象都存在两种情况，发布(deploy)和回滚(rollback)，所以需要对一个机器创建两个状态。</li>
<li>根据build的时候传入的参数，deploy还是rollback，选择对应的行为。</li>
</ol>
<h2 id="配置截图"><a href="#配置截图" class="headerlink" title="配置截图"></a>配置截图</h2><p><strong>图小新开一个浏览器页面看</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g1yiam30k7j218g7wikiu.jpg"></p>
<h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码:"></a>部分代码:</h2><ol>
<li>部署</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ -d &quot;/opt/$&#123;tomcat_dir&#125;/war&quot; ] &amp;&amp; echo &#x27;back dir is exist&#x27; || mkdir -p /opt/$&#123;tomcat_dir&#125;/war;</span><br><span class="line">cp /opt/$&#123;tomcat_dir&#125;/webapps/$&#123;tomcat_war&#125;.war /opt/$&#123;tomcat_dir&#125;/war/$&#123;tomcat_war&#125;.war_`date +&quot;%Y%m%d-%H%M&quot;` || echo &#x27;not exist war&#x27;;</span><br><span class="line">ps -ef | grep $&#123;tomcat_dir&#125; | grep -vP &quot;cronolog|grep&quot; | awk &#x27;&#123;print $2&#125;&#x27; | xargs -I &#123;&#125; kill &#123;&#125;;</span><br><span class="line">sleep 3;</span><br><span class="line">rm -rf /opt/$&#123;tomcat_dir&#125;/webapps/$&#123;tomcat_war&#125;;</span><br><span class="line">/bin/mv /opt/$&#123;tomcat_dir&#125;/webapps/$&#123;tomcat_war&#125;.&#123;war,warbak&#125; || echo &#x27;not exist war&#x27;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>回滚</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep $&#123;tomcat_dir&#125; | grep -vP &quot;cronolog|grep&quot; | awk &#x27;&#123;print $2&#125;&#x27; | xargs -I &#123;&#125; kill &#123;&#125;;</span><br><span class="line">sleep 3;</span><br><span class="line">rm -rf /opt/$&#123;tomcat_dir&#125;/webapps/$&#123;tomcat_war&#125;;</span><br><span class="line">/bin/mv /opt/$&#123;tomcat_dir&#125;/webapps/$&#123;tomcat_war&#125;.&#123;warbak,war&#125; || echo &#x27;not exist war&#x27;;</span><br><span class="line"><span class="meta">/opt/$</span><span class="bash">&#123;tomcat_dir&#125;/bin/catalina.sh start;</span></span><br></pre></td></tr></table></figure>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><ol>
<li>由于采用的是maven项目，所以不论发布还是回滚都是会进行war包的build，其实在回滚的时候是不需要进行war包的build的。</li>
</ol>
<p>refer:</p>
<blockquote>
<p><a href="http://www.eryajf.net/1404.html">http://www.eryajf.net/1404.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化样式和子绝父相</title>
    <url>/2020/03/02/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B7%E5%BC%8F%E5%92%8C%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8/</url>
    <content><![CDATA[<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><ol>
<li><p>最近把前端重新温习了下，然后在写小程序，首页样式就难住了，中间区块，怎么都无法铺满空白区域。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1gcfq81qns2j20b90jbt93.jpg" alt="zhongjian.png"></p>
</li>
<li><p>当时想到用子绝父相来解决，但即便使用了，还是有问题。中间区块设定bottom: 88rpx无法和底端bar对齐。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="排查结果"><a href="#排查结果" class="headerlink" title="排查结果"></a>排查结果</h2><ol>
<li>内容块无法准确拉伸位置到bottom: 88rpx，是因为父组件的高度有问题，这个父组件为最外层的组件.content，我当时给的高度是height: 100%。</li>
<li>然后因为.content是page根组件的子组件，所以height:100% 是继承page的高度，但page并没有设定高度，所以出现了问题。</li>
</ol>
<h2 id="思考如何给page设置一个合理的高度"><a href="#思考如何给page设置一个合理的高度" class="headerlink" title="思考如何给page设置一个合理的高度"></a>思考如何给page设置一个合理的高度</h2><ol>
<li>因为用的是小程序，所以手机端有不同的高度，苹果6和苹果x高度就不一致，如果我设定一个固定高度，那么适配不同手机屏幕肯定会存在问题。</li>
<li>后来查阅了文档，vh这个属性表示视口高度，也就是当前屏幕可见范围的高度，100vh表示整个屏幕，不论这个屏幕是什么类型的手机。</li>
<li>其实只要给.content设置100vh即可。</li>
</ol>
<h2 id="配合子绝父相"><a href="#配合子绝父相" class="headerlink" title="配合子绝父相"></a>配合子绝父相</h2><ol>
<li>让.content作为父元素，使用相对定位，设置<code>position: relative</code>。</li>
<li>再添加<code>height: 100vh;</code>属性。</li>
<li>白色区块内容作为子元素，让其绝对定位，设置<code>position: absolute</code>。</li>
<li>然后子元素使用top, bottom, left, right进行调整位置。</li>
</ol>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li>一开始初始化那会，要给最外层的先设定一个高度，如果是动态的话就给一个100vh的高度填满视口。</li>
<li>在父元素没有高度的时候，子元素使用<code>height: 100%</code>是没有效果的，即便是根组件使用，也是没有效果，这个和<code>width: 100%</code>不一样，不会撑开高度，具体原因<strong>浏览器根本就不计算内容的高度，除非内容超出了视窗范围(导致滚动条出现)。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑</strong>。</li>
</ol>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><ol>
<li><p>html代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">c-swiper</span> <span class="attr">class</span>=<span class="string">&#x27;foods-wrapper&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">c-swiper</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">c-search</span>&gt;</span><span class="tag">&lt;/<span class="name">c-search</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">c-foods-list</span>&gt;</span><span class="tag">&lt;/<span class="name">c-foods-list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">c-bottom-bar</span>&gt;</span><span class="tag">&lt;/<span class="name">c-bottom-bar</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>content部分</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: column;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#007AFF</span>;</span><br><span class="line">	<span class="comment">/* 视口高度100 */</span></span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">	<span class="comment">/* 子绝父相，有利于子元素定位 */</span></span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="3">
<li><p>foods-wrapper部分代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foods-wrapper</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: row;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#C03189</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">350</span>rpx;</span><br><span class="line">	<span class="attribute">bottom</span>: <span class="number">88</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>refer</p>
<blockquote>
<p><a href="http://www.webhek.com/post/css-100-percent-height.html">http://www.webhek.com/post/css-100-percent-height.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>front end</category>
      </categories>
      <tags>
        <tag>css，小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表实现</title>
    <url>/2020/06/14/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p><a href="https://iostat.io/2019/02/18/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/">链表基础</a></p>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><img src="https://assets.iostat.io/image/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="单向链表.png"></p>
<ul>
<li>第一个节点称之为头节点，里面不存放数据，最后一个称之为尾节点，指向NULL。</li>
<li>每个节点分为两个部分。第一个部分是保存活显示关于节点的信息，第二个部分是存储下一个节点的地址。</li>
<li>单链表只能单方向遍历，且最后尾节点的下一个地址指针指向为NULL。</li>
</ul>
<a id="more"></a>

<h3 id="go语言实现单向链表"><a href="#go语言实现单向链表" class="headerlink" title="go语言实现单向链表"></a>go语言实现单向链表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设计一个单向链表，要求插入的数据能够有序。</span></span><br><span class="line"><span class="comment">NO.1 C</span></span><br><span class="line"><span class="comment">No.2 PHP</span></span><br><span class="line"><span class="comment">No.3 Java</span></span><br><span class="line"><span class="comment">No.4 NodeJs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表会有一个head头，该节点不包含任何数据。</span></span><br><span class="line"><span class="comment">遍历链表，从head开始，取next的，依次取，如果为nil说明到链表尾部。</span></span><br><span class="line"><span class="comment">插入元素，从head开始，取出下一个节点的No进行比较，如果大于则在当前位置插入，让插入的新节点指向下一个节点，临时节点指向新节点。</span></span><br><span class="line"><span class="comment">删除元素，从head开始，取出下一个节点的No进行比较，如果大于则在当前位置删除, 将临时节点的next指向下下个节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LanNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	No <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// next指向下一个节点</span></span><br><span class="line">	next *LanNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNode</span><span class="params">(no <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">LanNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;LanNode&#123;</span><br><span class="line">		No:no,</span><br><span class="line">		Name:name,</span><br><span class="line">		<span class="comment">// 默认让next指向下一个节点，所以只需要传入no和string即可。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertNode</span><span class="params">(head *LanNode, newNode *LanNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 给定一个临时节点，用来遍历</span></span><br><span class="line">	<span class="comment">// 该临时节点为内存引用</span></span><br><span class="line">	tmp := head</span><br><span class="line">	<span class="comment">// 如果当前链表为空，则直接插入newNode</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			tmp.next = newNode</span><br><span class="line">			fmt.Println(<span class="string">&quot;已经遍历到链表尾部，插入成功&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当next的No大于新节点的No，表示可以插入</span></span><br><span class="line">		<span class="keyword">if</span> tmp.next.No &gt; newNode.No &#123;</span><br><span class="line">			<span class="comment">// 让插入的新节点指向next节点</span></span><br><span class="line">			newNode.next = tmp.next</span><br><span class="line">			<span class="comment">// 让tmp的next节点指向新节点</span></span><br><span class="line">			tmp.next = newNode</span><br><span class="line">			fmt.Println(<span class="string">&quot;已经插入到合适位置&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存在相同的情况，则退出</span></span><br><span class="line">		<span class="keyword">if</span> tmp.next.No == newNode.No &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;无法插入该节点，已有相同No&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 步进</span></span><br><span class="line">		tmp = tmp.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(head *LanNode, no <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 给tmp一个赋值，作为临时节点，用来遍历</span></span><br><span class="line">	<span class="comment">// 这个tmp其实是内存的引用</span></span><br><span class="line">	tmp := head</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;不存在待删除的no&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tmp.next.No == no &#123;</span><br><span class="line">			<span class="comment">// 将tmp当前的节点next指向tmp下一个节点的下一个节点。</span></span><br><span class="line">			tmp.next = tmp.next.next</span><br><span class="line">			fmt.Println(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 步进</span></span><br><span class="line">		tmp = tmp.next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对节点进行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listNode</span><span class="params">(head *LanNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从head的next开始遍历，直到nil为止</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> head.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;已经遍历到底部&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;No为%d, Name为%s语言 ==&gt; &quot;</span>,head.next.No, head.next.Name)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 步进</span></span><br><span class="line">		head = head.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义head头，不需要存放任何数据</span></span><br><span class="line">	headNode := &amp;LanNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义四个新的节点</span></span><br><span class="line">	nodeC := newNode(<span class="number">1</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">	nodePHP := newNode(<span class="number">2</span>, <span class="string">&quot;PHP&quot;</span>)</span><br><span class="line">	nodeJava := newNode(<span class="number">3</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">	nodeNodeJs := newNode(<span class="number">4</span>, <span class="string">&quot;NodeJs&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行数据插入, 这里乱序插入</span></span><br><span class="line">	insertNode(headNode, nodeC)</span><br><span class="line">	insertNode(headNode, nodeJava)</span><br><span class="line">	insertNode(headNode, nodeNodeJs)</span><br><span class="line">	insertNode(headNode, nodePHP)</span><br><span class="line"></span><br><span class="line">	listNode(headNode)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除一个数据3</span></span><br><span class="line">	deleteNode(headNode, <span class="number">3</span>)</span><br><span class="line">	listNode(headNode)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>go</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>原码反码补码以及位运算</title>
    <url>/2020/04/30/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E4%BB%A5%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><strong>无符号用原码</strong></p>
<p><strong>计算机的运算都用的补码</strong></p>
<a id="more"></a>

<h3 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h3><ol>
<li>原码， 反码，补码都相同</li>
</ol>
<h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><ol>
<li>反码等于原码符号位不变，其他取反。</li>
<li>补码等于反码+1</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p>2的原码为0000 0010, 因为是正数，所以反码、补码都相同为0000 0010。</p>
</li>
<li><p>-2的原码为1000 0010, 最高位1为符号位，1表示负数，0表示正数。所以其反码为1111 1101, 补码为反码+1, 则为1111 1110。</p>
</li>
</ol>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol>
<li><strong>位运算使用的都是反码。</strong></li>
<li><strong>位运算如果存在负数，最后都需要还原为原码得到真值。</strong></li>
</ol>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><h4 id="2和2做异或"><a href="#2和2做异或" class="headerlink" title="-2和2做异或"></a>-2和2做异或</h4><p>-2补码为1111 1110，2补码为0000 0010， 两者异或得到1111 1100。</p>
<p>因为存在-2,负数，所以需要对结果-1，**然后除了符号位进行取反操作，得到真正的值(原码)**，即对1111 1100减1，得到1111 1011，然后除去符号位取反，得到1000 0100，该值为-4。</p>
<h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><ol>
<li>右移运算，&gt;&gt; <strong>低位溢出，符号位不变，并用符号位(正数0补，负数1补)补溢出的高位</strong></li>
<li>左移运算，&lt;&lt; <strong>符号位不变，不够部分用0来补</strong></li>
<li><strong>位移运算如果存在负数，最后都需要还原为原码得到真值。</strong></li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>1的补码为0000 0001, 右移2位，符号位不变，得到0000 0000即为0</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>&lt;&lt;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>左移两位，符号位不变，不够的部分0补，得到0000 0100即为4</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-2&gt;&gt;2</span></span><br></pre></td></tr></table></figure>
<p>-2的补码为1111 1110,右移2位，符号不变，高位溢出，用符号位1来补，得到1111 1111，<strong>然后-1，除去符号位取反还原回原码，1000 0001</strong>即为-1.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-2&lt;&lt;<span class="string">2</span></span><br></pre></td></tr></table></figure>
<p>-2的补码为1111 1110,右移2位，符号不变，不够部分用0补，得到1111 1000，然后-1，除去符号位取反得到原码为1000 1000，即为-8。</p>
<h2 id="有些东西迟早还是要还的。。。"><a href="#有些东西迟早还是要还的。。。" class="headerlink" title="有些东西迟早还是要还的。。。"></a>有些东西迟早还是要还的。。。</h2>]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表实现</title>
    <url>/2020/06/15/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p><a href="https://iostat.io/2019/02/18/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/">链表基础</a></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://assets.iostat.io/image/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg" alt="双向链表.png"></p>
<ul>
<li>双向链表可以向前或者向后查找。</li>
<li>双向链表可以实现自我删除。</li>
<li>插入一个元素，让插入的新节点指向tmp.next节点，新节点的pre指向tmp临时节点, tmp.next也就是临时节点的下一个节点，也就是新节点的下一个节点).pre指向新节点，最后让tmp.next指向新节点。这里顺序不能乱。</li>
<li>删除一个元素，将tmp当前的节点next指向tmp下一个节点的下一个节点，此时tmp.next节点变成了待删除节点的下一个节点，接着让tmp的下个节点的pre指向tmp，完成删除。期间要考虑next为空节点的情况。</li>
</ul>
<a id="more"></a>

<h3 id="go语言实现双向链表"><a href="#go语言实现双向链表" class="headerlink" title="go语言实现双向链表"></a>go语言实现双向链表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 双向链表可以向前或者向后查找。</span></span><br><span class="line"><span class="comment">2. 双向链表可以实现自我删除。</span></span><br><span class="line"><span class="comment">3. 插入一个元素，让插入的新节点指向tmp.next节点，新节点的pre指向tmp临时节点, tmp.next也就是临时节点的下一个节点，也就是新节点的下一个节点).pre指向新节点，最后让tmp.next指向新节点。这里顺序不能乱。</span></span><br><span class="line"><span class="comment">4. 删除一个元素，将tmp当前的节点next指向tmp下一个节点的下一个节点，此时tmp.next节点变成了待删除节点的下一个节点，接着让tmp的下个节点的pre指向tmp，完成删除。期间要考虑next为空节点的情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LanNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	No <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// next指向下一个节点</span></span><br><span class="line">	next *LanNode</span><br><span class="line">	<span class="comment">// pre指向上一个节点</span></span><br><span class="line">	pre  *LanNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNode</span><span class="params">(no <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">LanNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;LanNode&#123;</span><br><span class="line">		No:no,</span><br><span class="line">		Name:name,</span><br><span class="line">		<span class="comment">// 默认让next指向下一个节点，所以只需要传入no和string即可。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertNode</span><span class="params">(head *LanNode, newNode *LanNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 给定一个临时节点，用来遍历</span></span><br><span class="line">	<span class="comment">// 该临时节点为内存引用</span></span><br><span class="line">	tmp := head</span><br><span class="line">	<span class="comment">// 如果当前链表为空，则直接插入newNode</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			tmp.next = newNode</span><br><span class="line">			fmt.Println(<span class="string">&quot;已经遍历到链表尾部，插入成功&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当next的No大于新节点的No，表示可以插入</span></span><br><span class="line">		<span class="keyword">if</span> tmp.next.No &gt; newNode.No &#123;</span><br><span class="line">			<span class="comment">// 让插入的新节点指向next节点</span></span><br><span class="line">			newNode.next = tmp.next</span><br><span class="line">			<span class="comment">// 新节点的pre指向当前临时的tmp节点()</span></span><br><span class="line">			newNode.pre = tmp</span><br><span class="line">			<span class="comment">// 让tmp下一个节点的pre指向newNode</span></span><br><span class="line">			tmp.next.pre = newNode</span><br><span class="line">			<span class="comment">// 让tmp的next节点指向新节点</span></span><br><span class="line">			tmp.next = newNode</span><br><span class="line"></span><br><span class="line">			fmt.Println(<span class="string">&quot;已经插入到合适位置&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存在相同的情况，则退出</span></span><br><span class="line">		<span class="keyword">if</span> tmp.next.No == newNode.No &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;无法插入该节点，已有相同No&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 步进</span></span><br><span class="line">		tmp = tmp.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(head *LanNode, no <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 给tmp一个赋值，作为临时节点，用来遍历</span></span><br><span class="line">	<span class="comment">// 这个tmp其实是内存的引用</span></span><br><span class="line">	tmp := head</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;不存在待删除的no&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tmp.next.No == no &#123;</span><br><span class="line">			<span class="comment">// 将tmp当前的节点next指向tmp下一个节点的下一个节点。</span></span><br><span class="line">			tmp.next = tmp.next.next</span><br><span class="line">			<span class="comment">// 因为tmp.next.next可能是nil, 那么如果是的话,则nil没有pre, 为nil的时候直接暂停,不需要pre了.</span></span><br><span class="line">			<span class="keyword">if</span> tmp.next != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 因为tmp.next已经指向了tmp.next.next, 所以这里的tmp.next已经跳过了被删除的节点. 让tmp的下个节点的pre指向tmp</span></span><br><span class="line">				tmp.next.pre = tmp</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;删除成功&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 步进</span></span><br><span class="line">		tmp = tmp.next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对节点进行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listNode</span><span class="params">(head *LanNode)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从head的next开始遍历，直到nil为止</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> head.next == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;已经遍历到底部&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;No为%d, Name为%s语言 ==&gt; &quot;</span>,head.next.No, head.next.Name)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 步进</span></span><br><span class="line">		head = head.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义head头，不需要存放任何数据</span></span><br><span class="line">	headNode := &amp;LanNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义四个新的节点</span></span><br><span class="line">	nodeC := newNode(<span class="number">1</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">	nodePHP := newNode(<span class="number">2</span>, <span class="string">&quot;PHP&quot;</span>)</span><br><span class="line">	nodeJava := newNode(<span class="number">3</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">	nodeNodeJs := newNode(<span class="number">4</span>, <span class="string">&quot;NodeJs&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行数据插入, 这里乱序插入</span></span><br><span class="line">	insertNode(headNode, nodeC)</span><br><span class="line">	insertNode(headNode, nodeJava)</span><br><span class="line">	insertNode(headNode, nodeNodeJs)</span><br><span class="line">	insertNode(headNode, nodePHP)</span><br><span class="line"></span><br><span class="line">	listNode(headNode)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除一个数据3</span></span><br><span class="line">	deleteNode(headNode, <span class="number">3</span>)</span><br><span class="line">	listNode(headNode)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>go</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>用正确的姿势动态修改小程序样式</title>
    <url>/2020/03/13/%E5%B0%8F%E7%A8%8B%E5%BA%8Fwxs%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="我的小程序菜单栏点击延迟很大"><a href="#我的小程序菜单栏点击延迟很大" class="headerlink" title="我的小程序菜单栏点击延迟很大"></a>我的小程序菜单栏点击延迟很大</h2><ol>
<li>小程序是用uni-app写的，写完真机调试发现菜单栏点击的延迟相当厉害，几乎有一到两秒。</li>
<li>微信开发工具的模拟界面点击没有任何的延迟感。</li>
<li>点击菜单栏会使得当前被点击的内容添加额外的样式，字体color为红色，背景为灰色。</li>
</ol>
<a id="more"></a>

<h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><ol>
<li><p>使用微信开发工具的”Audits”进行体验评分，体验分挺高的，但我自己的体验还是很差啊。</p>
</li>
<li><p>翻阅网上资料，修改样式也就差不多那么几种方式，我也是这样写的，感觉没毛病呀。</p>
</li>
<li><p>最小化配置，删减了所有其他相关组件，就留下了一个菜单，关联的样式也全部删掉，真机测试，还是有延迟。</p>
</li>
<li><p>怀疑是自己手机的问题，于是我用了下饿了么的小程序，大受打击，同时也让朋友真机测了下，也说有延迟感觉。</p>
</li>
<li><p>难道是uni-app框架的锅？行吧，我用小程序原生代码写了个菜单，点击发现的确比uniapp流畅点，但还是没有饿了么小程序那个菜单来的顺滑。</p>
</li>
<li><p>wdnmd，网上搜来搜去，说卡的基本上是组件过多，图片过多导致，跟我这个不太一样。</p>
</li>
<li><p>就这么过去了将近3天，一直没有头绪。让我更加在意的是饿了么为什么能那么流畅？</p>
</li>
</ol>
<h2 id="uni-app原代码"><a href="#uni-app原代码" class="headerlink" title="uni-app原代码"></a>uni-app原代码</h2><h3 id="template部分代码"><a href="#template部分代码" class="headerlink" title="template部分代码"></a>template部分代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;block v-for&#x3D;&#39;(item,index) in foodsInfo&#39; :key&#x3D;&#39;item.category&#39;&gt;</span><br><span class="line">	&lt;view class&#x3D;&#39;side-left-item&#39; @click&#x3D;&quot;itemClick(index)&quot; :class&#x3D;&quot;&#123;active: index &#x3D;&#x3D;&#x3D; currentIndex&#125;&quot;&gt;</span><br><span class="line">		&lt;text&gt;&#123;&#123;item.category&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">	&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JS部分代码"><a href="#JS部分代码" class="headerlink" title="JS部分代码"></a>JS部分代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		currentIndex: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="function"><span class="title">itemClick</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.currentIndex = index</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h2 id="小程序原生代码"><a href="#小程序原生代码" class="headerlink" title="小程序原生代码"></a>小程序原生代码</h2><h3 id="视图层部分代码"><a href="#视图层部分代码" class="headerlink" title="视图层部分代码"></a>视图层部分代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;block wx:for&#x3D;&quot;&#123;&#123;leftData&#125;&#125;&quot; wx:for-item&#x3D;&quot;lcai&quot; wx:key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">&lt;view bindtap&#x3D;&quot;btnClick&quot; data-index&#x3D;&quot;&#123;&#123;index&#125;&#125;&quot; class&#x3D;&quot;inner &#123;&#123;currentIndex &#x3D;&#x3D; index? &#39;active&#39; : &#39;&#39;&#125;&#125;&quot;&gt;&#123;&#123;lcai.name&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑层部分代码"><a href="#逻辑层部分代码" class="headerlink" title="逻辑层部分代码"></a>逻辑层部分代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentIndex: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  btnClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = e.currentTarget.dataset.index;</span><br><span class="line">    <span class="built_in">console</span>.log(index)</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      currentIndex: index</span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<h3 id="原代码的实现方式"><a href="#原代码的实现方式" class="headerlink" title="原代码的实现方式"></a>原代码的实现方式</h3><ol>
<li>跟网上说的基本上一致，绑定点击事件，通过判断当前元素的index和currentIndex是否相等，返回true或者false来动态添加active样式(color:red; background-color: gray;)。</li>
<li>看着没有任何的问题，在pc端也是这么写的。</li>
</ol>
<h2 id="直到我看到了这篇文章"><a href="#直到我看到了这篇文章" class="headerlink" title="直到我看到了这篇文章"></a>直到我看到了这篇文章</h2><ul>
<li><p>植树节晚上洗完澡一直在考虑这个问题，没有头绪，谷歌搜了下通用类的小程序优化思路。看到了如下这篇文章，才恍然大悟。</p>
</li>
<li><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/82741561">https://zhuanlan.zhihu.com/p/82741561</a></p>
</blockquote>
</li>
</ul>
<h3 id="为什么会慢？"><a href="#为什么会慢？" class="headerlink" title="为什么会慢？"></a>为什么会慢？</h3><ul>
<li>小程序的视图层(wxml)和逻辑层(js)是独立分开的。这样视图层不能运行js代码，逻辑层的js代码也不能修改视图层的dom</li>
<li>当数据更新以及事件系统只能靠线程间通讯，但跨线程通信的成本极高，一些频繁通讯的场景，触摸、滚动等。</li>
<li>一个点击行为，需要经过视图层、Native、逻辑层三者之间2个完整来回的通信，通信的耗时开销较大，用户的交互就会出现延时卡顿的情况。</li>
<li>for循环对数据格式修改，也会造成逻辑层和视图层频繁通讯。</li>
</ul>
<h3 id="wxs的出现"><a href="#wxs的出现" class="headerlink" title="wxs的出现"></a>wxs的出现</h3><ul>
<li>wxs是一种被限制了的js，他可以运行在视图层。<strong>换句话说wxs和视图层的交互不需要经过Native层</strong>。</li>
<li>他是不可以操作dom的，因为小程序的视图层和逻辑层的分开就是为了不想用js直接操作dom。</li>
<li>wxs无法直接修改业务数据，只能对当前组件的class和style处理，或者数据进行格式化。</li>
<li>如果要修改业务逻辑数据，则需要用callMethod方法。</li>
</ul>
<h3 id="wxs适合的场景"><a href="#wxs适合的场景" class="headerlink" title="wxs适合的场景"></a>wxs适合的场景</h3><ul>
<li>用户交互频繁、仅需改动组件样式（比如布局位置），无需改动数据内容的场景，比如侧滑菜单、索引列表、滚动渐变等 - 数据格式处理，比如文本、日期格式化，或者国际化。</li>
</ul>
<h2 id="修改后的uni-app代码"><a href="#修改后的uni-app代码" class="headerlink" title="修改后的uni-app代码"></a>修改后的uni-app代码</h2><h3 id="template部分代码-1"><a href="#template部分代码-1" class="headerlink" title="template部分代码"></a>template部分代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;block v-for&#x3D;&#39;(item,index) in foodsInfo&#39; :key&#x3D;&#39;index&#39;&gt;</span><br><span class="line">  &lt;!-- 绑定多个class的方式，用数组，变量不需要加&#123;&#123;&#125;&#125;     点击事件绑定wxs中export的clickwxs--&gt;</span><br><span class="line">	&lt;view :data-index&#x3D;&quot;index&quot; :class&#x3D;&#39;[&quot;side-left-item&quot;, &quot;inner_&quot; + index]&#39; @click&#x3D;&quot;clickwxs.tapName&quot;&gt;</span><br><span class="line">		&lt;text&gt;&#123;&#123;item.category&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">	&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>
<h3 id="WXS部分代码"><a href="#WXS部分代码" class="headerlink" title="WXS部分代码"></a>WXS部分代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该代码和上面template代码为同一个文件下。</span></span><br><span class="line"><span class="comment">//命名为clickwxs</span></span><br><span class="line">&lt;script <span class="built_in">module</span>=<span class="string">&quot;clickwxs&quot;</span> lang=<span class="string">&quot;wxs&quot;</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tapName</span>(<span class="params">event, ins</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.currentTarget.dataset.index)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(event))</span><br><span class="line">  <span class="keyword">var</span> owner = ins.selectAllComponents(<span class="string">&#x27;.side-left-item&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(owner)</span><br><span class="line">  <span class="comment">// 移除样式</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; owner.length; i++) &#123;</span><br><span class="line">    owner[i].removeClass(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;.inner&#x27;</span> + i)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">var</span> instance = ins.selectComponent(<span class="string">&#x27;.inner_&#x27;</span> + event.currentTarget.dataset.index)</span><br><span class="line">	<span class="built_in">console</span>.log(instance)</span><br><span class="line">  <span class="comment">// 添加active样式</span></span><br><span class="line">  instance.addClass(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">  instance.getDataset()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  tapName: tapName</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h2 id="修改后的微信小程序原生代码"><a href="#修改后的微信小程序原生代码" class="headerlink" title="修改后的微信小程序原生代码"></a>修改后的微信小程序原生代码</h2><h3 id="视图层代码"><a href="#视图层代码" class="headerlink" title="视图层代码"></a>视图层代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入wxs--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;wxs&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./index.wxs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-y</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;scroll&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;leftData&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;lcai&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">&quot;&#123;&#123;wxs.tapName&#125;&#125;&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;inner inner_&#123;&#123;index&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;lcai.name&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="wxs代码"><a href="#wxs代码" class="headerlink" title="wxs代码"></a>wxs代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tapName</span>(<span class="params">event, ownerInstance</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取所有class=&quot;inner&quot;的组件</span></span><br><span class="line">  <span class="keyword">var</span> owner = ownerInstance.selectAllComponents(<span class="string">&#x27;.inner&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(owner)</span><br><span class="line">  <span class="comment">// 清除样式</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; owner.length; i++) &#123;</span><br><span class="line">    owner[i].removeClass(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;.inner_&#x27;</span> + i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> instance = ownerInstance.selectComponent(<span class="string">&#x27;.inner_&#x27;</span> + event.currentTarget.dataset.index)</span><br><span class="line">  <span class="comment">// 添加active样式</span></span><br><span class="line">  instance.addClass(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">  instance.getDataset()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  tapName: tapName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>修改完后，无论是uni-app框架的小程序，还是小程序原生的写法，点击延迟感不再有。</strong></p>
<h2 id="两份代码github地址"><a href="#两份代码github地址" class="headerlink" title="两份代码github地址"></a>两份代码github地址</h2><ol>
<li><blockquote>
<p><a href="https://github.com/huangyisan/fooods">https://github.com/huangyisan/fooods</a>  leftbuttom分支</p>
</blockquote>
</li>
<li><blockquote>
<p><a href="https://github.com/huangyisan/ori-fooods">https://github.com/huangyisan/ori-fooods</a></p>
</blockquote>
</li>
</ol>
<p>refer</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/82741561">https://zhuanlan.zhihu.com/p/82741561</a></p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html">https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html</a></p>
<p><a href="https://www.cnblogs.com/murenziwei/p/11233505.html">https://www.cnblogs.com/murenziwei/p/11233505.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2019/03/19/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h2 id="判断value是否存在"><a href="#判断value是否存在" class="headerlink" title="判断value是否存在"></a>判断value是否存在</h2><ol>
<li>常用判断某个value是否存在特定集合中，一般用hashmap，但hashmap存储量较高。</li>
<li>布隆过滤器相对于hashmap而言，牺牲了准确性，但大大降低了空间利用率。</li>
<li>布隆过滤器对值的判断存在两种情况，<strong>可能存在</strong>和<strong>绝对不存在</strong>。</li>
</ol>
<a id="more"></a>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>布隆过滤器两个要素，长度为n的bit array和m个独立的hash function。对需要写入的数值value进行所有的hash function运算，得到的值和n进行取模运算，得到m个位置，把bit array的这些位置置为1，就完成了一次写入。</p>
<h2 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h2><p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g18503hemmj20ow0mk3z4.jpg"></p>
<ol>
<li>需要存入的值为’huangyisan’，bit arrary长度为10。</li>
<li>存在三个hash方法，分别对huangyisan运算。</li>
<li>然后对函数执行得到的结果，和长度10取模。</li>
<li>取模得到的值，在bit arrary中对应位置至于1。</li>
<li>那么只要bit arrary的3 5 9 位为1，则代表huangyisan这个字符串存在。</li>
</ol>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>布隆过滤器的两个状态，一个为绝对不存在(negative)，还有一个为可能存在(positive)。所以这个可能存在的状态，会使得得到的结果不一定准确。<br>出现这个情况，主要是存入数据比较多，导致bit位重叠，所以单单根据bit位为1判断某个字符串是否存在，只能判断为可能存在。<br>所以在对准确性有一定容忍度的环境，是可以使用布隆选择器的。</p>
<h2 id="问题最大可能进行避免"><a href="#问题最大可能进行避免" class="headerlink" title="问题最大可能进行避免"></a>问题最大可能进行避免</h2><p>问题肯定能存在，但可以降低产生的概率，此时就要在使用之前对bit arrary长度，hash function数量等因素进行设定。<br>一个可以进行评估设定的站点: <a href="https://hur.st/bloomfilter/?n=4000&amp;p=1.0E-7&amp;m=&amp;k=2">https://hur.st/bloomfilter/?n=4000&amp;p=1.0E-7&amp;m=&amp;k=2</a></p>
<h2 id="python实现布隆过滤器"><a href="#python实现布隆过滤器" class="headerlink" title="python实现布隆过滤器"></a>python实现布隆过滤器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,size</span>):</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.arrarylist = [<span class="number">0</span>]*size</span><br><span class="line">        self.hash_func = [hashlib.md5, hashlib.sha1, hashlib.sha224]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_data</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.hash_func:</span><br><span class="line">            index = <span class="built_in">int</span>(func(data.encode()).hexdigest(),<span class="number">16</span>) % self.size</span><br><span class="line">            self.arrarylist[index] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_data_exist</span>(<span class="params">self,data</span>):</span></span><br><span class="line">        result = <span class="number">1</span> <span class="comment">#起始位为1，如果为0，则肯定最终结果为0了。</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.hash_func:</span><br><span class="line">            index = <span class="built_in">int</span>(func(data.encode()).hexdigest(),<span class="number">16</span>) % self.size</span><br><span class="line">            <span class="comment">#三个index对应value，&amp;操作为1，则返回true</span></span><br><span class="line">            result &amp;= self.arrarylist[index]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> result == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 调整bf_size大小，可以改变False positive的值</span></span><br><span class="line">    bf_size = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    bloom_filter = BloomFilter(bf_size)</span><br><span class="line"></span><br><span class="line">    arrarylist = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加数值0-99</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        bloom_filter.add_data(<span class="built_in">str</span>(i))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对100-999进行is_data_exist方法运算，若返回true，则count+1，计算False positive的值。</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">if</span> bloom_filter.is_data_exist(<span class="built_in">str</span>(i)):</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;False positive is &#123;0:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(count/<span class="built_in">len</span>(<span class="built_in">range</span>(<span class="number">100</span>,<span class="number">1000</span>))*<span class="number">100</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>refer</p>
<blockquote>
<p><a href="https://medium.com/@Kadai/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%A4%A7%E4%BE%BF%E7%95%B6-bloom-filter-58b0320a346d">https://medium.com/@Kadai/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%A4%A7%E4%BE%BF%E7%95%B6-bloom-filter-58b0320a346d</a><br><a href="https://hur.st/bloomfilter/?n=4000&amp;p=1.0E-7&amp;m=&amp;k=2">https://hur.st/bloomfilter/?n=4000&amp;p=1.0E-7&amp;m=&amp;k=2</a><br><a href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>带宽测试</title>
    <url>/2019/01/15/%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当时是想测试单台服务器，流量到某带宽值，cpu，内存，磁盘io的表现。<br>现在单说iperf和nc的简单使用。</p>
<a id="more"></a>

<h1 id="iperf"><a href="#iperf" class="headerlink" title="iperf"></a>iperf</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ol>
<li>server端启用<code>iperf -s</code></li>
<li>client端连接server端，默认端口是<code>5001</code>,<code>iperf -c $&#123;server_ip&#125; $&#123;port&#125;</code></li>
</ol>
<p>server端：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">[root@SCA-LX5700025 ~]# iperf -s</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Server listening on TCP port 5001</span><br><span class="line">TCP window size: 85.3 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  4] local 10.8.199.17 port 5001 connected with 10.8.199.18 port 38008</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  4]  0.0-10.0 sec  1.13 GBytes   971 Mbits/sec</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client端：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">[root@SCA-LX5700026 ~]# iperf  -c 10.8.199.17 -p 5001</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to 10.8.199.17, TCP port 5001</span><br><span class="line">TCP window size: 85.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  3] local 10.8.199.18 port 38008 connected with 10.8.199.17 port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  3]  0.0-10.0 sec  1.13 GBytes   973 Mbits/sec</span><br></pre></td></tr></table></figure>
<p><strong>出来的结果直接是带宽，比如上面的是趋近于1000M带宽。</strong></p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>没有研究太多参数，更多参数可以<code>-h</code>查看。</p>
<ul>
<li>-b 指定带宽<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">[root@SCA-LX5700026 ~]# iperf  -c 10.8.199.17 -p 5001 -b 500M</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to 10.8.199.17, TCP port 5001</span><br><span class="line">TCP window size: 85.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  3] local 10.8.199.18 port 38010 connected with 10.8.199.17 port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  3]  0.0-10.0 sec   625 MBytes   524 Mbits/sec</span><br></pre></td></tr></table></figure>
<h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1></li>
</ul>
<h2 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h2><ol>
<li>server端启用<code>nc -vvlnp $&#123;server_port&#125; &gt;/dev/null</code>，或者<code>-4</code>指定只使用ipv4的方式。</li>
<li>client端连接<code>dd if=/dev/zero bs=1M count=1K | nc  $&#123;server_ip&#125; $&#123;server_port&#125;</code>，命令测试的是1G文件的下载速度。</li>
</ol>
<p>server端：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">[root@SCA-LX5700025 ~]# nc -vv4lnp <span class="number">5001</span> &gt;/dev/<span class="keyword">null</span></span><br><span class="line">Ncat: <span class="keyword">Version</span> <span class="number">7.50</span> ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening <span class="keyword">on</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">5001</span></span><br><span class="line">Ncat: <span class="keyword">Connection</span> <span class="keyword">from</span> <span class="number">10.8</span><span class="number">.199</span><span class="number">.18</span>.</span><br><span class="line">Ncat: <span class="keyword">Connection</span> <span class="keyword">from</span> <span class="number">10.8</span><span class="number">.199</span><span class="number">.18</span>:<span class="number">38410.</span></span><br><span class="line">NCAT <span class="keyword">DEBUG</span>: Closing fd <span class="number">4.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client端：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[root@SCA-LX5700026 ~]# dd <span class="attribute">if</span>=/dev/zero <span class="attribute">bs</span>=1M <span class="attribute">count</span>=1K | nc  10.8.199.17 5001</span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 8.7875 s, 122 MB/s</span><br></pre></td></tr></table></figure>
<p>refer:</p>
<blockquote>
<p><a href="https://askubuntu.com/questions/7976/how-do-you-test-the-network-speed-between-two-boxes">https://askubuntu.com/questions/7976/how-do-you-test-the-network-speed-between-two-boxes</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/09/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol>
<li>快速排序用到的是分治思想。</li>
<li>实现方法是，在序列中先确定一个比较值k，左边部分的值比k小，右边部分的值比k大，然后对左边和右边两部分继续获取各自的比较值k，依次递归，直到都排列完成，从而整个数列都变得有序。</li>
<li>退出条件是，左边增长的角标大于右边缩小的角标。</li>
<li><strong>如果选取的比较值k为最左边一个，则需要从右边优先开始比较；如果选取的比较值为k最右边第一个，则需要从左边优先开始比较。</strong></li>
</ol>
<a id="more"></a>

<h2 id="排序基本思路"><a href="#排序基本思路" class="headerlink" title="排序基本思路"></a>排序基本思路</h2><ol>
<li>给定一个数组，比如<code>[3，6，1，7，2，4，8]</code>。</li>
<li>先选定一个k，作为比较值，比如选取数组第一个数值，3，最左边作为比较值。</li>
<li><strong>从右边开始</strong>，同3比较，右边第一个数值8，因为8&gt;3,所以8不需要动，此时还是<code>[3，6，1，7，2，4，8]</code>。</li>
<li>接着比较倒数第二位4，4&gt;3，也不需要动，此时还是<code>[3，6，1，7，2，4，8]</code>。</li>
<li>接着倒数第三位2，2&lt;3，则将2放入3的位置，变成<code>[2,6,1,7,2,4,8]</code>，此时右边角标为4。</li>
<li>触发了右边的变换，所以这次开始从左边，2&lt;3，则不需要动，<code>[2,6,1,7,2,4,8]</code>。</li>
<li>左边继续走，第二个为6，6&gt;3，则需要变换<code>[2,6,1,7,6,4,8]</code>，此时左边角标为1</li>
<li>左边触发了交换，下面轮到右边，右边7，7&gt;3，不变，<code>[2,6,1,7,6,4,8]</code>。</li>
<li>右边继续，右边1，1&lt;3，则交换，变成<code>[2,1,1,7,6,4,8]</code>，此时右边角标为1。</li>
<li>轮到左边，左边继续，为1，依旧是<code>[2,1,1,7,6,4,8]</code>，此时左边角标为2。</li>
<li>继续轮到左边，此时左边发现自己角标大于右边角标，则停止，将k的值赋予当前左边角标，数组也就成了<code>[2,1,3,7,6,4,8]</code>。</li>
<li>之后出现左右两个子数组，继续递归，直到全部完成。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.jianshu.com/p/2b2f1f79984e">https://www.jianshu.com/p/2b2f1f79984e</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">quicklist = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def quick_sort(arr):</span><br><span class="line">    <span class="keyword">return</span> q_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">def q_sort(arr, <span class="keyword">left</span>, <span class="keyword">right</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span> &lt; righ<span class="variable">t:</span></span><br><span class="line">        pos = get_pos(arr,<span class="keyword">left</span>,<span class="keyword">right</span>)</span><br><span class="line">        # 递归左边排序，第一次<span class="keyword">left</span>为<span class="number">0</span>，pos-<span class="number">1</span>的值为get_pos排序一次后的pos位置左移一位。</span><br><span class="line">        q_sort(arr,<span class="keyword">left</span>,pos-<span class="number">1</span>)</span><br><span class="line">        # 递归右边排序，pos+<span class="number">1</span>的值为get_pos排序一次后的pos位置右移一位。</span><br><span class="line">        q_sort(arr,pos+<span class="number">1</span>,<span class="keyword">right</span>)</span><br><span class="line">    # 得到最终排序完的列表</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">def get_pos(arr,<span class="keyword">left</span>,<span class="keyword">right</span>):</span><br><span class="line">    # 左边第一位作为pos值</span><br><span class="line">    pos = arr[<span class="keyword">left</span>]</span><br><span class="line"></span><br><span class="line">    # 判断左右位置角标是否相遇</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">left</span> &lt; righ<span class="variable">t:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> <span class="built_in">and</span> arr[<span class="keyword">right</span>] &gt;= <span class="keyword">po</span><span class="variable">s:</span></span><br><span class="line">            # 右边角标缩小</span><br><span class="line">            <span class="keyword">right</span> -=<span class="number">1</span></span><br><span class="line">        # 将右边的换到左边</span><br><span class="line">        arr[<span class="keyword">left</span>] = arr[<span class="keyword">right</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> <span class="built_in">and</span> arr[<span class="keyword">left</span>] &lt;= <span class="keyword">po</span><span class="variable">s:</span></span><br><span class="line">            # 左边角标放大</span><br><span class="line">            <span class="keyword">left</span> +=<span class="number">1</span></span><br><span class="line">        # 将左边的换到右边</span><br><span class="line">        arr[<span class="keyword">right</span>] = arr[<span class="keyword">left</span>]</span><br><span class="line">    # 当左边和右边位置碰到的时候，让此时左边的位置成为pos值，因为pos值当时是被抠出来的。</span><br><span class="line">    arr[<span class="keyword">left</span>] = pos</span><br><span class="line">    # 获取此时的<span class="keyword">left</span>位置</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(quick_sort(quicklist))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(N2)，它的平均时间复杂度为 O(NlogN)。</p>
<p>refer</p>
<blockquote>
<p><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html</a><br><a href="https://www.jianshu.com/p/2b2f1f79984e">https://www.jianshu.com/p/2b2f1f79984e</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>新式类的C3 MRO理解</title>
    <url>/2018/12/20/%E6%96%B0%E5%BC%8F%E7%B1%BB%E7%9A%84C3-MRO%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="新式类"><a href="#新式类" class="headerlink" title="新式类"></a>新式类</h2><p><strong>python2.3以及之后的版本遵循的原则：C3 MRO</strong></p>
<p>其遵循的原则为：<br><code>一个类同时继承的类中，如果没有共同父类，则往最左的类的父类查询；如果存在共同父类，则从左到右查询。</code></p>
<a id="more"></a>

<p>自省方法<code>__mro__</code></p>
<h2 id="存在共同父类的情况"><a href="#存在共同父类的情况" class="headerlink" title="存在共同父类的情况"></a>存在共同父类的情况</h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">D</span>(<span class="title">object</span>): pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">E</span>(<span class="title">object</span>): pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">F</span>(<span class="title">object</span>): pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">B</span>(<span class="type">D</span>, <span class="type">E</span>): pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">C</span>(<span class="type">D</span>, <span class="type">F</span>): pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">A</span>(<span class="type">B</span>, <span class="type">C</span>): pass</span></span><br><span class="line"><span class="class">print(<span class="type">A</span>.<span class="title">__mro__</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">(&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="type">A</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="type">B</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="type">C</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="type">D</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="type">E</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="type">F</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object&#x27;</span>&gt;)</span></span><br></pre></td></tr></table></figure>
<p>顺序解释:<br><strong>这边需要注意的是B和C有相同的父类，所以B查询后直接查询的C。</strong></p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">查询关系</span><br><span class="line"><span class="built_in">D</span> <span class="operator">--&gt;</span> <span class="built_in">D</span><span class="operator">,</span><span class="variable">object</span></span><br><span class="line"><span class="built_in">E</span> <span class="operator">--&gt;</span> <span class="built_in">E</span><span class="operator">,</span><span class="variable">object</span></span><br><span class="line"><span class="variable">F</span> <span class="operator">--&gt;</span> <span class="variable">F</span><span class="operator">,</span><span class="variable">object</span></span><br><span class="line"></span><br><span class="line"><span class="variable">B</span> <span class="operator">--&gt;</span> <span class="variable">B</span><span class="operator">,</span> <span class="built_in">D</span><span class="operator">,</span> <span class="built_in">E</span><span class="operator">,</span> <span class="operator">....,</span> <span class="variable">object</span></span><br><span class="line"><span class="built_in">C</span> <span class="operator">--&gt;</span> <span class="built_in">C</span><span class="operator">,</span> <span class="built_in">D</span><span class="operator">,</span> <span class="variable">F</span><span class="operator">,</span> <span class="operator">....,</span> <span class="variable">object</span></span><br><span class="line"><span class="variable">A</span> <span class="operator">--&gt;</span> <span class="variable">A</span><span class="operator">.</span> <span class="variable">B</span><span class="operator">,</span> <span class="built_in">C</span><span class="operator">,</span> <span class="operator">....,</span> <span class="variable">object</span></span><br><span class="line">  将<span class="variable">B</span>和<span class="built_in">C</span>带入后得到</span><br><span class="line">  <span class="operator">--&gt;</span> <span class="variable">A</span><span class="operator">,</span> <span class="punctuation">(</span><span class="variable">B</span><span class="operator">,</span> <span class="built_in">D</span><span class="operator">,</span> <span class="built_in">E</span><span class="operator">,</span> <span class="operator">...,</span> <span class="variable">object</span><span class="punctuation">)</span><span class="operator">,</span> <span class="punctuation">(</span><span class="built_in">C</span><span class="operator">,</span><span class="built_in">D</span><span class="operator">,</span><span class="variable">F</span><span class="operator">,</span> <span class="operator">...,</span> <span class="variable">object</span><span class="punctuation">)</span></span><br><span class="line">  <span class="variable">B</span>和<span class="built_in">C</span>存在共同的父类，<span class="built_in">D</span>，所以<span class="variable">B</span>和<span class="built_in">C</span>是同一级别，查询顺序是<span class="variable">A</span><span class="operator">,</span> <span class="variable">B</span><span class="operator">,</span> <span class="built_in">C</span><span class="operator">,</span> 然后<span class="built_in">D</span><span class="operator">,</span></span><br><span class="line">  <span class="operator">--&gt;</span> <span class="variable">A</span><span class="operator">,</span> <span class="variable">B</span><span class="operator">,</span> <span class="built_in">C</span><span class="operator">,</span> <span class="built_in">D</span> <span class="punctuation">(</span><span class="built_in">E</span><span class="operator">,</span> <span class="operator">...,</span> <span class="variable">object</span><span class="punctuation">)</span><span class="operator">,</span> <span class="punctuation">(</span><span class="variable">F</span><span class="operator">,</span> <span class="operator">...,</span> <span class="variable">object</span><span class="punctuation">)</span> </span><br><span class="line">  <span class="operator">--&gt;</span> <span class="variable">A</span><span class="operator">,</span> <span class="variable">B</span><span class="operator">,</span> <span class="built_in">C</span><span class="operator">,</span> <span class="built_in">D</span><span class="operator">,</span> <span class="built_in">E</span><span class="operator">,</span> <span class="variable">F</span><span class="operator">,</span> <span class="variable">object</span></span><br></pre></td></tr></table></figure>
<h2 id="不存在共同父类的情况"><a href="#不存在共同父类的情况" class="headerlink" title="不存在共同父类的情况"></a>不存在共同父类的情况</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> g(<span class="keyword">object</span>): pass</span><br><span class="line"><span class="keyword">class</span> f(<span class="keyword">object</span>): pass</span><br><span class="line"><span class="keyword">class</span> h(<span class="keyword">object</span>): pass</span><br><span class="line"><span class="keyword">class</span> i(<span class="keyword">object</span>): pass</span><br><span class="line"><span class="keyword">class</span> e(<span class="keyword">object</span>): pass</span><br><span class="line"><span class="keyword">class</span> d(h,i): pass</span><br><span class="line"><span class="keyword">class</span> b(d,e): pass</span><br><span class="line"><span class="keyword">class</span> c(f,g): pass</span><br><span class="line"><span class="keyword">class</span> a(b,c): pass</span><br><span class="line">print(a.__mro__)</span><br><span class="line"></span><br><span class="line">(&lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>a&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>b&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>d&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>h&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>i&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>e&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>c&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>f&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="module-access"><span class="module"><span class="identifier">__main__</span>.</span></span>g&#x27;&gt;, &lt;<span class="keyword">class</span> &#x27;<span class="keyword">object</span>&#x27;&gt;)</span><br></pre></td></tr></table></figure>
<p>顺序解释：<br><strong>因为b和c不存在相同的父类，所以查询b查不到后直接查询b的父类。</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">查询关系：</span><br><span class="line">g --&gt; g, <span class="keyword">object</span></span><br><span class="line">f --&gt; f, <span class="keyword">object</span></span><br><span class="line">h --&gt; h, <span class="keyword">object</span></span><br><span class="line">i --&gt; i, <span class="keyword">object</span></span><br><span class="line">e --&gt; e, <span class="keyword">object</span></span><br><span class="line"></span><br><span class="line">b --&gt; b, d, e, ..., <span class="keyword">object</span></span><br><span class="line">c --&gt; c, f, g, ..., <span class="keyword">object</span></span><br><span class="line">d --&gt; d, h, i, ..., <span class="keyword">object</span></span><br><span class="line"></span><br><span class="line">a --&gt; a, b, c, ..., <span class="keyword">object</span></span><br><span class="line">  将<span class="type">B</span>和<span class="type">C</span>带入后得到</span><br><span class="line">  --&gt; a, (b, d, e, ..., <span class="keyword">object</span>), (c, f, g, ..., <span class="keyword">object</span>)</span><br><span class="line">  将b带入后得到</span><br><span class="line">  --&gt; a, (b, (d, h, i, ..., <span class="keyword">object</span>), e, ..., <span class="keyword">object</span>), (c, f, g, ..., <span class="keyword">object</span>)</span><br><span class="line">  b和c没有共同的父类，所以直接查询了d，d后，查询他的继承，h，因为h最顶了，所以开始依次返回，查询其平级的i，然后折回到b中右边的e,然后再次返回到a中右边的c，然后查询c中的f,发现到顶了，则查询其平级的g，然后依次退出，发现直接查询完了全部，则查询<span class="keyword">object</span>。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>是地址引用还是赋值操作</title>
    <url>/2019/01/17/%E6%98%AF%E5%9C%B0%E5%9D%80%E5%BC%95%E7%94%A8%E8%BF%98%E6%98%AF%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p><strong>凡是基本类型，都是赋值。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">c = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p><strong>若是复合类型，都是地址指向。</strong></p>
<p><strong>函数和类的赋值也是地址指向</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">b</span> = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">c</span> = 函数，类</span><br></pre></td></tr></table></figure>
<h2 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h2><p><strong>直接用id()看地址引用，如果原始对象改变后，其id()和赋值对象的id()不再一致，则为赋值，反之则是引用。</strong> </p>
<ul>
<li><p>验证基本类型：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a = <span class="number">3</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">b = a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(a)</span></span><br><span class="line">9413248</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(b)</span></span><br><span class="line">9413248</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a = <span class="number">4</span></span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(a)</span></span><br><span class="line">9413280</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(b)</span></span><br><span class="line">9413248</span><br></pre></td></tr></table></figure>
<p>给a第二次更变赋值为4后，b的id()和a的id()不同，所以是赋值</p>
</li>
<li><p>验证复合类型：</p>
<figure class="highlight python-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">b = a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">b</span></span><br><span class="line">[1, 2, 3]</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(a)</span></span><br><span class="line">140435242878376</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(b)</span></span><br><span class="line">140435242878376</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">a.append(<span class="number">1</span>)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(a)</span></span><br><span class="line">140435242878376</span><br><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python"><span class="built_in">id</span>(b)</span></span><br><span class="line">140435242878376</span><br></pre></td></tr></table></figure>
<p>给a第二次更变赋值为4后，b的id()和a的id()相同，所以是地址引用。下面的类的例子也能看出是地址引用。</p>
</li>
</ul>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">class</span> <span class="function"><span class="title">A</span>(<span class="variable"><span class="class">object</span></span>):</span></span><br><span class="line"><span class="function">    <span class="variable">def</span> <span class="title">test</span>(<span class="variable">self</span>):</span></span><br><span class="line"><span class="function">        <span class="variable">pass</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="variable">a</span> = <span class="title">A</span>()</span></span><br><span class="line"><span class="variable">b</span> = <span class="variable">a</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">id</span>(<span class="variable">a</span>))</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">id</span>(<span class="variable">b</span>))</span></span><br><span class="line"><span class="variable">a.value</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">id</span>(<span class="variable">a</span>))</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="variable">b.value</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">140233133844240</span></span><br><span class="line"><span class="number">140233133844240</span></span><br><span class="line"><span class="number">140233133844240</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>未配置中间证书CA引起的安卓端无法通过https建联加载图片案例</title>
    <url>/2019/01/06/%E6%9C%AA%E9%85%8D%E7%BD%AE%E4%B8%AD%E9%97%B4%E8%AF%81%E4%B9%A6CA%E5%BC%95%E8%B5%B7%E7%9A%84%E5%AE%89%E5%8D%93%E7%AB%AF%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87https%E5%BB%BA%E8%81%94%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>安卓同事称代码调试访问test-material.aaa.tv/xxx/xxxx.png等图片资源的时候报错，报错信息类似如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path not found.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>查看了安卓的开放文档，出现该报错主要由一下三种情况发生：</p>
<ol>
<li><a href="https://developer.android.google.cn/training/articles/security-ssl#UnknownCa">颁发服务器证书的 CA 未知</a>。</li>
<li><a href="https://developer.android.google.cn/training/articles/security-ssl#SelfSigned">服务器证书不是由 CA 签署的，而是自签署</a>。</li>
<li><a href="https://developer.android.google.cn/training/articles/security-ssl#MissingCa">服务器配置缺少中间 CA</a>。</li>
</ol>
<p>首先排除第一点和第二点，证书是购买的赛门铁克。</p>
<p>然后去<a href="https://www.ssllabs.com/ssltest/">ssllabs</a>网站测试<code>test-material.aaa.tv</code>域名支持的https建联加密方式<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1fywswiz7etj21ia0iiabj.jpg"></p>
<p>起先怀疑是安卓可能使用了SSL3的加密方式进行https简练握手，后来确认安卓使用版本之后排除了该情况。</p>
<p>接着使用浏览器访问资源查看发现存在中间CA证书，但用域名检测网站的时候提示不含中间CA证书。于是乎又抓了一个安卓端可以显示的图片的域名来测试，在测试网站上也是属于不包含中间CA证书的情况。</p>
<p>两者的区别是，无法建联的域名是阿里云上的，能建联显示图片的域名是腾讯云上的。</p>
<p>当时很纳闷，后来查阅资料得知不同软件或者设备会有不同的行为，有些即便不存在中间CA也会帮忙代理查找。</p>
<p>安卓(其他苹果设备应该也是如此)自身会信任一些根证书，可能安卓去“解析”test-material.aaa.tv这个域名的时候得到的根证书，并不在信任证书里面，从而导致https建联失败。</p>
<p>于是发现安卓的确是存在信任一些列证书的情况：<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1fywt2cigk2j20f00qoam5.jpg"></p>
<p>然后来获取下test-material.aaa.tv的根证书情况，自然，在浏览器端获取到的可能是浏览器帮助代理请求获得的。得在服务器端用命令去查看，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect test-material.aaa.tv:443 -servername test-material.aaa.tv</span><br></pre></td></tr></table></figure>
<p><strong>-connect 检测的域名，后面跟随ssl端口号</strong><br><strong>-servername 指定SNI(Server Name Indication)，因为可能存在多个域名对应一张证书的情况，比如买的证书是一级域名和二级域名都可以使用这种情况，那么需要指定具体的域名。</strong></p>
<p>SNI (Server Name Indication)是用来改善服务器与客户端 SSL (Secure Socket Layer)和 TLS (Transport Layer Security) 的一个扩展。主要解决一台服务器只能使用一个证书(一个域名)的缺点，随着服务器对虚拟主机的支持，一个服务器上可以为多个域名提供服务，因此SNI必须得到支持才能满足需求。</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3gy1fywt3e8uucj21yw0dk7h4.jpg"><br><em>上图已经修复问题，修复之前只有条目0，不包含条目1。</em></p>
<ul>
<li>红框信息：</li>
</ul>
<ol>
<li>起始证书是C=CN/L=xxxxx(后面一大串)，然后C=CN/L=xxxxx(后面一大串)这个证书又是由GeoTrust Inc./CN=GeoTrust SSL CA - G3颁发。</li>
</ol>
<ul>
<li>修复问题之前只有条目0,没有条目1，然后在安卓信任证书列表里面查不到关于信任GeoTrust Inc./CN=GeoTrust SSL CA - G3这个证书的条目。所以建联无法通过了。</li>
</ul>
<ol start="2">
<li>GeoTrust SSL CA - G3又是由Geo Trust Inc./CN=Geo Trust Global CA颁发。</li>
</ol>
<p><strong>修复问题之后可以在安卓端信任列表里面查到存在Geo Trust Global CA证书条目，所以建联成功了。</strong></p>
<h2 id="问题解决方法："><a href="#问题解决方法：" class="headerlink" title="问题解决方法："></a>问题解决方法：</h2><p>中间证书CA没配置导致，上阿里云后台，查看该域名对应的证书，发现的确只有本机CA证书，没有配置中间证书CA，重新配置上后，问题解决，安卓端建联正常。</p>
<p>refer:</p>
<blockquote>
<p><a href="https://developer.android.google.cn/training/articles/security-ssl.html#MissingCa">https://developer.android.google.cn/training/articles/security-ssl.html#MissingCa</a><br><a href="http://blog.csdn.net/makenothing/article/details/53292335">http://blog.csdn.net/makenothing/article/details/53292335</a></p>
</blockquote>
<p>证书检测地址:</p>
<blockquote>
<p><a href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a></p>
</blockquote>
<h2 id="安卓文档对于缺失中间证书的描述"><a href="#安卓文档对于缺失中间证书的描述" class="headerlink" title="安卓文档对于缺失中间证书的描述:"></a>安卓文档对于缺失中间证书的描述:</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">有趣的是，在大多数桌面浏览器中访问此服务器不会引发完全未知的 <span class="keyword">CA</span> 或自签署服务器证书所引发的类似错误。这是因为大多数桌面浏览器都会将可信的中间 <span class="keyword">CA</span> 缓存一段时间。当浏览器从某个网站访问和了解中间 <span class="keyword">CA</span> 后，下次它就不需要将中间 <span class="keyword">CA</span> 添加在证书链中。</span><br><span class="line"></span><br><span class="line">有些网站会专门为提供资源的辅助网络服务器这样做。例如，他们可能让具有完整证书链的服务器提供主 HTML 页面，让不包含 <span class="keyword">CA</span> 的服务器提供图像、CSS 或 JavaScript 等资源，以节省带宽。遗憾的是，这些服务器有时候可能会提供您正在尝试从 Android 应用调用的网络服务，这一点让人难以接受。</span><br><span class="line"></span><br><span class="line">可以通过两种方法解决此问题：</span><br><span class="line"></span><br><span class="line">配置服务器以便在服务器链中添加中间 <span class="keyword">CA</span>。大多数 <span class="keyword">CA</span> 都可以提供有关如何为所有常用网络服务器执行此操作的文档。如果您需要网站至少通过 Android 4.2 使用默认 Android 浏览器，那么这是唯一的方法。</span><br><span class="line">或者，像对待其他任何未知 <span class="keyword">CA</span> 一样对待中间 <span class="keyword">CA</span>，并创建一个 TrustManager 以直接信任它，如前面的两部分中所述。</span><br></pre></td></tr></table></figure>




<h2 id="查看证书到期时间："><a href="#查看证书到期时间：" class="headerlink" title="查看证书到期时间："></a>查看证书到期时间：</h2><p>openssl s_client -connect <a href="http://www.icoinbay.com:443/">www.icoinbay.com:443</a> -servername <a href="http://www.icoinbay.com/">www.icoinbay.com</a> 2&gt;/dev/null |openssl x509 -noout -dates </p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘无法挂载</title>
    <url>/2019/01/18/%E7%A3%81%E7%9B%98%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>今天一机器的磁盘掉了，机房更换了硬盘。看了下前人都是写在<code>/etc/fstab</code>里面，个人不推荐写这里，写入<code>/etc/rc.local</code>更加好</p>
<p>然后修改了/etc/fstab，然后mount -a挂载，没报错，df -h没看到挂上去的盘，很奇怪。</p>
<a id="more"></a>

<p>查看了下message日志：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Jan</span> <span class="number">18</span> <span class="number">14</span>:<span class="number">55</span>:<span class="number">55</span> SH-HDP<span class="number">1136</span> systemd: Unmounted /mnt/disk<span class="number">4</span>.</span><br><span class="line"><span class="attribute">Jan</span> <span class="number">18</span> <span class="number">14</span>:<span class="number">55</span>:<span class="number">55</span> SH-HDP<span class="number">1136</span> systemd: Unit mnt-disk<span class="number">4</span>.mount entered failed state.</span><br><span class="line"><span class="attribute">Jan</span> <span class="number">18</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">41</span> SH-HDP<span class="number">1136</span> kernel: XFS (sdd): Mounting V<span class="number">5</span> Filesystem</span><br><span class="line"><span class="attribute">Jan</span> <span class="number">18</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">41</span> SH-HDP<span class="number">1136</span> kernel: XFS (sdd): Ending clean mount</span><br><span class="line"><span class="attribute">Jan</span> <span class="number">18</span> <span class="number">14</span>:<span class="number">56</span>:<span class="number">41</span> SH-HDP<span class="number">1136</span> systemd: Unit mnt-disk<span class="number">4</span>.mount is bound to inactive unit dev-disk-by\x<span class="number">2</span>duuid-<span class="number">5</span>aad<span class="number">6483</span>\x<span class="number">2</span>de<span class="number">21</span>f\x<span class="number">2</span>d<span class="number">498</span>d\x<span class="number">2</span>d<span class="number">9</span>c<span class="number">8</span>c\x<span class="number">2</span>dfeff<span class="number">9</span>fd<span class="number">5</span>be<span class="number">76</span>.device. Stopping, too.</span><br></pre></td></tr></table></figure>
<p>最后一行谷歌查了下文档，第一篇文档说是用了<code>重启大法</code>。因为服务器比较重要，没考虑重启。</p>
<p>然后找到第二篇文档，说执行<code>systemctl-reload</code>，然后进行挂载。</p>
<p>尝试了下，的确成功了。</p>
<h2 id="诡异的systemctl-reload"><a href="#诡异的systemctl-reload" class="headerlink" title="诡异的systemctl-reload"></a>诡异的systemctl-reload</h2><p>但心里很纳闷，我修改个/etc/fstab和systemctl-reload有半毛钱关系，继续查了下谷歌，发现这是一个redhat7.4的bug。。。。。</p>
<p>Bug ID: 1566088</p>
<p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1566088">https://bugzilla.redhat.com/show_bug.cgi?id=1566088</a></p>
<p>refer:</p>
<blockquote>
<p><a href="http://mamchenkov.net/wordpress/2017/11/09/systemd-strikes-again-unit-var-whatever-mount-is-bound-to-inactive-unit/">http://mamchenkov.net/wordpress/2017/11/09/systemd-strikes-again-unit-var-whatever-mount-is-bound-to-inactive-unit/</a><br><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1566088">https://bugzilla.redhat.com/show_bug.cgi?id=1566088</a></p>
</blockquote>
]]></content>
      <categories>
        <category>system</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏数组(go语言实现)</title>
    <url>/2020/06/08/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="稀疏数组使用场景"><a href="#稀疏数组使用场景" class="headerlink" title="稀疏数组使用场景"></a>稀疏数组使用场景</h2><p>当一个二维数组的大部分元素为0，或者为相同值时，可以使用稀疏数组来<strong>压缩保存</strong>该二维数组。</p>
<h2 id="稀疏数组处理方法"><a href="#稀疏数组处理方法" class="headerlink" title="稀疏数组处理方法"></a>稀疏数组处理方法</h2><ol>
<li>稀疏数组一般n行，3列，第一列表示原先二维数组的行，第二列表示原先二维数组的列，第三列表示值。</li>
<li>稀疏数组的第一行，一般用来表示原先二维数组的总行数以及总列数，值可以定义一个原先二维数组中不可能产生的值，比如-1,0。</li>
</ol>
<a id="more"></a>

<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1gfknynjddkj21120hcq4m.jpg" alt="稀疏数组.png"></p>
<ol>
<li>原二维数组看做棋盘，白子为1，黑子为2。</li>
<li>稀疏数组第一行表示了”棋盘大小”为*<em>7</em>7**，值为0，该值只是用于甄别其他有效值。</li>
<li>稀疏数组第二行至第四行表示了”棋盘”内白子黑子的分布，顺序为从上到下，从左到右。</li>
<li>可以将行和列看为x轴和y轴。</li>
</ol>
<h3 id="二维数组矩阵用稀疏数组表示-go语言思路"><a href="#二维数组矩阵用稀疏数组表示-go语言思路" class="headerlink" title="二维数组矩阵用稀疏数组表示(go语言思路)"></a>二维数组矩阵用稀疏数组表示(go语言思路)</h3><ol>
<li>每一个棋子有三个属性，<strong>x轴坐标</strong>，<strong>y轴坐标</strong>，<strong>颜色</strong>。一个棋子的属性可以用结构体来表示。</li>
<li>稀疏数组由于存在长度不确定性，所以使用切片的方式来表示。</li>
<li>稀疏数组的第一个元素围棋盘布局。</li>
</ol>
<h3 id="go代码对二维数组压缩保存为稀疏数组"><a href="#go代码对二维数组压缩保存为稀疏数组" class="headerlink" title="go代码对二维数组压缩保存为稀疏数组"></a>go代码对二维数组压缩保存为稀疏数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个7*7的二维数组, 将黑子白子进行赋值.</span></span><br><span class="line">	<span class="keyword">var</span> chessMap [<span class="number">7</span>][<span class="number">7</span>]<span class="keyword">int</span></span><br><span class="line">	chessMap[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	chessMap[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">	chessMap[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">	chessMap[<span class="number">5</span>][<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印原始数据</span></span><br><span class="line">	<span class="keyword">for</span> _,v := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> _,v2 := <span class="keyword">range</span> v &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,v2)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用稀疏数组表示</span></span><br><span class="line">	<span class="comment">/* 每一个棋子都有三个属性</span></span><br><span class="line"><span class="comment">		1. x轴位置</span></span><br><span class="line"><span class="comment">		2. y轴位置</span></span><br><span class="line"><span class="comment">		3. 棋子颜色</span></span><br><span class="line"><span class="comment">		这三个属性可以使用结构体来表示</span></span><br><span class="line"><span class="comment">		然后将结构体依次append进数组中, 就可以作为一个稀疏数组了.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 定义一个存放棋子属性的结构体</span></span><br><span class="line">	 <span class="keyword">type</span> chess <span class="keyword">struct</span> &#123;</span><br><span class="line">	 	axisX <span class="keyword">int</span></span><br><span class="line">	 	axisY <span class="keyword">int</span></span><br><span class="line">	 	value <span class="keyword">int</span></span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 定义一个存放棋子结构体的切片</span></span><br><span class="line">	 <span class="keyword">var</span> chessSparseMap []chess</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// chessSparseMap稀疏数组第一行定义x,y和value</span></span><br><span class="line">	 firstLine := chess&#123;</span><br><span class="line">	 	axisX: <span class="number">7</span>,</span><br><span class="line">	 	axisY: <span class="number">7</span>,</span><br><span class="line">	 	value: <span class="number">0</span>,</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 chessSparseMap = <span class="built_in">append</span>(chessSparseMap, firstLine)</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 对原始数据进行遍历, 然后将获取到有数值内容的值,存储到chess结构体中, 并且将该结构体append到chessSparseMap里面.</span></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> k2,v2 := <span class="keyword">range</span> v &#123;</span><br><span class="line">			<span class="keyword">if</span> v2 != <span class="number">0</span> &#123;</span><br><span class="line">				tmpChess := chess&#123;</span><br><span class="line">					axisX:k,</span><br><span class="line">					axisY:k2,</span><br><span class="line">					value:v2,</span><br><span class="line">				&#125;</span><br><span class="line">				chessSparseMap = <span class="built_in">append</span>(chessSparseMap, tmpChess)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;稀疏数组为&quot;</span>)</span><br><span class="line">	fmt.Println(chessSparseMap)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line">稀疏数组为</span><br><span class="line">[&#123;<span class="number">7</span> <span class="number">7</span> <span class="number">0</span>&#125; &#123;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>&#125; &#123;<span class="number">2</span> <span class="number">2</span> <span class="number">2</span>&#125; &#123;<span class="number">2</span> <span class="number">4</span> <span class="number">1</span>&#125; &#123;<span class="number">5</span> <span class="number">3</span> <span class="number">2</span>&#125;]</span><br></pre></td></tr></table></figure>




<h3 id="稀疏数组还原为二维数组"><a href="#稀疏数组还原为二维数组" class="headerlink" title="稀疏数组还原为二维数组"></a>稀疏数组还原为二维数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义单个棋子的属性, x, y, value</span></span><br><span class="line">	<span class="keyword">type</span> chess <span class="keyword">struct</span> &#123;</span><br><span class="line">		axisX <span class="keyword">int</span></span><br><span class="line">		axisY <span class="keyword">int</span></span><br><span class="line">		value <span class="keyword">int</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个7*7数组</span></span><br><span class="line">	<span class="keyword">var</span> chessMap [<span class="number">7</span>][<span class="number">7</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取sparseMap文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;./learn-go/数据结构/1.稀疏数组/sparseMap&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;打开异常&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		content, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;内容读取完毕&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		contentSlice := strings.Split(content,<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">		axisX, err := strconv.Atoi(contentSlice[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;axisX转换出错&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		axisY, err := strconv.Atoi(contentSlice[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;axisY转换出错&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// strings.Split(contentSlice[2], &quot;\r\n&quot;)[0] value结尾存在\n, 通过Split方法去除\r\n</span></span><br><span class="line">		value, err := strconv.Atoi(strings.Split(contentSlice[<span class="number">2</span>], <span class="string">&quot;\r\n&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;value转换出错&quot;</span>,err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> value != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// axisX为x轴, axisY为y轴, value为棋子, 1 白子, 2 黑子</span></span><br><span class="line">			chessMap[axisX][axisY] = value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _,v := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v2 :=<span class="keyword">range</span> v&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d \t&quot;</span>,v2)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	</span><br><span class="line"><span class="number">0</span> 	<span class="number">1</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	</span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">2</span> 	<span class="number">0</span> 	<span class="number">1</span> 	<span class="number">0</span> 	<span class="number">0</span> 	</span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	</span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	</span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">2</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	</span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> </span><br></pre></td></tr></table></figure>


<p><strong>sparseMap文件内容</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">7 </span><span class="number">7</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>go</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>编写自定义 django-admin 命令</title>
    <url>/2019/11/07/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89django_admin%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><em>我想在django中放一个脚本，然后循环执行他，该脚本会操作数据库，我懒得自己pymysql等方式写，就想用orm的方式，直接脚本中import models，但是呢，python xxxx执行后各种报错，说找不到环境变量，网上搜了下解决方案，也是差不多，但我就是没有调试出来。于是打算用django自带的方式执行命令。</em></p>
<a id="more"></a>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ol>
<li>在app中创建/management/commands目录</li>
<li>在commands目录里面创建py脚本</li>
</ol>
<p>例如我的app叫做gp_volume，则在这个路径下创建/management/commands，然后放了两个脚本，一个是page_manager.py，一个是test.py。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="string">-- admin.py</span></span><br><span class="line">|<span class="string">-- apps.py</span></span><br><span class="line">|<span class="string">-- __init__.py</span></span><br><span class="line">|<span class="string">-- management</span></span><br><span class="line">|<span class="string">   `-- commands</span></span><br><span class="line">|<span class="string">       </span>|<span class="string">-- page_manager.py</span></span><br><span class="line">|<span class="string">       </span>|<span class="string">-- __pycache__</span></span><br><span class="line">|<span class="string">       </span>|<span class="string">   </span>|<span class="string">-- page_manager.cpython-36.pyc</span></span><br><span class="line">|<span class="string">       </span>|<span class="string">   `-- test.cpython-36.pyc</span></span><br><span class="line">|<span class="string">       `-- test.py</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><ol>
<li>脚本代码需要封装在Command这个类里面，且继承BaseCommand类</li>
<li>对Command类的handle函数进行重写</li>
</ol>
<p>拿个page_manager.py举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.management.base <span class="keyword">import</span> BaseCommand, CommandError</span><br><span class="line"><span class="keyword">from</span> gp_volume.models <span class="keyword">import</span> Code, Volume, Page</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写Command类，并且继承BaseCommand</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">BaseCommand</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写handle函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self, *args, **options</span>):</span></span><br><span class="line">        code_list = Code.objects.<span class="built_in">filter</span>(status=<span class="string">&#x27;o&#x27;</span>, date=<span class="built_in">str</span>(datetime.date.today()))</span><br><span class="line">        <span class="keyword">for</span> code <span class="keyword">in</span> code_list:</span><br><span class="line">            print(code.code)</span><br></pre></td></tr></table></figure>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><ol>
<li>python3 manage.py ${script_name}</li>
</ol>
<p>例如跑page_manager.py，无需脚本后缀名</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python3</span> manager page_manager</span><br></pre></td></tr></table></figure>
<h2 id="传参给脚本"><a href="#传参给脚本" class="headerlink" title="传参给脚本"></a>传参给脚本</h2><ol>
<li>定义add_arguments方法</li>
<li>使用options[‘key’]获取传入的参数</li>
</ol>
<p>test.py例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.management.base <span class="keyword">import</span> BaseCommand, CommandError</span><br><span class="line"><span class="keyword">from</span> gp_volume.models <span class="keyword">import</span> Code, Volume, Page</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">BaseCommand</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_arguments</span>(<span class="params">self, parser</span>):</span></span><br><span class="line">        <span class="comment"># nargs=&#x27;+&#x27; 表示至少要有一个参数</span></span><br><span class="line">        parser.add_argument(<span class="string">&#x27;code_id&#x27;</span>, nargs=<span class="string">&#x27;+&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>)</span><br><span class="line">        parser.add_argument(</span><br><span class="line">            <span class="string">&#x27;--delete&#x27;</span>,</span><br><span class="line">            <span class="comment"># store_True表示参数如果不写，默认没有。</span></span><br><span class="line">            action=<span class="string">&#x27;store_True&#x27;</span>,</span><br><span class="line">            <span class="built_in">help</span>=<span class="string">&#x27;Delete poll instead of closing it&#x27;</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self, *args, **options</span>):</span></span><br><span class="line">        <span class="comment"># 判断是否存在delete参数</span></span><br><span class="line">        <span class="keyword">if</span> options[<span class="string">&#x27;delete&#x27;</span>]:</span><br><span class="line">            <span class="keyword">for</span> code <span class="keyword">in</span> options[<span class="string">&#x27;code_id&#x27;</span>]:</span><br><span class="line">                Code.objects.get(code=code).delete()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;no args&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python3</span> manage.<span class="keyword">py</span> test --<span class="keyword">delete</span> xxxxxxx</span><br></pre></td></tr></table></figure>
<p>refer</p>
<blockquote>
<p><a href="https://docs.djangoproject.com/en/2.2/howto/custom-management-commands/">https://docs.djangoproject.com/en/2.2/howto/custom-management-commands/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>网络tcp_udp协议</title>
    <url>/2019/07/29/%E7%BD%91%E7%BB%9Ctcp_udp%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h1><h2 id="http封装"><a href="#http封装" class="headerlink" title="http封装"></a>http封装</h2><p>Ethernet2(以太网2帧头) | IPV4 | TCP | HTTP | FCS(以太网2帧尾)</p>
<h2 id="tcp端口号"><a href="#tcp端口号" class="headerlink" title="tcp端口号"></a>tcp端口号</h2><ol>
<li>取值范围<ul>
<li>16bit 范围0-65535  0–2^16-1</li>
<li>1-1023 知名端口</li>
<li>1024-65535 非知名端口</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h2 id="tcp信道协议种类"><a href="#tcp信道协议种类" class="headerlink" title="tcp信道协议种类"></a>tcp信道协议种类</h2><ol>
<li>单信道协议:一个应用程序对应一个端口</li>
<li>多信道协议:一个应用程序对应多个端口，比如ftp,tcp20(控制端口)和tcp21(数据端口)</li>
</ol>
<p>tcp对带宽抢占率远低于udp</p>
<h2 id="tcp头部封装"><a href="#tcp头部封装" class="headerlink" title="tcp头部封装"></a>tcp头部封装</h2><p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5gziza7nxj20ks0e241r.jpg"></p>
<ol>
<li>tcp header 取值范围20Byte-60Byte。</li>
<li>header length，因为长度可变，该字段告诉接受者tcp报头长度。</li>
<li>Resv. 保留字段全部置0。</li>
<li>6个控制位，syn置1 则表示发送syn，也就是三次握手的第一个阶段。</li>
<li>URG，服务器一对多处理报文的时候，如果tcp URG置为1，则优先对这些数据进行处理。</li>
<li>只有当需要对tcp启用高级功能的到时候，才需要添加options可选项</li>
<li>padding是因为三层包头和四层包头大小都必须被4整除，所以当options选项被使用的时候，无法被4整除的时候，对padding进行用连续的0填充，填充到可以被4整除</li>
<li>ergent pointer 紧急指针配合URG位，让多股tcp应用，哪一股被优先处理</li>
</ol>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5gzqxjim2j20os0iateh.jpg"></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5gzpoe43aj20pa0i6n36.jpg"></p>
<h2 id="面向连接协议"><a href="#面向连接协议" class="headerlink" title="面向连接协议:"></a>面向连接协议:</h2><ol>
<li>流量控制<ul>
<li>限速，(源末两端接受带宽不一致，如果源端带宽大，全速发送给接收端，则接收端会产生拥塞。) 在发送数据之前进行协商速率，通过windown字段(单位字节，Byte)进行协商,比如协商为100字节，则源端发送100字节数据给接收端，接收端收到后，返回一个确认给源端，如果没确认，则表示数据丢失，需要数据重传。窗口不是固定不变，在每次发送流量之前都会进行windown协商。<br>带宽大的时候，窗口经过协商会变大，直到占用链路最大字节的时候，又会控制窗口大小，防止拥塞发生，这种行为称之为滑动窗口。 </li>
<li>tcp延迟启动(slow start) 第一次协商为1 字节， 第二次为2字节 第n次为2^(n-1)次方,(下载的时候先比较小，然后逐渐变大)</li>
<li>全局同步问题：slow start 窗口逐渐变大，当超出阈值带宽的时候，会减半，然后又逐渐变大，触发阈值再减半，依次循环。其带宽利用是一个折线。平均带宽利用不会百分百打满。当存在大量tcp应用的时候，此时这些应用一起发送数据的时候，就会出现全局同步的问题，大家都在利用带宽，发现不足了，瞬间减半窗口。</li>
<li>滑动窗口的协商发生在接收方回复syn-ack的时候。</li>
</ul>
</li>
<li>防乱序<ul>
<li>处理延迟，串行化延迟，传输延迟，队列延迟</li>
<li>队列延迟，导致源给目的地发送多个数据，导致乱序—-抖动。</li>
<li>通过squence number来标记数据包，进行顺序接受。</li>
</ul>
</li>
<li>防丢包<ul>
<li>acknowlegde number中包含一个确认号，确认号的值通常为发送方发送的最大序列号值加1。比如发送方发送 1 2 3 ，则接收方发送确认号4，发送方知道4后，接着发送4 5 6。如果接收方只收到了4 5 ，则其返回确认号为6，那么发送方发现接收方漏了6，则对6进行重发。 如果发送方只收到了4，返回了确认号5， 那么发送方会对 5 6 都重发。</li>
</ul>
</li>
<li>完整性检查<ul>
<li>根据接收到的数据跟tcp中的checksum字段比较。因为并不是HMAC的方式，所以无法检测数据是否被篡改，只能检测流量在发送的时候是否因为拥塞导致冲突。</li>
</ul>
</li>
<li>数据重传<ul>
<li>根据发送方发来的确认号，以及发送过去的序列号，对比查看是否需要重传。</li>
</ul>
</li>
</ol>
<h2 id="tcp注意点"><a href="#tcp注意点" class="headerlink" title="tcp注意点"></a>tcp注意点</h2><ol>
<li><p>tcp只支持单播(unicast)数据的发送,如果用了tcp，则无法组播或者广播。相对udp不够灵活，udp支持单播 组播 广播。</p>
</li>
<li><p>完全连接，完成三次握手。</p>
</li>
<li><p>半开连接，发送端未发送最后一次ack的连接，接收端不会自动断开，会默认被保持，且消耗服务器内存和cpu。</p>
</li>
</ol>
<h1 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h1><p><strong>面向无连接，不可靠传输</strong></p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5gzpv5go7j20ta0a2whd.jpg"></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>ip header | udp header | data</p>
<h2 id="udp头部报文"><a href="#udp头部报文" class="headerlink" title="udp头部报文"></a>udp头部报文</h2><p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5gznh8e5jj20ta0a2whd.jpg"></p>
<ol>
<li><p>udp头部占用8字节，传输时候没有确认机制。</p>
</li>
<li><p>udp主持组播和广播</p>
</li>
<li><p>媒体流量基本用udp封装，所以媒体对序列的要求，则封装一个rtp(实时传输协议)的包头，其squence 为12字节，保证源末报文可以根据序列进行重组。 ethernet2 | udp | rtp | VoIP | FCS</p>
</li>
</ol>
<h1 id="tcp-udp对比"><a href="#tcp-udp对比" class="headerlink" title="tcp udp对比"></a>tcp udp对比</h1><ol>
<li>可靠 tcp强</li>
<li>安全 udp强  tcp 三次握手容易被攻击</li>
<li>带宽利用   udp利用高  tcp存在全局同步的问题，解决办法 QoS WRED加权随机早期检测</li>
<li>应用灵活   tcp只支持单播，udp更加灵活</li>
<li>不用支持重传的服务  VoIP 用udp</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>自建Kubernetes集群创建SLB</title>
    <url>/2021/08/26/%E8%87%AA%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E5%88%9B%E5%BB%BASLB/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>​    当前环境没有使用阿里云ack托管kubernetes服务，而是采用了购买ECS，自建集群的方式。ingress svc需要使用LoadBalancer的Type类型来创建阿里云slb服务。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>阿里云已经给出了解决方法，首先是创建阿里云CCM资源，然后指定svc Type类型，就会自动创建slb服务了。</p>
<blockquote>
<p>阿里云官方文档目前暂未提供部署CCM的方法，所以自己根据github的文档对其进行了部署，并且验证了可用性，以下为部署方式，也包含了踩的几个坑。</p>
</blockquote>
<a id="more"></a>



<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ul>
<li>在阿里云环境自建的ecs服务器的kubernetes集群。</li>
<li>AK,SK需要对部分资源进行授权。具体哪些下面会提到。</li>
</ul>
<p><strong>因为我的集群已经在运行，使用的kubeadm部署，而不是从一开始初始化阶段为CCM做准备。</strong></p>
<h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><ol>
<li><p>依次获取所有的node节点的REGION和INSTANCE信息。<strong>注意需要每个node节点都去获取。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过命令获取到region-id和instance-id信息</span></span><br><span class="line">META_EP=http://100.100.100.200/latest/meta-data</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> `curl -s <span class="variable">$META_EP</span>/region-id`.`curl -s <span class="variable">$META_EP</span>/instance-id`</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p><strong>对每个节点进行patch</strong>，将region-id和instance-id组合作为provide-id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl patch node $&#123;NODE_NAME&#125; -p &quot;&#123;\&quot;spec\&quot;:&#123;\&quot;providerID\&quot;: $&#123;region-id&#125;.$&#123;instance-id&#125; &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>创建一个RAM用户(我个人推荐不在主账户下创建，而是用子账户来管理)，生成AKSK，该AKSK需要有访问部分资源的访问权限，这些权限至少包含<a href="https://github.com/kubernetes/cloud-provider-alibaba-cloud/blob/master/docs/examples/master.policy">master.policy</a>里面的权限，<strong>当时我就是想当然的以为只需要slb权限即可，导致一直无法创建。</strong>所以我给的权限是AliyunECSFullAccess。</p>
</li>
<li><p>将ak sk进行base64编码，并存储到configmap资源中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> base64 AccessKey &amp; AccessKeySecret</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$AccessKeyID</span>&quot;</span> |base64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$AcceessKeySecret</span>&quot;</span>|base64</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt;<span class="string">EOF &gt;cloud-config.yaml</span></span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: cloud-config</span><br><span class="line">  namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  cloud-config.conf: |-</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Global&quot;: &#123;</span><br><span class="line">            &quot;accessKeyID&quot;: &quot;$your-AccessKeyID-base64&quot;,</span><br><span class="line">            &quot;accessKeySecret&quot;: &quot;$your-AccessKeySecret-base64&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f cloud-config.yaml</span></span><br></pre></td></tr></table></figure></li>
<li><p>在/etc/kubernetes路径下创建cloud-controller-manager.conf的文件，并用ca.crt  64编码替换$CA_DATA内容，修改server地址为自身的api-server地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成base64编码</span></span><br><span class="line">cat /etc/kubernetes/pki/ca.crt|base64 -w 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成cloud-controller-manager.conf文件</span></span><br><span class="line">kind: Config</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: system:cloud-controller-manager</span><br><span class="line">  name: system:cloud-controller-manager@kubernetes</span><br><span class="line">current-context: system:cloud-controller-manager@kubernetes</span><br><span class="line">users:</span><br><span class="line">- name: system:cloud-controller-manager</span><br><span class="line">  user:</span><br><span class="line">    tokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    # 注意替换$CA_DATA</span><br><span class="line">    certificate-authority-data: $CA_DATA</span><br><span class="line">    # 这里填写集群api-server的地址</span><br><span class="line">    server: https://192.168.1.76:6443</span><br><span class="line">  name: kubernetes</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>下载<a href="https://raw.githubusercontent.com/kubernetes/cloud-provider-alibaba-cloud/master/docs/examples/cloud-controller-manager.yml">cloud-controller-manager.yml</a>文件，并替换–cluster-cidr地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取cluster-cidr地址</span></span><br><span class="line">kubectl cluster-info dump | grep cluster-cidr</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="7">
<li><p>对第六步的cloud-controller-manager.yml文件apply操作，然后观察kube-system的ns下是否生成了cloud-controller-manager-xxxx的pod，并且正常运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="8">
<li><p>进行创建LoadBalancer的测试，可以使用官方说明的最后几步，因为我这边用了nginx ingress, 所以直接修改了nginx ingress svc的type为LoadBalancer，保存后就自动创建SLB，可以通过查看cloud-controller-manager-xxxx的log看到具体信息。<strong>这里我一开始出现了Your account does not have enough balance的报错导致创建失败，那会查看余额是33块多点，后来我充值了100元，就成功创建了。</strong>在命令行可以通过<code>kubect get svc -n ingress-nginx</code>看到，svc的外网地址。</p>
</li>
<li><p>如果修改了svc的Type，从Loadbalancer改成其他的，会自动删除slb。</p>
</li>
</ol>
<p>ref:</p>
<blockquote>
<p><a href="https://github.com/kubernetes/cloud-provider-alibaba-cloud">https://github.com/kubernetes/cloud-provider-alibaba-cloud</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>误删正在输出的tomcat服务日志</title>
    <url>/2019/04/17/%E8%AF%AF%E5%88%A0%E6%AD%A3%E5%9C%A8%E8%BE%93%E5%87%BA%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="误删场景"><a href="#误删场景" class="headerlink" title="误删场景"></a>误删场景</h2><p>今天find写日志切割tomcat日志，需要匹配后缀为log,out,txt，之后忘记写括号,将log和out删除了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/find /opt/*/logs/* ( -name &quot;*.out&quot;  -o -name &quot;*.log&quot; -o -name &quot;*.txt&quot; ) -mtime +30 | xargs -I &#123;&#125; rm -f &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>tomcat不像nginx那样可以reload，其需要整个暂停，然后启动才能重新生成日志文件，但如果重启tomcat，则war包加载需要的时间比较长，且这段时间无法提供服务。</p>
<a id="more"></a>

<h2 id="临时查看的方法"><a href="#临时查看的方法" class="headerlink" title="临时查看的方法"></a>临时查看的方法</h2><p>虽然日志文件被删除，但在tomcat没有关闭之前文件描述符还是存在的，只是软连对象被删除而已。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>链表基础</title>
    <url>/2019/02/18/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><p>链表（Linked list）是一种线性，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)</p>
<p><strong>链表包含了内存块”节点”，以及记录下个或者上个节点地址的指针next。</strong></p>
<a id="more"></a>

<h2 id="链表常见结构"><a href="#链表常见结构" class="headerlink" title="链表常见结构"></a>链表常见结构</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g0aenkj7b8j20bc015t8h.jpg"></p>
<ul>
<li>第一个节点称之为头节点，头结点不存放数据，最后一个称之为尾节点。</li>
<li>每个节点分为两个部分。第一个部分是保存活显示关于节点的信息，第二个部分是存储下一个节点的地址。</li>
<li>单链表只能单方向遍历，且最后尾节点的下一个地址指针指向为NULL。</li>
</ul>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g0aepbxd64j209q01o742.jpg"></p>
<ul>
<li>首尾节点连接在一起，可以是单链表的首尾相连，也可以是双链表的首尾相连。</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g0aepjmdd9j20gy015t8i.jpg"></p>
<ul>
<li>双向链表有两个连接，一个指向前一个节点(若是头节点，则指向NULL)，另外一个指向下一个节点(若是尾节点，则指向NULL)。</li>
</ul>
<h2 id="链表的查找、插入、删除"><a href="#链表的查找、插入、删除" class="headerlink" title="链表的查找、插入、删除"></a>链表的查找、插入、删除</h2><h3 id="插入删除行为复杂度"><a href="#插入删除行为复杂度" class="headerlink" title="插入删除行为复杂度"></a>插入删除行为复杂度</h3><ol>
<li>对于数组而言，因为需要保证内存空间的连续性，当插入或者删除的时候，需要对数据进行搬迁(比如插入第二个位置，则原本第二个位置的数据”搬迁”到第三个位置，原本第三个位置的数据”搬迁”到第四个位置，以此类推)，这样才能保证连续,所以其时间复杂度为O(n)。</li>
<li>对链表而言，因为无需考虑数据的搬迁，只需要改变前后节点指针，所以其时间复杂度为O(1)。</li>
</ol>
<h3 id="查询行为复杂度"><a href="#查询行为复杂度" class="headerlink" title="查询行为复杂度"></a>查询行为复杂度</h3><ol>
<li>数组查询分两种，一种是根据下标索引查询，一种是查询具体数据，如果是第一种，则可以通过首地址和下标通过寻址公式查询得到，时间复杂度为O(1)，但第二种查询具体数据，则是O(n)。</li>
<li>链表的查询则因为需要依次遍历，所以其查询复杂度为O(n)。</li>
</ol>
<h2 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h2><ul>
<li>数组需要一块<strong>连续的内存空间</strong>。如果连续空间不足以被申请，即便总内存足够，也会创建数组失败。</li>
<li>链表不需要连续的内存空间，他通过指针将一组零散的内存块串联起来。</li>
<li>链表因为需要额外对指针进行存储，所以内存空间使用比数组要大。</li>
<li>cpu从内存读取数据，会先把读取到的数据加载到cpu的缓存中。从内存读取数据并不只是读取特定的访问地址，而是一个的数据块并存入cpu缓存中，然后下次查询的时候会先从cpu缓存中查询，如果找不到就从内存中查询，对于数组，读取某个下标对应的值后，其因为是连续的内存，所以会被一并存入cpu缓存中，而链表不会。</li>
</ul>
<p>refer</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8</a><br><a href="https://www.cnblogs.com/springfor/p/3985333.html">https://www.cnblogs.com/springfor/p/3985333.html</a><br><a href="https://time.geekbang.org/">https://time.geekbang.org/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/06/11/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="数组模拟队列-单向"><a href="#数组模拟队列-单向" class="headerlink" title="数组模拟队列(单向)"></a>数组模拟队列(单向)</h2><p><img src="https://assets.iostat.io/image/%E5%8D%95%E6%96%B9%E5%90%91%E9%98%9F%E5%88%97.png" alt="队列.png"></p>
<ol>
<li>队列三个要素, head,指向队列头; tail, 指向队列尾; maxCap, 队列总容量。</li>
<li>队列初始化的时候, head和tail都指向-1位置。</li>
<li>对于head而言, 指向的位置为弹出的元素. 在弹出的时候,<strong>head先+1</strong>, 再弹出head此时指向的元素。</li>
<li>对于tail而言, 指向的位置为队尾. 在压入元素的时候, <strong>tail先+1</strong>, 再放入元素。</li>
<li>当head == tail的时候, 说明队列为空。</li>
<li>当tail == maxCap-1的时候, 说明队列已满, 之所以要-1 是因为下标是从0开始的。</li>
<li>数组单向队列, 压入元素的时候会占用一个位置,当占满后,即便弹出元素,也无法释放空间。</li>
<li>所有的弹出都是伪弹出, 因为随着head的移动, 当查看队列内容的时候, 只是查看head到tail区间的元素。</li>
<li>单向队列, 当存储满之后, 哪怕取出数据也无法再往里塞入数据。</li>
</ol>
<a id="more"></a>

<h3 id="go代码实现数组模拟单向队列"><a href="#go代码实现数组模拟单向队列" class="headerlink" title="go代码实现数组模拟单向队列"></a>go代码实现数组模拟单向队列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	head <span class="keyword">int</span></span><br><span class="line">	tail <span class="keyword">int</span></span><br><span class="line">	maxCap <span class="keyword">int</span></span><br><span class="line">	array [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">isFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// q.tail为下标，队列最大容量需要 - 1</span></span><br><span class="line">	<span class="keyword">if</span> q.tail == q.maxCap - <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;队列已满&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> q.head == q.tail &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">pushQueue</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先判断队列是否满 true为不满</span></span><br><span class="line">	<span class="keyword">if</span> q.isFull() &#123;</span><br><span class="line">		q.tail += <span class="number">1</span></span><br><span class="line">		q.array[q.tail] = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">popQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先判断队列是否为空 true为不空</span></span><br><span class="line">	<span class="keyword">if</span> q.isEmpty() &#123;</span><br><span class="line">		q.head += <span class="number">1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;弹出元素为&quot;</span>)</span><br><span class="line">		fmt.Println(q.array[q.head])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">showQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取从head+1到tail+1位切片, 所以需要从head+1号位进行遍历到tail的位置。</span></span><br><span class="line">	<span class="comment">// 需要判断是否为空</span></span><br><span class="line">	<span class="keyword">if</span> q.isEmpty() &#123;</span><br><span class="line">		<span class="comment">// 因为被head指向的元素是已经被视为弹出了,所以要从head的下一位开始算.</span></span><br><span class="line">		tmpHead := q.head + <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i:=tmpHead; i&lt;=q.tail;i++ &#123;</span><br><span class="line">			fmt.Println(q.array[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;空队列&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Q := &amp;Queue&#123;</span><br><span class="line">		head:<span class="number">-1</span>,</span><br><span class="line">		tail:<span class="number">-1</span>,</span><br><span class="line">		maxCap:<span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	Q.pushQueue(<span class="number">1</span>)</span><br><span class="line">	Q.pushQueue(<span class="number">2</span>)</span><br><span class="line">	Q.pushQueue(<span class="number">3</span>)</span><br><span class="line">	Q.pushQueue(<span class="number">3</span>)</span><br><span class="line">	Q.pushQueue(<span class="number">4</span>)</span><br><span class="line">	Q.popQueue()</span><br><span class="line">	Q.showQueue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p><img src="https://assets.iostat.io/image/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97.png" alt="队列.png"></p>
<ol>
<li>环形队列克服了单向队列的问题，只要数据被取出，就可以一直被填充新数据。</li>
<li>环形队列其实也是数组实现的，只是当数据填入队尾后，使用<strong>取模</strong>的方式，重新将tail移动至队头。</li>
<li>一般情况下，比如单向队列，填充数据，队尾+1，也就是tail+1, 当队列非空的时候，tail的角标一定大于队头head的角标，但环形数组不同，因为tail会产生移动到队头的情况，所以存在head的角标大于tail角标的情况。<strong>但无论如何，tail和head相等的情况有且只会产生两次，一次是空队列的时候，还有一次是队列满的时候</strong>。</li>
<li>正因为存在当tail和head相等的时候有两种不确定性，<strong>所以我们可以在塞入数据后，限制tail追赶且跟head平齐，预留一个空位的方式，当tail+1除以队列长度，如果等于head，则表示队列满，这种情况，队列的可用度为队列长度-1</strong>。</li>
<li><strong>那么tail和head相等的情况只会发生在队列为空的时候，此时的相等是tail被head追赶并平齐了。</strong></li>
<li>tail和head的起始位置角标都为0。</li>
<li>如果要计算当前队列长度，如果是单向队列，那么只需要获取head至tail位置的内容即可，但环形队列存在重置队头的情况，队列长度为(tail+队列长度-head) % 队列长度。</li>
<li>为什么用这个长度算法公式？因为存在tail重置队头的情况，直接tail加上队列长度则假定每次都重置队头，最后除以队列长度，则是获取真实长度。</li>
<li>每次塞入数据，都是先塞入，然后(tail+1) % 队列长度； 同样，每次取出数据，都是先取出，然后(head+1) % 队列长度，两者都需要取模，防止溢出。</li>
</ol>
<h3 id="go代码实现环形队列"><a href="#go代码实现环形队列" class="headerlink" title="go代码实现环形队列"></a>go代码实现环形队列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明队列结构体, 四个要素, 长度, head, tail, 数组</span></span><br><span class="line"><span class="keyword">type</span> queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	head <span class="keyword">int</span></span><br><span class="line">	tail <span class="keyword">int</span></span><br><span class="line">	array [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">	maxCap <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span> <span class="title">isFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="keyword">if</span> (q.tail + <span class="number">1</span>) % q.maxCap == q.head &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;队列已满&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断队伍是否为空</span></span><br><span class="line">	<span class="keyword">if</span> q.tail == q.head &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span> <span class="title">pushQueue</span><span class="params">(value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> q.isFull() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;队列满了&quot;</span>)</span><br><span class="line">		<span class="comment">//// 此时队列满了, 需要取模后重新开始</span></span><br><span class="line">		<span class="comment">//q.tail = (q.tail + 1) % q.maxCap</span></span><br><span class="line">		<span class="comment">//q.array[q.tail] = value</span></span><br><span class="line">		<span class="comment">//q.tail += 1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		q.array[q.tail] = value</span><br><span class="line">		<span class="comment">// 自增因为存在循环情况, 所以要取模才不会溢出</span></span><br><span class="line">		q.tail = (q.tail + <span class="number">1</span>) % q.maxCap</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span> <span class="title">popQueue</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	<span class="comment">// 弹出之前先判断数组是否为空</span></span><br><span class="line">	<span class="keyword">if</span> q.isEmpty() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val := q.array[q.head]</span><br><span class="line">	<span class="comment">// 自增因为存在循环情况, 所以要取模才不会溢出</span></span><br><span class="line">	q.head = (q.head + <span class="number">1</span>) % q.maxCap</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;弹出了%v\n&quot;</span>, val)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span> <span class="title">showQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 因为可能tail会进行下一轮,导致tail的下标比head小, 所以要先得到队列中当前有多少个元素, 那么以head为起点, 循环这些元素个数次数, 则就是队列总的元素内容了</span></span><br><span class="line">	count := (q.tail + q.maxCap - q.head) % q.maxCap</span><br><span class="line">	<span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;当前为空队列&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	tempHead := q.head</span><br><span class="line">	<span class="comment">// 循环元素个数的次数, 因为i的起始值为0, 如果count是5, 那么其实是0,1,2,3,4 所以是i&lt;count,而非i&lt;=count</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span> ; i&lt;count; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;q.array[%v], 值为%v\n&quot;</span>, tempHead, q.array[tempHead])</span><br><span class="line">		<span class="comment">// 然后tempHead +1, 但因为是循环, 到了最大空间后, 又从第一个元素开始, 所以要取模</span></span><br><span class="line">		tempHead = (tempHead + <span class="number">1</span>) % q.maxCap</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Q := &amp;queue&#123;</span><br><span class="line">		head:<span class="number">0</span>,</span><br><span class="line">		tail:<span class="number">0</span>,</span><br><span class="line">		maxCap:<span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	Q.pushQueue(<span class="number">4</span>)</span><br><span class="line">	Q.pushQueue(<span class="number">5</span>)</span><br><span class="line">	Q.pushQueue(<span class="number">3</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;push 4, 5, 3后为&quot;</span>)</span><br><span class="line">	Q.showQueue()</span><br><span class="line"></span><br><span class="line">	Q.popQueue()</span><br><span class="line">	Q.popQueue()</span><br><span class="line">	fmt.Println(<span class="string">&quot;pop两次后为&quot;</span>)</span><br><span class="line">	Q.showQueue()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>go</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存模型和持久化(搬运)</title>
    <url>/2019/07/30/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis内存模型"><a href="#Redis内存模型" class="headerlink" title="Redis内存模型"></a>Redis内存模型</h1><h2 id="Redis内存统计"><a href="#Redis内存统计" class="headerlink" title="Redis内存统计"></a>Redis内存统计</h2><p>使用<code>info memory</code>进行统计</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:853392</span><br><span class="line">used_memory_human:833.39K</span><br><span class="line">used_memory_rss:3375104</span><br><span class="line">used_memory_rss_human:3.22M</span><br><span class="line">used_memory_peak:853392</span><br><span class="line">used_memory_peak_human:833.39K</span><br><span class="line">used_memory_peak_perc:100.01%</span><br><span class="line">used_memory_overhead:841150</span><br><span class="line">used_memory_startup:791384</span><br><span class="line">used_memory_dataset:12242</span><br><span class="line">used_memory_dataset_perc:19.74%</span><br><span class="line">allocator_allocated:1396056</span><br><span class="line">allocator_active:1724416</span><br><span class="line">allocator_resident:8605696</span><br><span class="line">total_system_memory:1929056256</span><br><span class="line">total_system_memory_human:1.80G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:1.24</span><br><span class="line">allocator_frag_bytes:328360</span><br><span class="line">allocator_rss_ratio:4.99</span><br><span class="line">allocator_rss_bytes:6881280</span><br><span class="line">rss_overhead_ratio:0.39</span><br><span class="line">rss_overhead_bytes:-5230592</span><br><span class="line">mem_fragmentation_ratio:4.15</span><br><span class="line">mem_fragmentation_bytes:2562728</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:49694</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure>
<p>几个关键的内存属性字段</p>
<ol>
<li>used_memory</li>
</ol>
<ul>
<li>Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）。</li>
</ul>
<ol start="2">
<li>used_memory_rss</li>
</ol>
<ul>
<li>Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是<strong>不包括虚拟内存</strong>。</li>
</ul>
<ol start="3">
<li>mem_fragmentation_ratio</li>
</ol>
<ul>
<li>used_memory_rss / used_memory的比值，该值越大，内存碎片越多，如果该值小于1，则表明使用了虚拟内存swap，需要对redis进行扩容，优化等操作。</li>
<li>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）</li>
</ul>
<ol start="4">
<li>mem_allocator</li>
</ol>
<ul>
<li>Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。</li>
</ul>
<h2 id="Redis内存划分"><a href="#Redis内存划分" class="headerlink" title="Redis内存划分"></a>Redis内存划分</h2><p><strong>redis除了内部数据会占用内存之外，也存在其他占用内存的地方。</strong></p>
<p>Redis的内存占用主要可以划分为以下几个部分</p>
<ol>
<li>数据(字符串、哈希、列表、集合、有序集合)</li>
</ol>
<ul>
<li>数据为最主要占用内存部分，这部分内存占用<strong>会统计在used_memory中</strong>。</li>
</ul>
<ol start="2">
<li>进程本身运行需要的内存</li>
</ol>
<ul>
<li>redis进程本身运行需要内存，入代码，常量池等。因为这部分不是有jemalloc分配，因此<strong>不会统计在used_memory中</strong>。</li>
<li>子进程，比如AOF，RDB也会占用内存，但<strong>也不会统计在used_memory中</strong></li>
</ul>
<ol start="3">
<li>缓冲内存</li>
</ol>
<ul>
<li>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等。这部分内存由jemalloc分配，因此<strong>会统计在used_memory中</strong>。</li>
</ul>
<ol start="4">
<li>内存碎片</li>
</ol>
<ul>
<li>内存碎片是Redis在分配、回收物理内存过程中产生的。<strong>不会统计在used_memory中</strong>。</li>
</ul>
<h2 id="Redis数据存储的细节"><a href="#Redis数据存储的细节" class="headerlink" title="Redis数据存储的细节"></a>Redis数据存储的细节</h2><p>直接查看refer内容</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="Redis高可用技术"><a href="#Redis高可用技术" class="headerlink" title="Redis高可用技术"></a>Redis高可用技术</h2><ol>
<li>持久化</li>
</ol>
<ul>
<li>持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li>
</ul>
<ol start="2">
<li>复制</li>
</ol>
<ul>
<li>复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。</li>
<li>缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li>
</ul>
<ol start="3">
<li>哨兵</li>
</ol>
<ul>
<li>在复制的基础上，哨兵实现了自动化的故障恢复。</li>
<li>缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li>
</ul>
<ol start="4">
<li>集群</li>
</ol>
<ul>
<li>通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li>
</ul>
<h2 id="Redis持久化类型"><a href="#Redis持久化类型" class="headerlink" title="Redis持久化类型"></a>Redis持久化类型</h2><ol>
<li>RDB</li>
</ol>
<ul>
<li>将数据保存到硬盘</li>
</ul>
<ol start="2">
<li>AOF</li>
</ol>
<ul>
<li>将每次执行的写命令保存到硬盘</li>
</ul>
<p><strong>由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</strong></p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p><strong>RDB可以通过手动触发，或者自动触发</strong></p>
<ol>
<li>手动触发</li>
</ol>
<ul>
<li>在命令行界面执行<code>save</code>命令，或者<code>bgsave</code>命令。</li>
<li>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。</li>
<li>bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。</li>
<li>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用</li>
</ul>
<ol start="2">
<li>自动触发</li>
</ol>
<ul>
<li>在配置文件中配置<code>save m n</code>，表示在m秒内发生n次变化时会触发bgsave。例如 save 900 1 表示在900秒内，如果redis数据发生了至少1次变化，则执行bgsave。多条save m n命令只要满足其中一条，就会触发。</li>
<li>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点。</li>
<li>执行shutdown命令时，自动执行rdb持久化。</li>
</ul>
<h3 id="save-m-n的实现原理"><a href="#save-m-n的实现原理" class="headerlink" title="save m n的实现原理"></a>save m n的实现原理</h3><ol>
<li><p>Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。</p>
</li>
<li><p>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。</p>
</li>
<li><p>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；<strong>而当save/bgsave执行完成后，会将dirty重新置为0</strong>。例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意<strong>dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令</strong>。</p>
</li>
<li><p>lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。</p>
</li>
</ol>
<p><strong>save m n的原理如下</strong></p>
<p>每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足</p>
<ul>
<li>当前时间-lastsave &gt; m</li>
<li>dirty &gt;= n</li>
</ul>
<h3 id="bgsave执行流程"><a href="#bgsave执行流程" class="headerlink" title="bgsave执行流程"></a>bgsave执行流程</h3><p>bgsave执行流程图</p>
<p><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5hsqct4vtj20fe09s0tq.jpg"></p>
<p>五个步骤</p>
<ol>
<li><p>Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似，都是fork子进程进行具体的工作，且都只有在fork时阻塞）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。</p>
</li>
<li><p>父进程执行fork操作创建子进程，<strong>这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令。</strong></p>
</li>
<li><p>父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令。</p>
</li>
<li><p>子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换。</p>
</li>
<li><p>子进程发送信号给父进程表示完成，父进程更新统计信息。</p>
</li>
</ol>
<h3 id="bgsave加载"><a href="#bgsave加载" class="headerlink" title="bgsave加载"></a>bgsave加载</h3><ol>
<li>RDB文件的载入工作是在服务器启动时自动执行的。</li>
<li>由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据。</li>
<li>只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。</li>
<li>服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</li>
<li>Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。</li>
</ol>
<h3 id="RDB常用配置总结"><a href="#RDB常用配置总结" class="headerlink" title="RDB常用配置总结"></a>RDB常用配置总结</h3><ol>
<li>save m n bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发</li>
<li>stop-writes-on-bgsave-error yes 当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no</li>
<li>rdbcompression yes 是否开启RDB文件压缩</li>
<li>rdbchecksum yes 是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现</li>
<li>dbfilename dump.rdb RDB文件名</li>
<li>dir ./ RDB文件和AOF文件所在目录</li>
</ol>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p><strong>AOF持久化是将Redis执行的每次写命令记录到单独的日志文件中，当Redis重启时再次执行AOF文件中的命令来恢复数据。</strong></p>
<p><strong>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</strong></p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>配置文件中<code>appendonly yes</code></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol>
<li>命令追加(append)：将Redis的写命令追加到缓冲区aof_buf。</li>
</ol>
<ul>
<li><strong>Redis先将写命令追加到缓冲区，而不是直接写入文件</strong>，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。</li>
</ul>
<ol start="2">
<li>文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘。</li>
<li>文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。</li>
</ol>
<h3 id="appendfsync参数"><a href="#appendfsync参数" class="headerlink" title="appendfsync参数"></a>appendfsync参数</h3><p><strong>AOF缓存区的同步文件策略由参数appendfsync控制</strong></p>
<ol>
<li>always</li>
</ol>
<ul>
<li>命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，<strong>硬盘IO成为性能瓶颈</strong>。</li>
</ul>
<ol start="2">
<li>no</li>
</ol>
<ul>
<li>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</li>
</ul>
<ol start="3">
<li>everysec</li>
</ol>
<ul>
<li>命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。<strong>everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置</strong>。</li>
</ul>
<h3 id="文件重写-rewrite"><a href="#文件重写-rewrite" class="headerlink" title="文件重写(rewrite)"></a>文件重写(rewrite)</h3><p><strong>文件重写是指定期重写AOF文件，减小AOF文件的体积</strong></p>
<p><strong>AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作</strong></p>
<p>关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</p>
<p>文件重写之所以能够压缩AOF文件的原因</p>
<ol>
<li><p>过期的数据不再写入文件</p>
</li>
<li><p>无效的命令不再写入文件</p>
</li>
</ol>
<ul>
<li>如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等</li>
</ul>
<ol start="3">
<li>多条命令可以合并为一个</li>
</ol>
<ul>
<li>如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。</li>
</ul>
<h4 id="文件重写的触发"><a href="#文件重写的触发" class="headerlink" title="文件重写的触发"></a>文件重写的触发</h4><ol>
<li>手动触发</li>
</ol>
<ul>
<li>直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。</li>
</ul>
<ol start="2">
<li>自动触发<br> <strong>根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机</strong>。<ol>
<li>auto-aof-rewrite-min-size<ul>
<li>执行AOF重写时，文件的最小体积，默认值为64MB。</li>
</ul>
</li>
<li>auto-aof-rewrite-percentage<ul>
<li>执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</strong></p>
<h4 id="文件重写的流程"><a href="#文件重写的流程" class="headerlink" title="文件重写的流程"></a>文件重写的流程</h4><p>重写流程图<br><img src="https://ws1.sinaimg.cn/large/9f0d15f3ly1g5hu5nkyvkj20aj09laab.jpg"></p>
<ol>
<li>Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。</li>
<li>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。</li>
<li><ol>
<li>父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。<strong>Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。</strong></li>
<li>由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。<strong>由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区</strong>。</li>
</ol>
</li>
<li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。</li>
<li><ol>
<li>子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。</li>
<li>父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。</li>
<li>使用新的AOF文件替换老文件，完成AOF重写。</li>
</ol>
</li>
</ol>
<h3 id="启动时加载"><a href="#启动时加载" class="headerlink" title="启动时加载"></a>启动时加载</h3><ol>
<li>当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据。</li>
<li>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载。</li>
</ol>
<h4 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h4><ol>
<li>Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。</li>
<li>如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。aof-load-truncated参数默认是开启的。</li>
</ol>
<h4 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h4><p>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；<strong>因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端</strong>，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。</p>
<h3 id="AOF常用配置总结"><a href="#AOF常用配置总结" class="headerlink" title="AOF常用配置总结"></a>AOF常用配置总结</h3><ol>
<li>appendonly no：是否开启AOF</li>
<li>appendfilename “appendonly.aof”：AOF文件名</li>
<li>dir ./：RDB文件和AOF文件所在目录</li>
<li>appendfsync everysec：fsync持久化策略</li>
<li>no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡</li>
<li>auto-aof-rewrite-percentage 100：文件重写触发条件之一</li>
<li>auto-aof-rewrite-min-size 64mb：文件重写触发提交之一</li>
<li>aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件</li>
</ol>
<h2 id="方案选择与常见问题"><a href="#方案选择与常见问题" class="headerlink" title="方案选择与常见问题"></a>方案选择与常见问题</h2><h3 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h3><ol>
<li><p>RDB持久化</p>
</li>
<li><p>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p>
</li>
<li><p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p>
</li>
<li><p>AOF持久化</p>
</li>
<li><p>优点：于支持秒级持久化、兼容性好。</p>
</li>
<li><p>缺点：是文件大、恢复速度慢、对性能影响大。</p>
</li>
</ol>
<h3 id="策略选择等其他问题参见原文"><a href="#策略选择等其他问题参见原文" class="headerlink" title="策略选择等其他问题参见原文"></a>策略选择等其他问题参见原文</h3><blockquote>
<p><a href="https://www.cnblogs.com/kismetv/p/9137897.html">https://www.cnblogs.com/kismetv/p/9137897.html</a></p>
</blockquote>
<p>refer</p>
<blockquote>
<p><a href="https://www.cnblogs.com/kismetv/p/8654978.html">https://www.cnblogs.com/kismetv/p/8654978.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp_max_syn_backlog和net.core.somaxconn</title>
    <url>/2019/02/11/tcp_max_syn_backlog%E5%92%8Csomaxconn/</url>
    <content><![CDATA[<p><strong>kernel 3.10.0-693.2.2.el7.x86_64</strong></p>
<h2 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h2><p>tcp的建联存在两种状态</p>
<ol>
<li>incomplete connection queue  未建联的队列</li>
<li>completed connection queue   已建联的队列</li>
</ol>
<a id="more"></a>

<ul>
<li><p>未建联的队列</p>
<ul>
<li>客户端发出syn请求，并且已经达到服务端，服务端返回syn+ack,等待对端响应ack时候的队列。</li>
<li>这些套接口处于SYN_RCVD状态。</li>
</ul>
</li>
<li><p>已建联的队列</p>
<ul>
<li>客户端发送建联请求，并且已经和服务端完成了三次握手，但此时这个socket还未被程序使用。(如何拿出来使用，则需要调用accept()函数)</li>
<li>这些套接口处于ESTABLISHED状态。</li>
</ul>
</li>
</ul>
<h2 id="listen-和accept-函数"><a href="#listen-和accept-函数" class="headerlink" title="listen()和accept()函数"></a>listen()和accept()函数</h2><p>三次握手图</p>
<p><img src="http://ww1.sinaimg.cn/large/9f0d15f3gy1g02g8ez0asj20uz0en0te.jpg"></p>
<p>一段python服务端网络编程代码：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">socket</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">socket</span>.<span class="built_in">socket</span>()</span><br><span class="line">host = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line">s.bind((host, port))</span><br><span class="line">BACKLOG = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">s.listen(BACKLOG)</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    c, addr = s.accept()</span><br><span class="line">    print(<span class="string">&quot;conn addr : &quot;</span>, addr)</span><br><span class="line">    c.<span class="built_in">send</span>(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">    c.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>上述代码listen()和accept()解释如下</p>
<h1 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen()函数"></a>listen()函数</h1><p>listen()函数的主要作用就是将套接字(sockfd)变成被动的连接监听套接字(被动等待客户端的连接)。</p>
<h1 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h1><p>从处于 completed connection queue状态的连接队列头部取出一个已经完成的连接，如这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。</p>
<p><strong>如果程序不调用accept()函数，那么连接socket一直滞留在completed connection queue队列里面，进而未被程序消费使用。</strong></p>
<p>比如如下代码:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="title">s</span> = socket.socket()</span><br><span class="line"><span class="title">host</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="keyword">port</span> = 12345</span><br><span class="line">s.bind((host, port))</span><br><span class="line">BACKLOG = 5</span><br><span class="line"></span><br><span class="line">s.listen(<span class="type">BACKLOG</span>)</span><br><span class="line">print(&#x27;listening&#x27;)</span><br><span class="line">time.sleep(3600)</span><br></pre></td></tr></table></figure>
<h2 id="somaxconn"><a href="#somaxconn" class="headerlink" title="somaxconn"></a>somaxconn</h2><p>The behavior of the backlog argument on TCP sockets changed with Linux 2.2. Now it specifies the queue length for <strong>completely established</strong> sockets waiting to be accepted, instead of the number of incomplete connection requests. </p>
<p>If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value 128.</p>
<ol>
<li>somaxconn用来指定系统定义的建联队列的长度(ESTAB状态的连接数量)。</li>
<li>若程序中定义的listen函数的backlog大于系统定义的，则以系统定义为准。</li>
</ol>
<h3 id="代码实践-somaxconn"><a href="#代码实践-somaxconn" class="headerlink" title="代码实践 somaxconn"></a>代码实践 somaxconn</h3><p>python的一个不含accept()的服务端代码，这样可以让socket滞留在completed connection queue队列里面。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="title">s</span> = socket.socket(socket.<span class="type">AF_INET</span>, socket.<span class="type">SOCK_STREAM</span>)</span><br><span class="line"><span class="title">host</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="keyword">port</span> = 12345</span><br><span class="line">s.bind((host, port))</span><br><span class="line">BACKLOG = 2</span><br><span class="line"></span><br><span class="line">s.listen(<span class="type">BACKLOG</span>)</span><br><span class="line">print(&#x27;listening&#x27;)</span><br><span class="line">time.sleep(3600)</span><br></pre></td></tr></table></figure>
<p>查看下系统somaxconn的值：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[root@leanote ~]</span><span class="comment"># sysctl -a | grep somaxconn</span></span><br><span class="line"><span class="attr">net.core.somaxconn</span> = <span class="number">128</span></span><br></pre></td></tr></table></figure>
<p>启动进程，<strong>先不使用客户端进行连接</strong>，使用ss查看进程pid。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@leanote</span> ~]<span class="meta"># ss -anpl | egrep <span class="string">&quot;10187|Recv-Q&quot;</span></span></span><br><span class="line">Netid  State      Recv-Q <span class="built_in">Send</span>-Q <span class="keyword">Local</span> Address:Port               Peer Address:Port              </span><br><span class="line">tcp    LISTEN     <span class="number">0</span>      <span class="number">5</span>         *:<span class="number">12345</span>                 *:*                   users:((<span class="string">&quot;python3&quot;</span>,pid=<span class="number">10187</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>这里涉及到Recv-Q和Send-Q两个字段，这两个字段的含义和前面state字段为何种状态密不可分，解释如下</p>
<ul>
<li><p>Recv-Q</p>
<ul>
<li>Established: The count of bytes not copied by the user program connected to this socket.(套接字缓冲还没有被应用程序取走的字节数)</li>
<li>Listening: Since Kernel 2.6.18 this column contains the current syn backlog. (当前syn backlog为backlog+1)</li>
</ul>
</li>
<li><p>Send-Q</p>
<ul>
<li>Established: The count of bytes <strong>not acknowledged</strong> by the remote host.(没有被远端确认的字节数)</li>
<li>Listening: Since Kernel 2.6.18 this column contains the maximum size of the syn backlog.</li>
</ul>
</li>
</ul>
<p><strong>Send-Q 对应的值是5，这个值也就是代码中listen()中BACKLOG的值。</strong></p>
<p>此时如果调整BACKLOG至256，重新启动进程，然后用ss查看信息：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="title">s</span> = socket.socket(socket.<span class="type">AF_INET</span>, socket.<span class="type">SOCK_STREAM</span>)</span><br><span class="line"><span class="title">host</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="keyword">port</span> = 12345</span><br><span class="line">s.bind((host, port))</span><br><span class="line">BACKLOG = 256</span><br><span class="line"></span><br><span class="line">s.listen(<span class="type">BACKLOG</span>)</span><br><span class="line">print(&#x27;listening&#x27;)</span><br><span class="line">time.sleep(3600)</span><br></pre></td></tr></table></figure>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@leanote</span> ~]<span class="meta"># ss -anp |egrep <span class="string">&quot;12345|Recv-Q&quot;</span></span></span><br><span class="line">Netid  State      Recv-Q <span class="built_in">Send</span>-Q <span class="keyword">Local</span> Address:Port               Peer Address:Port              </span><br><span class="line">tcp    LISTEN     <span class="number">0</span>      <span class="number">128</span>       *:<span class="number">12345</span>                 *:*                   users:((<span class="string">&quot;python3&quot;</span>,pid=<span class="number">19593</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>Send-Q被系统somaxcon限制为128，调整系统somaxcon的值后，重启进程，然后ss继续观察</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[root@leanote ~]</span><span class="comment"># sysctl net.core.somaxconn=65522</span></span><br><span class="line"><span class="attr">net.core.somaxconn</span> = <span class="number">65522</span></span><br></pre></td></tr></table></figure>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@leanote</span> ~]<span class="meta"># ss -anp |egrep <span class="string">&quot;12345|Recv-Q&quot;</span></span></span><br><span class="line">Netid  State      Recv-Q <span class="built_in">Send</span>-Q <span class="keyword">Local</span> Address:Port               Peer Address:Port              </span><br><span class="line">tcp    LISTEN     <span class="number">0</span>      <span class="number">256</span>       *:<span class="number">12345</span>                 *:*                   users:((<span class="string">&quot;python3&quot;</span>,pid=<span class="number">19839</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>变成了程序代码里定义的BACKLOG值了。</p>
<p><strong>让客户端进行建联</strong></p>
<p>客户端代码：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">socket</span></span><br><span class="line">import <span class="built_in">time</span></span><br><span class="line">host = <span class="string">&#x27;122.152.220.151&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line">sockets=[]</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    s = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line">    s.connect((host, port))</span><br><span class="line">    sockets.append(s)</span><br><span class="line">    <span class="built_in">time</span>.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><strong>代码中BACKLOG修改为2</strong></p>
<p>使用ss观察服务端</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]<span class="comment"># ss -anp |egrep &quot;12345|Recv-Q&quot;</span></span><br><span class="line">Netid  State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              </span><br><span class="line">tcp    LISTEN    <span class="number"> 3 </span>    <span class="number"> 2 </span>        *:12345                 *:*                   users:((&quot;python3&quot;,pid=20361,fd=3))</span><br><span class="line">tcp    SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:35986              </span><br><span class="line">tcp    SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:36012              </span><br><span class="line">tcp    SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              89.248.167.131:56380              </span><br><span class="line">tcp    SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:35994              </span><br><span class="line">tcp    SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:36002              </span><br><span class="line">tcp    ESTAB     <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:35972              </span><br><span class="line">tcp    ESTAB     <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:35952              </span><br><span class="line">tcp    ESTAB     <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:35960                          </span><br></pre></td></tr></table></figure>
<p><strong>建联3个后(ESTAB),其他请求一直处于SYN-RECV状态。</strong></p>
<p>Recv-Q为3，表示当前syn backlog为3 ,backlog+1的结果(2+1)。</p>
<p>当BACKLOG满的时候，抓包情况：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]# tcpdump -i any port <span class="number">12345</span> -nnn &gt; <span class="number">111</span></span><br><span class="line">[root@leanote ~]# cat <span class="number">111</span> | grep  <span class="number">37182</span></span><br><span class="line"><span class="number">16</span>:<span class="number">11</span>:<span class="number">58.519076</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [S], seq <span class="number">1450185841</span>, win <span class="number">29200</span>, options [mss <span class="number">1424</span>,sackOK,TS val <span class="number">3561765739</span> ecr <span class="number">0</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">11:58.519145</span> IP <span class="number">10.105.31.91</span>.<span class="number">12345</span> &gt; <span class="number">118.24.105.81</span>.<span class="number">37182</span>: Flags [S.], seq <span class="number">1044766216</span>, ack <span class="number">1450185842</span>, win <span class="number">28960</span>, options [mss <span class="number">1460</span>,sackOK,TS val <span class="number">3121876725</span> ecr <span class="number">3561765739</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">11</span>:<span class="number">58.578420</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [.], ack <span class="number">1</span>, win <span class="number">229</span>, options [nop,nop,TS val <span class="number">3561765798</span> ecr <span class="number">3121876725</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">11</span>:<span class="number">59.853632</span> IP <span class="number">10.105.31.91</span>.<span class="number">12345</span> &gt; <span class="number">118.24.105.81</span>.<span class="number">37182</span>: Flags [S.], seq <span class="number">1044766216</span>, ack <span class="number">1450185842</span>, win <span class="number">28960</span>, options [mss <span class="number">1460</span>,sackOK,TS val <span class="number">3121878060</span> ecr <span class="number">3561765798</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">11</span>:<span class="number">59.912872</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [.], ack <span class="number">1</span>, win <span class="number">229</span>, options [nop,nop,TS val <span class="number">3561767133</span> ecr <span class="number">3121876725</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12</span>:<span class="number">02.053621</span> IP <span class="number">10.105.31.91</span>.<span class="number">12345</span> &gt; <span class="number">118.24.105.81</span>.<span class="number">37182</span>: Flags [S.], seq <span class="number">1044766216</span>, ack <span class="number">1450185842</span>, win <span class="number">28960</span>, options [mss <span class="number">1460</span>,sackOK,TS val <span class="number">3121880260</span> ecr <span class="number">3561767133</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12:02.112871</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [.], ack <span class="number">1</span>, win <span class="number">229</span>, options [nop,nop,TS val <span class="number">3561769333</span> ecr <span class="number">3121876725</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12:06.253625</span> IP <span class="number">10.105.31.91</span>.<span class="number">12345</span> &gt; <span class="number">118.24.105.81</span>.<span class="number">37182</span>: Flags [S.], seq <span class="number">1044766216</span>, ack <span class="number">1450185842</span>, win <span class="number">28960</span>, options [mss <span class="number">1460</span>,sackOK,TS val <span class="number">3121884460</span> ecr <span class="number">3561769333</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12</span>:<span class="number">06.312908</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [.], ack <span class="number">1</span>, win <span class="number">229</span>, options [nop,nop,TS val <span class="number">3561773533</span> ecr <span class="number">3121876725</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12:14.253636</span> IP <span class="number">10.105.31.91</span>.<span class="number">12345</span> &gt; <span class="number">118.24.105.81</span>.<span class="number">37182</span>: Flags [S.], seq <span class="number">1044766216</span>, ack <span class="number">1450185842</span>, win <span class="number">28960</span>, options [mss <span class="number">1460</span>,sackOK,TS val <span class="number">3121892460</span> ecr <span class="number">3561773533</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12</span>:<span class="number">14.312821</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [.], ack <span class="number">1</span>, win <span class="number">229</span>, options [nop,nop,TS val <span class="number">3561781533</span> ecr <span class="number">3121876725</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12:30.253631</span> IP <span class="number">10.105.31.91</span>.<span class="number">12345</span> &gt; <span class="number">118.24.105.81</span>.<span class="number">37182</span>: Flags [S.], seq <span class="number">1044766216</span>, ack <span class="number">1450185842</span>, win <span class="number">28960</span>, options [mss <span class="number">1460</span>,sackOK,TS val <span class="number">3121908460</span> ecr <span class="number">3561781533</span>,nop,wscale <span class="number">7</span>], length <span class="number">0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">12</span>:<span class="number">30.312821</span> IP <span class="number">118.24.105.81</span>.<span class="number">37182</span> &gt; <span class="number">10.105.31.91</span>.<span class="number">12345</span>: Flags [.], ack <span class="number">1</span>, win <span class="number">229</span>, options [nop,nop,TS val <span class="number">3561797533</span> ecr <span class="number">3121876725</span>], length <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>对客户端一直发送syn+ack包。([S.]  S表示syn，.表示ack)<br>6次后，不再继续发送</p>
<p>虽然服务端ESTAB状态只有3个，但是对客户端而言，存在多个</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">[root@VM_0_15_centos ~]# netstat -ant | grep <span class="number">12345</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37326</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37410</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37312</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37242</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37232</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37360</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37266</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37442</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37458</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37468</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37214</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37392</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37282</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37292</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37182</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37174</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37222</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37370</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37400</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37430</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37206</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37418</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37342</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37352</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37252</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37384</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37334</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37274</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37450</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37300</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 172.27.0</span>.<span class="number">15:37192</span>       <span class="number">122.152.220.151</span>:<span class="number">12345</span>   ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>对于客户端而言，服务端发送了syn+ack已经算是三次握手成功了。</p>
<h2 id="tcp-max-syn-backlog"><a href="#tcp-max-syn-backlog" class="headerlink" title="tcp_max_syn_backlog"></a>tcp_max_syn_backlog</h2><p>The maximum number of queued connection    requests which have still <strong>not received</strong> an acknowledgement from the connecting client. If this number is exceeded, the kernel will begin drop-ping requests.The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog. When syncookies are enabled there is no logical maximum length and this setting is ignored</p>
<ol>
<li>tcp_max_syn_backlog用来定义未建联的SYN-RECV状态队列长度。</li>
<li>当启用syncookies功能的时候，tcp_max_syn_backlog的功能将被忽视。</li>
</ol>
<p>###代码实践 tcp_max_syn_backlog</p>
<p>查看下系统tcp_max_syn_backlog的值：<br>[root@leanote ~]# sysctl -a | grep tcp_max_syn_backlog<br>net.ipv4.tcp_max_syn_backlog = 128</p>
<p>服务端ss查看</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]# netstat -ant | grep <span class="number">12345</span></span><br><span class="line">tcp        <span class="number">3</span>      <span class="number">0 0.0.0</span>.<span class="number">0:12345</span>           <span class="number">0.0.0.0</span>:*               LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37926</span>     SYN_RECV   </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37894</span>     SYN_RECV   </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37944</span>     SYN_RECV   </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37936</span>     SYN_RECV   </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37908</span>     SYN_RECV   </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37918</span>     SYN_RECV   </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37874</span>     ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37864</span>     ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0 10.105.31</span>.<span class="number">91:12345</span>      <span class="number">118.24.105.81</span>:<span class="number">37882</span>     ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>输出发现SYN_RECV状态状态很多，<strong>虽然连接处于SYN_RECV</strong>，一段时间后，自动删除，但是通过调整tcp_max_syn_backlog的值可以调整同一时间内SYN_RECV的数量。</p>
<p>调整成为2个：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[root@leanote ~]</span><span class="comment"># sysctl net.ipv4.tcp_max_syn_backlog=2</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_max_syn_backlog</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>因为当syncookies功能开启的时候，tcp_max_syn_backlog不会发挥作用，所以syncookies也得暂停：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[root@leanote ~]</span><span class="comment"># sysctl net.ipv4.tcp_syncookies=0</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_syncookies</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>客户端服务端重启，然后ss查看状态：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]<span class="comment"># ss -ant | grep 12345</span></span><br><span class="line">LISTEN    <span class="number"> 3 </span>    <span class="number"> 2 </span>           *:12345                    *:*                  </span><br><span class="line">SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:38456              </span><br><span class="line">SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:38470              </span><br><span class="line">SYN-RECV  <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:38398              </span><br><span class="line">ESTAB     <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:38280              </span><br><span class="line">ESTAB     <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:38264              </span><br><span class="line">ESTAB     <span class="number"> 0 </span>    <span class="number"> 0 </span>     10.105.31.91:12345              118.24.105.81:38272    </span><br></pre></td></tr></table></figure>
<p>这个syn_backlog设定的是2，但观察SYN-RECV最多出现3个。可能也是syn_backlog+1。待考证。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">[root@leanote ~]# netstat -s | grep <span class="keyword">drop</span></span><br><span class="line">    <span class="number">20</span> dropped because <span class="keyword">of</span> missing route</span><br><span class="line">    <span class="number">19</span> ICMP packets dropped because they were <span class="keyword">out</span>-<span class="keyword">of</span>-<span class="keyword">window</span></span><br><span class="line">    <span class="number">92307</span> SYNs <span class="keyword">to</span> <span class="keyword">LISTEN</span> sockets dropped</span><br><span class="line">    </span><br><span class="line">[root@leanote ~]# dmesg  | tail -n <span class="number">10</span></span><br><span class="line">[<span class="number">3124021.575444</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38910</span></span><br><span class="line">[<span class="number">3124025.583391</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38910</span></span><br><span class="line">[<span class="number">3124033.599301</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38910</span></span><br><span class="line">[<span class="number">3124049.647044</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38910</span></span><br><span class="line">[<span class="number">3124111.900356</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38996</span></span><br><span class="line">[<span class="number">3124112.902233</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38996</span></span><br><span class="line">[<span class="number">3124114.908171</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38996</span></span><br><span class="line">[<span class="number">3124118.916112</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38996</span></span><br><span class="line">[<span class="number">3124126.924020</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38996</span></span><br><span class="line">[<span class="number">3124142.955770</span>] TCP: <span class="keyword">drop</span> <span class="keyword">open</span> request <span class="keyword">from</span> <span class="number">118.24</span><span class="number">.105</span><span class="number">.81</span>/<span class="number">38996</span></span><br></pre></td></tr></table></figure>
<p>服务器开始丢弃syn包，以及丢弃从客户端发送来的新连接。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>tcp_max_syn_backlog用来定义未建联的SYN-RECV状态队列长度。但当启用syncookies功能的时候失效。</li>
<li>somaxconn会限制listen()函数中BACKLOG的值。</li>
</ul>
<p><strong>somaxconn在高并发下需要调整，默认128绝逼不够用。</strong></p>
<p>refer</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/30b861cac826">https://www.jianshu.com/p/30b861cac826</a><br><a href="https://www.jianshu.com/p/7fde92785056">https://www.jianshu.com/p/7fde92785056</a><br><a href="https://linux.die.net/man/2/listen">https://linux.die.net/man/2/listen</a><br><a href="http://www.agr.unideb.hu/~agocs/informatics/11_e_unix/unixhelp/unixhelp.ed.ac.uk/CGI/man-cgiaa65.html?tcp+7">http://www.agr.unideb.hu/~agocs/informatics/11_e_unix/unixhelp/unixhelp.ed.ac.uk/CGI/man-cgiaa65.html?tcp+7</a><br><a href="http://zake7749.github.io/2015/03/17/SocketProgramming/">http://zake7749.github.io/2015/03/17/SocketProgramming/</a><br><a href="http://man7.org/linux/man-pages/man2/accept.2.html">http://man7.org/linux/man-pages/man2/accept.2.html</a><br><a href="https://blog.csdn.net/tennysonsky/article/details/45621341">https://blog.csdn.net/tennysonsky/article/details/45621341</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
</search>
