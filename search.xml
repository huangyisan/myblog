<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bash fork: retry: Resource temporarily unavailable]]></title>
    <url>%2F2019%2F01%2F02%2Fbash-fork-retry-Resource-temporarily-unavailable%2F</url>
    <content type="text"><![CDATA[挖个坑。明天写。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort函数中key的理解]]></title>
    <url>%2F2018%2F12%2F29%2Fsort%E5%87%BD%E6%95%B0%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[sort()函数12345Help on method_descriptor:sort(...) L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*(END) python3中已经取消了sort()函数中cmp参数 python中sort()函数用来排序，其中有个key的参数，十分神奇。 我对key参数的理解是：这个key是构造了一个全新的对象，对这些全新的对象进行比较排序，然后再根据结果，对原先的对象进行排序。 字典value排序:比如很常用的，对一个字典进行value排序：123456d = &#123;1: &apos;c&apos;, 2:&apos;d&apos;, 3: &apos;b&apos;, 4: &apos;a&apos;&#125;def sort_value(x): return x[1]print(sorted(d.items(), key=sort_value)) d.items得到dict_items([(1, ‘c’), (2, ‘d’), (3, ‘b’), (4, ‘a’)])，其挨个传入到key对应的sort_value函数中，返回索引为1的值，也就是value的值，然后对这个新对象进行排序，最终以新对象排序的结果来输出d.items()的排序。 将sort_value函数写成lambda则：1print(sorted(d.items(), key=lambda x :x[1])) 字符串内容重新排序:对字符串”hUangYisan6749”重新排序，要求: 数字在最前面，偶数在奇数前面。 字符串在数字后面，大写字母在小写字母后面。 思路： 字符串挨个拆出来。 构造一个元组，能够符合上述需求，然后排序的。元组的排序是从首个元素逐一排序的，碰到首元素一样，则比第二个元素 先确定一个通用的元组，总共是四种类型，奇数偶数，大写小写。例：偶数，奇数，大写，小写(1,0,0,0)，比如这样就表示该字符为偶数。 由于默认sorted排序是从小到大，所以根据需求，得写成小写，大写，奇数，偶数的方式(或者加上reverse=True) 123456789def custom_order(x): if x.islower(): return 1,0,0,0,x if x.isupper(): return 0,1,0,0,x if x.isdigit() and int(x) % 2 == 0: return 0,0,1,0,x else: return 0,0,0,1,x 当对比相同的时候，会索引+1比较，所以return不能漏掉x，因为当前面四位全部相等的时候，要比较x。 那么代码可以写成：1234567891011121314mystring = &quot;hUangYisan6749&quot;def custom_order(x): if x.islower(): return 1,0,0,0,x if x.isupper(): return 0,1,0,0,x if x.isdigit() and int(x) % 2 == 0: return 0,0,1,0,x else: return 0,0,0,1,xprint(&quot;&quot;.join(sorted(mystring,key=custom_order)))7946UYaaghinns refer: http://python.jobbole.com/85025/]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[split函数]]></title>
    <url>%2F2018%2F12%2F29%2Fsplit%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一道领扣的题给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: &quot;Hello World&quot;输出: 5 写出的其中一种答案是：123456789101112class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; slist = s.split() print(slist) if slist == []: return 0 return len(slist[-1]) split(“ “) 和 split()起先我认为split(“ “)和split()的作用是一样的，都是以空格进行分割。以至于一开始做上面领扣的题一直都有问题。 然后手工验证了下两者的情况： split(“ “)的情况 12&gt;&gt;&gt; &quot; a &quot;.split(&quot; &quot;)[&apos;&apos;, &apos;a&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;] split()的情况 12&gt;&gt;&gt; &quot; a &quot;.split()[&apos;a&apos;] 查了下split()的用法 123S.split([sep [,maxsplit]]) -&gt; list of stringsReturn a list of the words in the string S, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result. 也就是说，如果sep不填写，那么split()执行两个行为： 以任何whitespace字符串作为分隔符。 除所有的empty string。 empty string就是not xxx返回结果为False的字符串,包括””。 refer: https://leetcode-cn.com/problems/length-of-last-word/help(str.split)]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7网卡改名]]></title>
    <url>%2F2018%2F12%2F27%2Fcentos7%E7%BD%91%E5%8D%A1%E6%94%B9%E5%90%8D%2F</url>
    <content type="text"><![CDATA[客户瞎搞，两张网卡，说是看着名称不爽，自行修改了网卡名，为bond0和bond1，bond1能启动，而bond0无法启动。我这边接手擦屁股。 先说udev服务，然后再看问题产生的原因。 system-udevd进程在centos6中为udevd进程：12[root@VM_31_91_centos6 ~]# ps -ef | grep udevroot 470 1 0 01:17 ? 00:00:00 /sbin/udevd -d 在centos7中为system-udevd进程12[root@VM_31_91_centos7 ~]# ps -ef | grep udevroot 460 1 0 10月09 ? 00:00:00 /usr/lib/systemd/systemd-udevd udev的作用是：man udevreceives device uevents directly from the kernel whenever a device is added or removed from the system, or it changes its state.当有设备从系统插入或者拔出，或者改变了状态的时候，内核会直接收到设备uevents。 udev rules文件存在位置： system rules directory: /usr/lib/udev/rules.d volatile runtime directory: /run/udev/rules.d local administration directory: /etc/udev/rules.d udev读取文件规则： 读取这些目录下以.rules为后缀的文件。 文件先后顺序和其所在目录无关，和文件的名称顺序有关。 若不同目录存在相同的文件，则根据目录名称来排优先级顺序。/etc&gt;/run&gt;/usr udev进行网卡重命名 https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsg 优先查询的是/usr/lib/udev/rules.d/60-net.rules配置文件。如果发现包含 HWADDR 条目的 ifcfg 文件与某个接口的 MAC 地址匹配，它会将该接口重命名为 ifcfg 文件中由 DEVICE 指令给出的名称。 问题产生的原因当时发现/usr/lib/udev/rules.d/60-net.rules文件内已经存在了bond1的配置，而bond0的配置写到了/etc/udev/rules.d/70-persistent-net.rules里面，由于60的优先级高于70，所以bond0网卡一直起不来。 其实centos7已经不用70-persistent-net.rules这个文件了，在centos6中，删除了70-persistent-net.rules文件，他会通过/lib/udev/write_net_rules文件来生成，但centos7已经不存在该文件了，centos7是使用/lib/udev/rename_device文件来生成/usr/lib/udev/rules.d/60-net.rules。 合理修改centos7网卡名称流程首先修改当前网卡名称 123/sbin/ip link set eth1 down/sbin/ip link set eth1 name eth123/sbin/ip link set eth123 up 然后在/usr/lib/udev/rules.d/60-net.rules中加入配置策略ACTION==”add”, SUBSYSTEM==”net”, DRIVERS==”?*”, ATTR{address}==”00:50:56:8e:3f:a7”, NAME=”eth123” refer: https://www.freedesktop.org/software/systemd/man/udev.html#https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsghttps://unix.stackexchange.com/questions/205010/centos-7-rename-network-interface-without-rebooting]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从无法加载JAVA_HOME说起]]></title>
    <url>%2F2018%2F12%2F25%2F%E4%BB%8E%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDJAVA-HOME%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[这几天在做jenkins cicd的事儿，用sudo的方式启动tomcat，直接报出无法找到JAVA_HOME。当时挺纳闷的，因为我在/etc/profile里面是添加了JAVA_HOME。123456789[root@ccc bin]# sudo ./catalina.sh startNeither the JAVA_HOME nor the JRE_HOME environment variable is definedAt least one of these environment variable is needed to run this program[root@ccc bin]# tail -n 5 /etc/profileexport JAVA_HOME=/tool/jdk1.8.0_144export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 如此如此，出现了两个疑问。 为什么/etc/profile的内容无法被加载？ 在/etc/profile里面写入jdk环境变量是否合适？ 为什么/etc/profile的内容无法被加载？先说下一个概念，linux的用户交互模式。在linux中用户交互模式可以分为两类： Interactive Shell Non-Interactive Shell Interactive Shell 顾名思义，就是登陆用户可以和shell进行交互的，比如你用xshell上一台服务器，出现的terminal就是属于Interactive Shell方式。Non-Interactive Shell 非交互的模式，比如用crontab的方式执行一个shell脚本。 那么问题就来了，这两种模式的环境变量从哪里去获取呢？ Interactive Shell登录情况 123456789101112execute /etc/profileIF ~/.bash_profile exists THEN execute ~/.bash_profileELSE IF ~/.bash_login exist THEN execute ~/.bash_login ELSE IF ~/.profile exist THEN execute ~/.profile END IF END IFEND IF 一目了然，入口为/etc/profile文件。其中在.bash_profile里面还判断是否存在~/.bashrc，如果存在则加载~/.bashrc。 12if [ -f ~/.bashrc ]; then . ~/.bashrc 还没完，在执行~/.bashrc的时候里面继续判断是否存在/etc/bashrc，如果存在则执行/etc/bashrc。 123if [ -f /etc/bashrc ]; then . /etc/bashrcfi 顺带一说，当用户退出Interactive Shell的时候，执行~/.bash_logout内容。所以可以在退出的时候定义一些行为。 123IF ~/.bash_logout exists THEN execute ~/.bash_logoutEND IF 总结下Interactive Shell的顺序： /etc/profile ~/.bash_profile ~/.bashrc /etc/bashrc ~/.bash_login ~/.profile ~/.bash_logout (当且仅当退出Interactive Shell的时候执行) Non-Interactive Shell的情况 123IF ~/.bashrc exists THEN execute ~/.bashrcEND IF 直接去执行的~/.bashrc，该文件也会判断是否存在/etc/bashrc，存在则执行/etc/bashrc。 总结下Non-Interactive Shell的顺序： ~/.bashrc /etc/bashrc 看似原因好像是因为sudo ./catalina.sh start进入了Non-Interactive Shell，从而没加载/etc/profile，其实并不是这样的。sudo在这边搞出了幺蛾子？ sudo做了啥？命令输入visudo，有那么一节内容： 1234567891011121314# Preserving HOME has security implications since many programs# use it when searching for configuration files. Note that HOME# is already set when the the env_reset option is enabled, so# this option is only effective for configurations where either# env_reset is disabled or HOME is present in the env_keep list.#Defaults always_set_homeDefaults env_resetDefaults env_keep = &quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS&quot;Defaults env_keep += &quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;Defaults env_keep += &quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;Defaults env_keep += &quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;Defaults env_keep += &quot;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot; 其行为会将env reset，但是会保留部分环境变量。这一行为导致了sudo ./catalina.sh start无法寻找到jdk变量。 比较差劲的解决方法：man一下sudo，有个-E的参数，能保留之前的环境变量，但是不推荐这样做，因为有安全隐患： 123-E The -E (preserve environment) option indicates to the security policy that the user wishes to preserve their existing environment variables. The security policy may return an error if the -E option is specified and the user does not have permission to preserve the environment. 1234567[root@ccc bin]# sudo -E ./catalina.sh startUsing CATALINA_BASE: /opt/mixcdn-tomcatUsing CATALINA_HOME: /opt/mixcdn-tomcatUsing CATALINA_TMPDIR: /opt/mixcdn-tomcat/tempUsing JRE_HOME: /tool/jdk1.8.0_144Using CLASSPATH: /opt/mixcdn-tomcat/bin/bootstrap.jar:/opt/mixcdn-tomcat/bin/tomcat-juli.jarTomcat started. 好的解决方法在下面： 在/etc/profile里面写入jdk环境变量是否合适？针对部署tomcat的jdk环境，很多文档，包括我自己，之前也是从别人那边拿来的部署jdk文档，将jdk环境变量写入/etc/profile，等文件中，这个观念基本上贯穿了我整个运维生涯。 其实官方给出了写法，在catalina.sh里面: 12345678910111213141516171819202122232425262728# Control Script for the CATALINA Server## Environment Variable Prerequisites## Do not set the variables in this script. Instead put them into a script# setenv.sh in CATALINA_BASE/bin to keep your customizations separate.## CATALINA_HOME May point at your Catalina &quot;build&quot; directory.## CATALINA_BASE (Optional) Base directory for resolving dynamic portions# of a Catalina installation. If not present, resolves to........# Ensure that any user defined CLASSPATH variables are not used on startup,# but allow them to be specified in setenv.sh, in rare case when it is needed.CLASSPATH=if [ -r &quot;$CATALINA_BASE/bin/setenv.sh&quot; ]; then . &quot;$CATALINA_BASE/bin/setenv.sh&quot;elif [ -r &quot;$CATALINA_HOME/bin/setenv.sh&quot; ]; then . &quot;$CATALINA_HOME/bin/setenv.sh&quot;fi........ 就是在tomcat/bin目录下面，写入一个setenv.sh文件里面写入需要的环境变量，当运行catalina.sh启动脚本的时候，其会进行执行该setenv.sh文件，当前我的版本是1.8，非特殊情况其已经不需要写入CLASSPATH。(据说jdk1.5之后就不需要写入CLASSPATH了。) 123[root@ccc bin]# cat setenv.shexport JAVA_HOME=/tool/jdk1.8.0_144export PATH=$PATH:$JAVA_HOME/bin 多看官方文档，多看服务自带脚本还是非常有必要的。 Refer: https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/https://stackoverflow.com/questions/8633461/how-to-keep-environment-variables-when-using-sudohttps://segmentfault.com/q/1010000011528636/a-1020000011538128 下次写sudo su两个命令。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clean/rm/reset/revert/checkout用法和区别]]></title>
    <url>%2F2018%2F12%2F22%2Fgit-clean-rm-reset-revert-checkout%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git的工作区和暂存区先说下这两个概念：工作区，就是你git仓库的目录，你进行修改文件的区域。暂存区，git从库里面有个.git的隐藏目录，里面”有一块”，可以理解为暂存区。 工作区和缓存区如何联系起来？通过提交代码行为的步骤流程来解读: 修改代码文件 git add 修改后的代码文件 此刻的行为将该代码文件从工作区添加到了暂存区 git commit -m &#39;commit 内容&#39; 此刻的行为把暂存区的内容提交到了本地分支上 最后的git push操作只是一个将本地分支推送到远端的行为，所以先不考虑进去，只考前面三点。 查看工作区和暂存区常用的命令为git status 一般常见的是如下三种情况： 在工作区新建了文件或目录，但还未将这些文件或目录git add提交到暂存区。这些文件或目录被标记为untracked files。 123456789101112huangyisan:~/Desktop/github/test $ touch foo barhuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar foonothing added to commit but untracked files present (use &quot;git add&quot; to track) 对修改后的文件进行了git add操作，将这些文件提交到了暂存区，但未执行git commit -m &#39;xxx&#39;，未提交到本地分支。此时文件属于Changes to be committed状态 123456789101112huangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 对已经git add操作，但未提交到本地分支的文件，继续进行了修改，修改完后未进行git add，此时文件属于Changes not staged for commit状态 123456789101112131415161718huangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 已经commit到本地分支的文件，且该文件在工作区没被修改之前，其不会在git status中出现。 git checkout – file两种情况 若被checkout的文件在暂存区，但工作区修改了，也就是上面的第三种情况，此时执行该命令，被checkout的文件变成和暂存区一样的状态和内容。12345678910111213141516171819202122232425262728293031huangyisan:~/Desktop/github/test $ echo &apos;first line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foohuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 将foo文件写入’first line’内容后，用git add foo，提交到了暂存区，未commit情况下，再写入新内容’new line’,若想还原到暂存区状态，则使用命令git checkout -- foo 被修改文件不在暂存区，此时使用git checkout -- file命令，则该文件和当前版本仓库中原先的文件一致。123456789101112huangyisan:~/Desktop/github/test $ git statusOn branch masternothing to commit, working tree cleanhuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 干净的工作区，修改了foo文件，然后进行checkout操作之后，foo文件还原成了仓库中该文件原先的状态和内容。 git cleangit clean 的对象为untracked files，也就是在工作区新建，但还未执行git add命令提交到暂存区的文件或目录。1234567891011121314151617181920212223huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ touch new1 new2huangyisan:~/Desktop/github/test $ mkdir &#123;tmp1,tmp2&#125;huangyisan:~/Desktop/github/test $ lsbar foo new1 new2 tmp1 tmp2huangyisan:~/Desktop/github/test $ git clean -nWould remove new1Would remove new2huangyisan:~/Desktop/github/test $ git clean -f new1Removing new1huangyisan:~/Desktop/github/test $ git clean -df tmp1Removing tmp1/huangyisan:~/Desktop/github/test $ lsbar foo new2 tmp2huangyisan:~/Desktop/github/test $ git clean -fRemoving new2huangyisan:~/Desktop/github/test $ lsbar foo tmp2huangyisan:~/Desktop/github/test $ git clean -dfRemoving tmp2/huangyisan:~/Desktop/github/test $ lsbar foo git clean -n，干跑模式，可以列出哪些文件会被清除，但不会列出哪些目录会被清除。git clean -f，若指定文件，则该文件被清除，若不指定文件，则所有未被提交到暂存区的文件都被清除。git clean -df，若指定目录，则该目录被清除，若不指定目录，则所有未被提交到暂存区的目录都被清除。 git rmgit rm等价于rm xxx &amp;&amp; git add .。如果一个文件是被rm删除，则可以使用git checkout -- file将文件还原回来，而如果是用git rm删除，则该文件不可以被git checkout -- file。当然，如果是rm文件，然后git add操作，也是不能被git checkout -- file还原回来的。123456789101112131415huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ rm fooremove foo? yhuangyisan:~/Desktop/github/test $ lsbarhuangyisan:~/Desktop/github/test $ git checkout foohuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git rm foorm &apos;foo&apos;huangyisan:~/Desktop/github/test $ git checkout fooerror: pathspec &apos;foo&apos; did not match any file(s) known to git.huangyisan:~/Desktop/github/test $ lsbar foo文件起先被rm删除，并未提交到暂存区，所以是可以被checkout还原，后来执行了git rm，所以当使用checkout还原的时候就报错了。 git reset三种模式 –mixed 默认方式，将暂存区内容清空，回退到工作区，并且保留工作区的修改内容。 1234567891011121314151617181920212223242526272829huangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git reset HEADUnstaged changes after reset:M foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foono changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 暂存区被清空，工作区的更变被保留下来，foo文件存在new line这行内容。 –soft 暂存区内容，工作区内容都被保留，HEAD指向指定的commit号，该commit号原先的文件若有变动，则直接被add到暂存区。 123456789101112131415161718192021222324252627282930313233343536373839huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foohuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ git log --onelinee5ca64a (HEAD -&gt; master) 10ba0aa5 1ebaa828 1a2f32c5 18f89d40 updatebe60bed 1bb51c34 .df8f824 update4dbd952 update9e683fb 179dfad8 13e58cef add 194e5bf4 remove02aadbb okhuangyisan:~/Desktop/github/test $ git reset --soft 8f89d40huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foonew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: bar new file: foo 将foo的改动add到暂存区后，使用git reset --soft 8f89d40，8f89d40这个commit号原先是存在bar这个文件，且foo文件不存在，因为reset之前的内容和之后的比较出现了差异，则这些差异被add到了新的暂存区中。 –hard HEAD重置到指定commit号，且清空暂存区，工作区的内容和该commit号版本仓库的内容一致。 123456huangyisan:~/Desktop/github/test $ git reset --hard HEADHEAD is now at 14d3892 1huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foofirst line 暂存区被清空，工作区内容成了当前commit号版本仓库的内容，也就是没修改之前的内容，foo文件不存在new line行。但若工作区存在Untracked files，则这些Untracked files会携带进入到指定的commit号版本仓库的工作区中，所以要恢复到和某个commit号完全一致，还需要git clean -f清空Untracked files。 git reset会将HEAD指向的分支指向reset对应的commit，而git checkout是HEAD直接指向对应的commit。 git revert仅将某个commit号提交分支的内容撤销，且将此次撤销作为一个新的提交。 12345678910111213141516171819huangyisan:~/Desktop/github/test $ git log --oneline145af31 (HEAD -&gt; master) add newedf54e3 add fooc11842d add bar5f4b280 remove allhuangyisan:~/Desktop/github/test $ lsbar foo new new1huangyisan:~/Desktop/github/test $ git revert c11842d[master 19e736c] Revert &quot;add bar&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 barhuangyisan:~/Desktop/github/test $ lsfoo new new1huangyisan:~/Desktop/github/test $ git log --oneline19e736c (HEAD -&gt; master) Revert &quot;add bar&quot;145af31 add newedf54e3 add fooc11842d add bar5f4b280 remove all c11842d是将bar文件提交到了分支，当执行git revert c11842d,则撤销了提交bar文件到分支，所以执行完后，bar文件不见了，但foo文件依旧存在，所以revert只影响了被撤销的commit的变更内容，而且看git log，多了一个新的commit提交号19e736c。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getchar()存储类型]]></title>
    <url>%2F2018%2F12%2F20%2Fgetchar-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[getchar()返回类型声明为int类型getchar()函数从文本流读入下一个输入字符，并且作为结果返回。 一个读取字符，并且打印的程序，当读取end of file(EOF)的时候结束。123456789101112#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c != EOF) &#123; putchar(c); c = getchar(); &#125; return 0;&#125; 起先没搞明白为什么对c的声明是int类型，而不是char类型。 后来查阅资料得知，char类型的声明，会根据不同的编译器，或者不同的架构平台，可能成为unsigned char或者是signed char类型。 如果是unsigned char类型，占8位，一个字节，其范围为0000 0000 ~ 1111 1111，即0 ~ 255，那么无法存储EOF这个结束符，EOF可以理解为数值-1(C89, C99, C11并没有给EOF定义一个具体的值，只是说EOF是一个负值常量)。 而当被作为signed char类型，虽然其取值范围为-128 ~ +127，虽然能够存储EOF这个结束符，看似正常，但在linux的环境，会混淆char 255和EOF，导致输入数据的截断。 在linux平台运行以下程序 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char c; printf(&quot;Enter characters : &quot;); while((c= getchar()) != EOF)&#123; putchar(c); &#125; return 0;&#125; 输出结果可以发现\0377后面部分没有被打印。 12[root@VM_31_91_centos ~]# gcc test.c &amp;&amp; echo -e &apos;Hello world\0377And some more&apos; | ./a.outEnter characters : Hello world[root@VM_31_91_centos ~]# getchar()和putchar()初始返回的值都为int类型。对于getchar()函数返回值的声明使用int类型 打印出EOF的值123456789101112131415#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c == EOF) &#123; printf(&quot;this is the value of EOF:%d&quot;,c); c = getchar(); break; &#125; return 0;&#125; 执行程序，按CTRL+D发送EOF，查看得到的数值为-1。 refer https://stackoverflow.com/questions/18013167/why-must-the-variable-used-to-hold-getchars-return-value-be-declared-as-inthttps://stackoverflow.com/questions/35356322/difference-between-int-and-char-in-getchar-fgetc-and-putchar-fputchttps://stackoverflow.com/questions/7119470/int-c-getcharThe C Programming Language - By Kernighan and Ritchie]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[True or False]]></title>
    <url>%2F2018%2F12%2F18%2FTrue-or-False%2F</url>
    <content type="text"><![CDATA[链式比较先来看一段代码: 12&gt;&gt;&gt; 2 in [1,0] == FalseFalse 起先我认为输出的结果是True，因为 2 in [1,0] 为False，接着False == False 返回的是True。 后来发现，这个其实是链式比较(chained comparisons)，这种比较法，常见的为类似1&lt;2&lt;3这种，能立马反应过来，其实质为 1&lt;2 and 2&lt;3。所以2 in [1,0] == False的本质其实为(2 in [1,0]) and ([1,0] == False)，很显然，前面的返回为False，后面的返回也为False，False and False的结果为False，所以最终得到的结果为False。 如下比较符号进行组合，都为链式比较“&lt;” | “&gt;” | “==” | “&gt;=” | “&lt;=” | “&lt;&gt;” | “!=” | “is” [“not”] | [“not”] “in” https://docs.python.org/2/reference/expressions.html#comparisons 空字符串代码如下： 12&gt;&gt;&gt; &quot;&quot; in &quot;abc&quot;True 空字符串始终被视为任何其他字符串的子字符串，所以其返回为True。字符串的比较等价于find()方法，x in y 等价于y.find(x) != -1。当find()执行结果为-1的时候，表示x不是y的子字符串，反之，则x为y的子字符串。空字符串的执行结果如下: 12&gt;&gt;&gt; &quot;abc&quot;.find(&apos;&apos;) != -1True https://docs.python.org/3/reference/expressions.html#membership-test-operations]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
</search>
