<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F27%2Fcentos7%E7%BD%91%E5%8D%A1%E6%94%B9%E5%90%8D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[从无法加载JAVA_HOME说起]]></title>
    <url>%2F2018%2F12%2F25%2F%E4%BB%8E%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDJAVA-HOME%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[这几天在做jenkins cicd的事儿，用sudo的方式启动tomcat，直接报出无法找到JAVA_HOME。当时挺纳闷的，因为我在/etc/profile里面是添加了JAVA_HOME。123456789[root@ccc bin]# sudo ./catalina.sh startNeither the JAVA_HOME nor the JRE_HOME environment variable is definedAt least one of these environment variable is needed to run this program[root@ccc bin]# tail -n 5 /etc/profileexport JAVA_HOME=/tool/jdk1.8.0_144export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 如此如此，出现了两个疑问。 为什么/etc/profile的内容无法被加载？ 在/etc/profile里面写入jdk环境变量是否合适？ 为什么/etc/profile的内容无法被加载？先说下一个概念，linux的用户交互模式。在linux中用户交互模式可以分为两类： Interactive Shell Non-Interactive Shell Interactive Shell 顾名思义，就是登陆用户可以和shell进行交互的，比如你用xshell上一台服务器，出现的terminal就是属于Interactive Shell方式。Non-Interactive Shell 非交互的模式，比如用crontab的方式执行一个shell脚本。 那么问题就来了，这两种模式的环境变量从哪里去获取呢？ Interactive Shell登录情况 123456789101112execute /etc/profileIF ~/.bash_profile exists THEN execute ~/.bash_profileELSE IF ~/.bash_login exist THEN execute ~/.bash_login ELSE IF ~/.profile exist THEN execute ~/.profile END IF END IFEND IF 一目了然，入口为/etc/profile文件。其中在.bash_profile里面还判断是否存在~/.bashrc，如果存在则加载~/.bashrc。 12if [ -f ~/.bashrc ]; then . ~/.bashrc 还没完，在执行~/.bashrc的时候里面继续判断是否存在/etc/bashrc，如果存在则执行/etc/bashrc。 123if [ -f /etc/bashrc ]; then . /etc/bashrcfi 顺带一说，当用户退出Interactive Shell的时候，执行~/.bash_logout内容。所以可以在退出的时候定义一些行为。 123IF ~/.bash_logout exists THEN execute ~/.bash_logoutEND IF 总结下Interactive Shell的顺序： /etc/profile ~/.bash_profile ~/.bashrc /etc/bashrc ~/.bash_login ~/.profile ~/.bash_logout (当且仅当退出Interactive Shell的时候执行) Non-Interactive Shell的情况 123IF ~/.bashrc exists THEN execute ~/.bashrcEND IF 直接去执行的~/.bashrc，该文件也会判断是否存在/etc/bashrc，存在则执行/etc/bashrc。 总结下Non-Interactive Shell的顺序： ~/.bashrc /etc/bashrc 看似原因好像是因为sudo ./catalina.sh start进入了Non-Interactive Shell，从而没加载/etc/profile，其实并不是这样的。sudo在这边搞出了幺蛾子？ sudo做了啥？命令输入visudo，有那么一节内容： 1234567891011121314# Preserving HOME has security implications since many programs# use it when searching for configuration files. Note that HOME# is already set when the the env_reset option is enabled, so# this option is only effective for configurations where either# env_reset is disabled or HOME is present in the env_keep list.#Defaults always_set_homeDefaults env_resetDefaults env_keep = &quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS&quot;Defaults env_keep += &quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;Defaults env_keep += &quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;Defaults env_keep += &quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;Defaults env_keep += &quot;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot; 其行为会将env reset，但是会保留部分环境变量。这一行为导致了sudo ./catalina.sh start无法寻找到jdk变量。 比较差劲的解决方法：man一下sudo，有个-E的参数，能保留之前的环境变量，但是不推荐这样做，因为有安全隐患： 123-E The -E (preserve environment) option indicates to the security policy that the user wishes to preserve their existing environment variables. The security policy may return an error if the -E option is specified and the user does not have permission to preserve the environment. 1234567[root@ccc bin]# sudo -E ./catalina.sh startUsing CATALINA_BASE: /opt/mixcdn-tomcatUsing CATALINA_HOME: /opt/mixcdn-tomcatUsing CATALINA_TMPDIR: /opt/mixcdn-tomcat/tempUsing JRE_HOME: /tool/jdk1.8.0_144Using CLASSPATH: /opt/mixcdn-tomcat/bin/bootstrap.jar:/opt/mixcdn-tomcat/bin/tomcat-juli.jarTomcat started. 好的解决方法在下面： 在/etc/profile里面写入jdk环境变量是否合适？针对部署tomcat的jdk环境，很多文档，包括我自己，之前也是从别人那边拿来的部署jdk文档，将jdk环境变量写入/etc/profile，等文件中，这个观念基本上贯穿了我整个运维生涯。 其实官方给出了写法，在catalina.sh里面: 12345678910111213141516171819202122232425262728# Control Script for the CATALINA Server## Environment Variable Prerequisites## Do not set the variables in this script. Instead put them into a script# setenv.sh in CATALINA_BASE/bin to keep your customizations separate.## CATALINA_HOME May point at your Catalina &quot;build&quot; directory.## CATALINA_BASE (Optional) Base directory for resolving dynamic portions# of a Catalina installation. If not present, resolves to........# Ensure that any user defined CLASSPATH variables are not used on startup,# but allow them to be specified in setenv.sh, in rare case when it is needed.CLASSPATH=if [ -r &quot;$CATALINA_BASE/bin/setenv.sh&quot; ]; then . &quot;$CATALINA_BASE/bin/setenv.sh&quot;elif [ -r &quot;$CATALINA_HOME/bin/setenv.sh&quot; ]; then . &quot;$CATALINA_HOME/bin/setenv.sh&quot;fi........ 就是在tomcat/bin目录下面，写入一个setenv.sh文件里面写入需要的环境变量，当运行catalina.sh启动脚本的时候，其会进行执行该setenv.sh文件，当前我的版本是1.8，非特殊情况其已经不需要写入CLASSPATH。(据说jdk1.5之后就不需要写入CLASSPATH了。) 123[root@ccc bin]# cat setenv.shexport JAVA_HOME=/tool/jdk1.8.0_144export PATH=$PATH:$JAVA_HOME/bin 多看官方文档，多看服务自带脚本还是非常有必要的。 Refer: https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/https://stackoverflow.com/questions/8633461/how-to-keep-environment-variables-when-using-sudohttps://segmentfault.com/q/1010000011528636/a-1020000011538128 下次写sudo su两个命令。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clean/rm/reset/revert/checkout用法和区别]]></title>
    <url>%2F2018%2F12%2F22%2Fgit-clean-rm-reset-revert-checkout%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git的工作区和暂存区先说下这两个概念：工作区，就是你git仓库的目录，你进行修改文件的区域。暂存区，git从库里面有个.git的隐藏目录，里面”有一块”，可以理解为暂存区。 工作区和缓存区如何联系起来？通过提交代码行为的步骤流程来解读: 修改代码文件 git add 修改后的代码文件 此刻的行为将该代码文件从工作区添加到了暂存区 git commit -m &#39;commit 内容&#39; 此刻的行为把暂存区的内容提交到了本地分支上 最后的git push操作只是一个将本地分支推送到远端的行为，所以先不考虑进去，只考前面三点。 查看工作区和暂存区常用的命令为git status 一般常见的是如下三种情况： 在工作区新建了文件或目录，但还未将这些文件或目录git add提交到暂存区。这些文件或目录被标记为untracked files。 123456789101112huangyisan:~/Desktop/github/test $ touch foo barhuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar foonothing added to commit but untracked files present (use &quot;git add&quot; to track) 对修改后的文件进行了git add操作，将这些文件提交到了暂存区，但未执行git commit -m &#39;xxx&#39;，未提交到本地分支。此时文件属于Changes to be committed状态 123456789101112huangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 对已经git add操作，但未提交到本地分支的文件，继续进行了修改，修改完后未进行git add，此时文件属于Changes not staged for commit状态 123456789101112131415161718huangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 已经commit到本地分支的文件，且该文件在工作区没被修改之前，其不会在git status中出现。 git checkout – file两种情况 若被checkout的文件在暂存区，但工作区修改了，也就是上面的第三种情况，此时执行该命令，被checkout的文件变成和暂存区一样的状态和内容。12345678910111213141516171819202122232425262728293031huangyisan:~/Desktop/github/test $ echo &apos;first line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foohuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 将foo文件写入’first line’内容后，用git add foo，提交到了暂存区，未commit情况下，再写入新内容’new line’,若想还原到暂存区状态，则使用命令git checkout -- foo 被修改文件不在暂存区，此时使用git checkout -- file命令，则该文件和当前版本仓库中原先的文件一致。123456789101112huangyisan:~/Desktop/github/test $ git statusOn branch masternothing to commit, working tree cleanhuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 干净的工作区，修改了foo文件，然后进行checkout操作之后，foo文件还原成了仓库中该文件原先的状态和内容。 git cleangit clean 的对象为untracked files，也就是在工作区新建，但还未执行git add命令提交到暂存区的文件或目录。1234567891011121314151617181920212223huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ touch new1 new2huangyisan:~/Desktop/github/test $ mkdir &#123;tmp1,tmp2&#125;huangyisan:~/Desktop/github/test $ lsbar foo new1 new2 tmp1 tmp2huangyisan:~/Desktop/github/test $ git clean -nWould remove new1Would remove new2huangyisan:~/Desktop/github/test $ git clean -f new1Removing new1huangyisan:~/Desktop/github/test $ git clean -df tmp1Removing tmp1/huangyisan:~/Desktop/github/test $ lsbar foo new2 tmp2huangyisan:~/Desktop/github/test $ git clean -fRemoving new2huangyisan:~/Desktop/github/test $ lsbar foo tmp2huangyisan:~/Desktop/github/test $ git clean -dfRemoving tmp2/huangyisan:~/Desktop/github/test $ lsbar foo git clean -n，干跑模式，可以列出哪些文件会被清除，但不会列出哪些目录会被清除。git clean -f，若指定文件，则该文件被清除，若不指定文件，则所有未被提交到暂存区的文件都被清除。git clean -df，若指定目录，则该目录被清除，若不指定目录，则所有未被提交到暂存区的目录都被清除。 git rmgit rm等价于rm xxx &amp;&amp; git add .。如果一个文件是被rm删除，则可以使用git checkout -- file将文件还原回来，而如果是用git rm删除，则该文件不可以被git checkout -- file。当然，如果是rm文件，然后git add操作，也是不能被git checkout -- file还原回来的。123456789101112131415huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ rm fooremove foo? yhuangyisan:~/Desktop/github/test $ lsbarhuangyisan:~/Desktop/github/test $ git checkout foohuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git rm foorm &apos;foo&apos;huangyisan:~/Desktop/github/test $ git checkout fooerror: pathspec &apos;foo&apos; did not match any file(s) known to git.huangyisan:~/Desktop/github/test $ lsbar foo文件起先被rm删除，并未提交到暂存区，所以是可以被checkout还原，后来执行了git rm，所以当使用checkout还原的时候就报错了。 git reset三种模式 –mixed 默认方式，将暂存区内容清空，回退到工作区，并且保留工作区的修改内容。 1234567891011121314151617181920212223242526272829huangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git reset HEADUnstaged changes after reset:M foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foono changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 暂存区被清空，工作区的更变被保留下来，foo文件存在new line这行内容。 –soft 暂存区内容，工作区内容都被保留，HEAD指向指定的commit号，该commit号原先的文件若有变动，则直接被add到暂存区。 123456789101112131415161718192021222324252627282930313233343536373839huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foohuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ git log --onelinee5ca64a (HEAD -&gt; master) 10ba0aa5 1ebaa828 1a2f32c5 18f89d40 updatebe60bed 1bb51c34 .df8f824 update4dbd952 update9e683fb 179dfad8 13e58cef add 194e5bf4 remove02aadbb okhuangyisan:~/Desktop/github/test $ git reset --soft 8f89d40huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foonew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: bar new file: foo 将foo的改动add到暂存区后，使用git reset --soft 8f89d40，8f89d40这个commit号原先是存在bar这个文件，且foo文件不存在，因为reset之前的内容和之后的比较出现了差异，则这些差异被add到了新的暂存区中。 –hard HEAD重置到指定commit号，且清空暂存区，工作区的内容和该commit号版本仓库的内容一致。 123456huangyisan:~/Desktop/github/test $ git reset --hard HEADHEAD is now at 14d3892 1huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foofirst line 暂存区被清空，工作区内容成了当前commit号版本仓库的内容，也就是没修改之前的内容，foo文件不存在new line行。但若工作区存在Untracked files，则这些Untracked files会携带进入到指定的commit号版本仓库的工作区中，所以要恢复到和某个commit号完全一致，还需要git clean -f清空Untracked files。 git reset会将HEAD指向的分支指向reset对应的commit，而git checkout是HEAD直接指向对应的commit。 git revert仅将某个commit号提交分支的内容撤销，且将此次撤销作为一个新的提交。 12345678910111213141516171819huangyisan:~/Desktop/github/test $ git log --oneline145af31 (HEAD -&gt; master) add newedf54e3 add fooc11842d add bar5f4b280 remove allhuangyisan:~/Desktop/github/test $ lsbar foo new new1huangyisan:~/Desktop/github/test $ git revert c11842d[master 19e736c] Revert &quot;add bar&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 barhuangyisan:~/Desktop/github/test $ lsfoo new new1huangyisan:~/Desktop/github/test $ git log --oneline19e736c (HEAD -&gt; master) Revert &quot;add bar&quot;145af31 add newedf54e3 add fooc11842d add bar5f4b280 remove all c11842d是将bar文件提交到了分支，当执行git revert c11842d,则撤销了提交bar文件到分支，所以执行完后，bar文件不见了，但foo文件依旧存在，所以revert只影响了被撤销的commit的变更内容，而且看git log，多了一个新的commit提交号19e736c。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getchar()存储类型]]></title>
    <url>%2F2018%2F12%2F20%2Fgetchar-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[getchar()返回类型声明为int类型getchar()函数从文本流读入下一个输入字符，并且作为结果返回。 一个读取字符，并且打印的程序，当读取end of file(EOF)的时候结束。123456789101112#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c != EOF) &#123; putchar(c); c = getchar(); &#125; return 0;&#125; 起先没搞明白为什么对c的声明是int类型，而不是char类型。 后来查阅资料得知，char类型的声明，会根据不同的编译器，或者不同的架构平台，可能成为unsigned char或者是signed char类型。 如果是unsigned char类型，占8位，一个字节，其范围为0000 0000 ~ 1111 1111，即0 ~ 255，那么无法存储EOF这个结束符，EOF可以理解为数值-1(C89, C99, C11并没有给EOF定义一个具体的值，只是说EOF是一个负值常量)。 而当被作为signed char类型，虽然其取值范围为-128 ~ +127，虽然能够存储EOF这个结束符，看似正常，但在linux的环境，会混淆char 255和EOF，导致输入数据的截断。 在linux平台运行以下程序 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char c; printf(&quot;Enter characters : &quot;); while((c= getchar()) != EOF)&#123; putchar(c); &#125; return 0;&#125; 输出结果可以发现\0377后面部分没有被打印。 12[root@VM_31_91_centos ~]# gcc test.c &amp;&amp; echo -e &apos;Hello world\0377And some more&apos; | ./a.outEnter characters : Hello world[root@VM_31_91_centos ~]# getchar()和putchar()初始返回的值都为int类型。对于getchar()函数返回值的声明使用int类型 打印出EOF的值123456789101112131415#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c == EOF) &#123; printf(&quot;this is the value of EOF:%d&quot;,c); c = getchar(); break; &#125; return 0;&#125; 执行程序，按CTRL+D发送EOF，查看得到的数值为-1。 refer https://stackoverflow.com/questions/18013167/why-must-the-variable-used-to-hold-getchars-return-value-be-declared-as-inthttps://stackoverflow.com/questions/35356322/difference-between-int-and-char-in-getchar-fgetc-and-putchar-fputchttps://stackoverflow.com/questions/7119470/int-c-getcharThe C Programming Language - By Kernighan and Ritchie]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[True or False]]></title>
    <url>%2F2018%2F12%2F18%2FTrue-or-False%2F</url>
    <content type="text"><![CDATA[链式比较先来看一段代码: 12&gt;&gt;&gt; 2 in [1,0] == FalseFalse 起先我认为输出的结果是True，因为 2 in [1,0] 为False，接着False == False 返回的是True。 后来发现，这个其实是链式比较(chained comparisons)，这种比较法，常见的为类似1&lt;2&lt;3这种，能立马反应过来，其实质为 1&lt;2 and 2&lt;3。所以2 in [1,0] == False的本质其实为(2 in [1,0]) and ([1,0] == False)，很显然，前面的返回为False，后面的返回也为False，False and False的结果为False，所以最终得到的结果为False。 如下比较符号进行组合，都为链式比较“&lt;” | “&gt;” | “==” | “&gt;=” | “&lt;=” | “&lt;&gt;” | “!=” | “is” [“not”] | [“not”] “in” https://docs.python.org/2/reference/expressions.html#comparisons 空字符串代码如下： 12&gt;&gt;&gt; &quot;&quot; in &quot;abc&quot;True 空字符串始终被视为任何其他字符串的子字符串，所以其返回为True。字符串的比较等价于find()方法，x in y 等价于y.find(x) != -1。当find()执行结果为-1的时候，表示x不是y的子字符串，反之，则x为y的子字符串。空字符串的执行结果如下: 12&gt;&gt;&gt; &quot;abc&quot;.find(&apos;&apos;) != -1True https://docs.python.org/3/reference/expressions.html#membership-test-operations]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
