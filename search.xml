<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树遍历]]></title>
    <url>%2F2019%2F02%2F12%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[遍历方式 前序遍历(深度优先) 中序遍历(深度优先) 后序遍历(深度优先) 层级遍历(广度优先)]]></content>
      <tags>
        <tag>python3</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp_max_syn_backlog和net.core.somaxconn]]></title>
    <url>%2F2019%2F02%2F11%2Ftcp_max_syn_backlog%E5%92%8Csomaxconn%2F</url>
    <content type="text"><![CDATA[kernel 3.10.0-693.2.2.el7.x86_64 两个队列tcp的建联存在两种状态 incomplete connection queue 未建联的队列 completed connection queue 已建联的队列 未建联的队列 客户端发出syn请求，并且已经达到服务端，服务端返回syn+ack,等待对端响应ack时候的队列。 这些套接口处于SYN_RCVD状态。 已建联的队列 客户端发送建联请求，并且已经和服务端完成了三次握手，但此时这个socket还未被程序使用。(如何拿出来使用，则需要调用accept()函数) 这些套接口处于ESTABLISHED状态。 listen()和accept()函数三次握手图 一段python服务端网络编程代码： 1234567891011121314import sockets = socket.socket()host = &quot;0.0.0.0&quot;port = 12345s.bind((host, port))BACKLOG = 5s.listen(BACKLOG)while True: c, addr = s.accept() print(&quot;conn addr : &quot;, addr) c.send(&quot;hello word&quot;) c.close() 上述代码listen()和accept()解释如下 listen()函数listen()函数的主要作用就是将套接字(sockfd)变成被动的连接监听套接字(被动等待客户端的连接)。 accept()函数从处于 completed connection queue状态的连接队列头部取出一个已经完成的连接，如这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。 如果程序不调用accept()函数，那么连接socket一直滞留在completed connection queue队列里面，进而未被程序消费使用。 比如如下代码: 123456789101112import socketimport times = socket.socket()host = &quot;0.0.0.0&quot;port = 12345s.bind((host, port))BACKLOG = 5s.listen(BACKLOG)print(&apos;listening&apos;)time.sleep(3600) somaxconnThe behavior of the backlog argument on TCP sockets changed with Linux 2.2. Now it specifies the queue length for completely established sockets waiting to be accepted, instead of the number of incomplete connection requests. If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value 128. somaxconn用来指定系统定义的建联队列的长度(ESTAB状态的连接数量)。 若程序中定义的listen函数的backlog大于系统定义的，则以系统定义为准。 代码实践 somaxconnpython的一个不含accept()的服务端代码，这样可以让socket滞留在completed connection queue队列里面。 123456789101112import socketimport times = socket.socket(socket.AF_INET, socket.SOCK_STREAM)host = &quot;0.0.0.0&quot;port = 12345s.bind((host, port))BACKLOG = 2s.listen(BACKLOG)print(&apos;listening&apos;)time.sleep(3600) 查看下系统somaxconn的值：12[root@leanote ~]# sysctl -a | grep somaxconnnet.core.somaxconn = 128 启动进程，先不使用客户端进行连接，使用ss查看进程pid。 123[root@leanote ~]# ss -anpl | egrep &quot;10187|Recv-Q&quot;Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port tcp LISTEN 0 5 *:12345 *:* users:((&quot;python3&quot;,pid=10187,fd=3)) 这里涉及到Recv-Q和Send-Q两个字段，这两个字段的含义和前面state字段为何种状态密不可分，解释如下 Recv-Q Established: The count of bytes not copied by the user program connected to this socket.(套接字缓冲还没有被应用程序取走的字节数) Listening: Since Kernel 2.6.18 this column contains the current syn backlog. (当前syn backlog为backlog+1) Send-Q Established: The count of bytes not acknowledged by the remote host.(没有被远端确认的字节数) Listening: Since Kernel 2.6.18 this column contains the maximum size of the syn backlog. Send-Q 对应的值是5，这个值也就是代码中listen()中BACKLOG的值。 此时如果调整BACKLOG至256，重新启动进程，然后用ss查看信息： 123456789101112import socketimport times = socket.socket(socket.AF_INET, socket.SOCK_STREAM)host = &quot;0.0.0.0&quot;port = 12345s.bind((host, port))BACKLOG = 256s.listen(BACKLOG)print(&apos;listening&apos;)time.sleep(3600) 123[root@leanote ~]# ss -anp |egrep &quot;12345|Recv-Q&quot;Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port tcp LISTEN 0 128 *:12345 *:* users:((&quot;python3&quot;,pid=19593,fd=3)) Send-Q被系统somaxcon限制为128，调整系统somaxcon的值后，重启进程，然后ss继续观察 12[root@leanote ~]# sysctl net.core.somaxconn=65522net.core.somaxconn = 65522 123[root@leanote ~]# ss -anp |egrep &quot;12345|Recv-Q&quot;Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port tcp LISTEN 0 256 *:12345 *:* users:((&quot;python3&quot;,pid=19839,fd=3)) 变成了程序代码里定义的BACKLOG值了。 让客户端进行建联 客户端代码： 12345678910import socketimport timehost = &apos;122.152.220.151&apos;port = 12345sockets=[]while True: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) sockets.append(s) time.sleep(10) 代码中BACKLOG修改为2 使用ss观察服务端 1234567891011[root@leanote ~]# ss -anp |egrep &quot;12345|Recv-Q&quot;Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port tcp LISTEN 3 2 *:12345 *:* users:((&quot;python3&quot;,pid=20361,fd=3))tcp SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:35986 tcp SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:36012 tcp SYN-RECV 0 0 10.105.31.91:12345 89.248.167.131:56380 tcp SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:35994 tcp SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:36002 tcp ESTAB 0 0 10.105.31.91:12345 118.24.105.81:35972 tcp ESTAB 0 0 10.105.31.91:12345 118.24.105.81:35952 tcp ESTAB 0 0 10.105.31.91:12345 118.24.105.81:35960 建联3个后(ESTAB),其他请求一直处于SYN-RECV状态。 Recv-Q为3，表示当前syn backlog为3 ,backlog+1的结果(2+1)。 当BACKLOG满的时候，抓包情况：123456789101112131415[root@leanote ~]# tcpdump -i any port 12345 -nnn &gt; 111[root@leanote ~]# cat 111 | grep 3718216:11:58.519076 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [S], seq 1450185841, win 29200, options [mss 1424,sackOK,TS val 3561765739 ecr 0,nop,wscale 7], length 016:11:58.519145 IP 10.105.31.91.12345 &gt; 118.24.105.81.37182: Flags [S.], seq 1044766216, ack 1450185842, win 28960, options [mss 1460,sackOK,TS val 3121876725 ecr 3561765739,nop,wscale 7], length 016:11:58.578420 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [.], ack 1, win 229, options [nop,nop,TS val 3561765798 ecr 3121876725], length 016:11:59.853632 IP 10.105.31.91.12345 &gt; 118.24.105.81.37182: Flags [S.], seq 1044766216, ack 1450185842, win 28960, options [mss 1460,sackOK,TS val 3121878060 ecr 3561765798,nop,wscale 7], length 016:11:59.912872 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [.], ack 1, win 229, options [nop,nop,TS val 3561767133 ecr 3121876725], length 016:12:02.053621 IP 10.105.31.91.12345 &gt; 118.24.105.81.37182: Flags [S.], seq 1044766216, ack 1450185842, win 28960, options [mss 1460,sackOK,TS val 3121880260 ecr 3561767133,nop,wscale 7], length 016:12:02.112871 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [.], ack 1, win 229, options [nop,nop,TS val 3561769333 ecr 3121876725], length 016:12:06.253625 IP 10.105.31.91.12345 &gt; 118.24.105.81.37182: Flags [S.], seq 1044766216, ack 1450185842, win 28960, options [mss 1460,sackOK,TS val 3121884460 ecr 3561769333,nop,wscale 7], length 016:12:06.312908 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [.], ack 1, win 229, options [nop,nop,TS val 3561773533 ecr 3121876725], length 016:12:14.253636 IP 10.105.31.91.12345 &gt; 118.24.105.81.37182: Flags [S.], seq 1044766216, ack 1450185842, win 28960, options [mss 1460,sackOK,TS val 3121892460 ecr 3561773533,nop,wscale 7], length 016:12:14.312821 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [.], ack 1, win 229, options [nop,nop,TS val 3561781533 ecr 3121876725], length 016:12:30.253631 IP 10.105.31.91.12345 &gt; 118.24.105.81.37182: Flags [S.], seq 1044766216, ack 1450185842, win 28960, options [mss 1460,sackOK,TS val 3121908460 ecr 3561781533,nop,wscale 7], length 016:12:30.312821 IP 118.24.105.81.37182 &gt; 10.105.31.91.12345: Flags [.], ack 1, win 229, options [nop,nop,TS val 3561797533 ecr 3121876725], length 0 对客户端一直发送syn+ack包。([S.] S表示syn，.表示ack)6次后，不再继续发送 虽然服务端ESTAB状态只有3个，但是对客户端而言，存在多个 1234567891011121314151617181920212223242526272829303132[root@VM_0_15_centos ~]# netstat -ant | grep 12345tcp 0 0 172.27.0.15:37326 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37410 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37312 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37242 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37232 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37360 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37266 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37442 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37458 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37468 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37214 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37392 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37282 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37292 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37182 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37174 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37222 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37370 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37400 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37430 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37206 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37418 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37342 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37352 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37252 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37384 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37334 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37274 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37450 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37300 122.152.220.151:12345 ESTABLISHEDtcp 0 0 172.27.0.15:37192 122.152.220.151:12345 ESTABLISHED 对于客户端而言，服务端发送了syn+ack已经算是三次握手成功了。 tcp_max_syn_backlogThe maximum number of queued connection requests which have still not received an acknowledgement from the connecting client. If this number is exceeded, the kernel will begin drop-ping requests.The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog. When syncookies are enabled there is no logical maximum length and this setting is ignored tcp_max_syn_backlog用来定义未建联的SYN-RECV状态队列长度。 当启用syncookies功能的时候，tcp_max_syn_backlog的功能将被忽视。 ###代码实践 tcp_max_syn_backlog 查看下系统tcp_max_syn_backlog的值：[root@leanote ~]# sysctl -a | grep tcp_max_syn_backlognet.ipv4.tcp_max_syn_backlog = 128 服务端ss查看1234567891011[root@leanote ~]# netstat -ant | grep 12345tcp 3 0 0.0.0.0:12345 0.0.0.0:* LISTEN tcp 0 0 10.105.31.91:12345 118.24.105.81:37926 SYN_RECV tcp 0 0 10.105.31.91:12345 118.24.105.81:37894 SYN_RECV tcp 0 0 10.105.31.91:12345 118.24.105.81:37944 SYN_RECV tcp 0 0 10.105.31.91:12345 118.24.105.81:37936 SYN_RECV tcp 0 0 10.105.31.91:12345 118.24.105.81:37908 SYN_RECV tcp 0 0 10.105.31.91:12345 118.24.105.81:37918 SYN_RECV tcp 0 0 10.105.31.91:12345 118.24.105.81:37874 ESTABLISHEDtcp 0 0 10.105.31.91:12345 118.24.105.81:37864 ESTABLISHEDtcp 0 0 10.105.31.91:12345 118.24.105.81:37882 ESTABLISHED 输出发现SYN_RECV状态状态很多，虽然连接处于SYN_RECV，一段时间后，自动删除，但是通过调整tcp_max_syn_backlog的值可以调整同一时间内SYN_RECV的数量。 调整成为2个：12[root@leanote ~]# sysctl net.ipv4.tcp_max_syn_backlog=2net.ipv4.tcp_max_syn_backlog = 2 因为当syncookies功能开启的时候，tcp_max_syn_backlog不会发挥作用，所以syncookies也得暂停：12[root@leanote ~]# sysctl net.ipv4.tcp_syncookies=0net.ipv4.tcp_syncookies = 0 客户端服务端重启，然后ss查看状态：12345678[root@leanote ~]# ss -ant | grep 12345LISTEN 3 2 *:12345 *:* SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:38456 SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:38470 SYN-RECV 0 0 10.105.31.91:12345 118.24.105.81:38398 ESTAB 0 0 10.105.31.91:12345 118.24.105.81:38280 ESTAB 0 0 10.105.31.91:12345 118.24.105.81:38264 ESTAB 0 0 10.105.31.91:12345 118.24.105.81:38272 这个syn_backlog设定的是2，但观察SYN-RECV最多出现3个。可能也是syn_backlog+1。待考证。 12345678910111213141516[root@leanote ~]# netstat -s | grep drop 20 dropped because of missing route 19 ICMP packets dropped because they were out-of-window 92307 SYNs to LISTEN sockets dropped [root@leanote ~]# dmesg | tail -n 10[3124021.575444] TCP: drop open request from 118.24.105.81/38910[3124025.583391] TCP: drop open request from 118.24.105.81/38910[3124033.599301] TCP: drop open request from 118.24.105.81/38910[3124049.647044] TCP: drop open request from 118.24.105.81/38910[3124111.900356] TCP: drop open request from 118.24.105.81/38996[3124112.902233] TCP: drop open request from 118.24.105.81/38996[3124114.908171] TCP: drop open request from 118.24.105.81/38996[3124118.916112] TCP: drop open request from 118.24.105.81/38996[3124126.924020] TCP: drop open request from 118.24.105.81/38996[3124142.955770] TCP: drop open request from 118.24.105.81/38996 服务器开始丢弃syn包，以及丢弃从客户端发送来的新连接。 总结 tcp_max_syn_backlog用来定义未建联的SYN-RECV状态队列长度。但当启用syncookies功能的时候失效。 somaxconn会限制listen()函数中BACKLOG的值。 somaxconn在高并发下需要调整，默认128绝逼不够用。 refer https://www.jianshu.com/p/30b861cac826https://www.jianshu.com/p/7fde92785056https://linux.die.net/man/2/listenhttp://www.agr.unideb.hu/~agocs/informatics/11_e_unix/unixhelp/unixhelp.ed.ac.uk/CGI/man-cgiaa65.html?tcp+7http://zake7749.github.io/2015/03/17/SocketProgramming/http://man7.org/linux/man-pages/man2/accept.2.htmlhttps://blog.csdn.net/tennysonsky/article/details/45621341]]></content>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux平均负载]]></title>
    <url>%2F2019%2F02%2F05%2Flinux%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[linux平负载定义 单位时间内，处于运行或者准备运行(R)，以及不可中断睡眠进程(D)数量的平均值(指数平滑法)。 和cpu使用率没有直接关系。 负载上升，可能是cpu使用率过高，也可能是磁盘io问题。 平均负载算法其算法为指数平滑法，内核因为不可以直接做浮点运算，而选择定点运算的方式来计算指数平滑法。 指数平滑法公式： linux 2.6.18内核 loadt = loadt-1 α + n (1 – α)，[0 &lt; α &lt; 1] linux 3.12内核 loadt = loadt-1 α + n (1 – α) + z，[0 &lt; α &lt; 1] 3.12内核增加了修正值z。 loadt表示当前时刻一段时间内的平滑均值。loadt-1表示上一时间段的平滑均值。α Linux Kernel要计算的是前1min, 5min, 15min的Load 均值，α需要分别选取。Linux Kernel选取的是: e-5/(60m)5:表示5s，作分子。60:表示60s。m: 表示分钟，1, 5, 15。 60 m作为分母。把m带入到公式计算，分别能计算出0.920044415，0.983471454，0.994459848 参考文档: http://brytonlee.github.io/blog/2014/05/07/linux-kernel-load-average-calc/ multi-core vs multi-processor load关注机器有多少个processor 1234此公式包含超线程数。[root@leanote ~]# cat /proc/cpuinfo | grep &quot;processor&quot; | wc -l1[root@leanote ~]# core可以理解为核心数，也就是cpu核心总数，而processor理解为逻辑cpu个数，而非真实cpu个数，这个逻辑cpu个数等于top后按1查看到的结果。 linux查看cpu信息总核数 = 物理CPU个数 X 每颗物理CPU的核数总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数 查看物理CPU个数cat /proc/cpuinfo| grep “physical id”| sort| uniq| wc -l 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep “cpu cores”| uniq 查看逻辑CPU的个数cat /proc/cpuinfo| grep “processor”| wc -l refer http://brytonlee.github.io/blog/2014/05/07/linux-kernel-load-average-calc/]]></content>
      <tags>
        <tag>linux</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kill -9 不起作用]]></title>
    <url>%2F2019%2F02%2F02%2Fkill-9%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[案例在公司压测，因为担心磁盘读写影响性能，所以磁盘通过nfs挂载。之后发现挂载内容无法进行读取，于是乎想重新挂载，umount命令下去，提示Device is busy，那就是铁定挂载目录或者文件被进程占用了，随之查询到了进程，打算用kill pid让进程暂停，但发现没有成功，随后用kill -9 pid强制暂停，但发现也没成功，进程pid一直存在，进程也未退出。 原因谷歌查询了下，得到了一个准确的回答。原文见refer。 kill不论发送任何信号，都是异步传递信号，内核传递信号给pid存在非常小的时间，但即便如此小的时间，也是需要进程腾出这么个时间点来接受，并处理，但如果进程当时处于阻止信号状态，那么发送过去的信号会被队列，等进程不在阻止信号后再传入，并且执行信号。 通常情况下，进程不会阻止信号，但是如果此时进程调用内核代码(系统调用)，而内核代码是可以阻止信号传入的。当中断系统调用会导致内核中某处形成错误的数据结构，或者内核一些不变量被违反的时候，内核代码会阻塞所有信号传入。所以，若出现bug或其他异常情况触发了无限期的系统调用阻塞，那么就无法传递kill发送的信号。 在系统调用中被阻塞的进程，一般称为不可中断进程，通过ps或者top，查看状态为D的进程，一般磁盘读写数据的时候是处于不可中断进程状态。 一个典型的例子就是nfs挂载的情况，当server没有响应的时候，往往会一直处于不可中断情况。 解决方法暂停server端和clinet端的nfs进程，重新挂载解决。 top ps查看不可中断进程1ps -eo pid,ppid,stat,pri,uid 进程状态常见标记符 R 表示进程正在Cpu的就绪队列中，正在运行或者正在等待运行。 D 是disk sleep缩写，也就是不可中断状态睡眠，一般表示进程正在和硬件交互，而交互过程不允许被其他进程或中断打断。 Z 僵尸进程，实际上进程已经结束，但是父进程没有回收他的资源，比如进程描述符，pid等。 S 是interruptible sleep缩写，表示可中断状态睡眠，表示进程因为等待某个事件而被挂起，当进程等到事件发生时，他会被唤醒进入R状态。 I 是idle缩写，也是空闲状态，用在不可中断睡眠的内核线程上。前面的D是表示硬件交互导致的不可中断，但对某些内核线程来说，他们有可能实际上并没有任何负载，这边用Idle为了区分这种情况。D状态进程会导致平均负载升高，I状态的进程却不会。 T 表示stopped状态，表示进程处于暂停状态(十字符病毒，一般都先对进程stop，然后排查问题)，发送SIGSTP就可以让进程暂停，再发送SIGCONT信号，则恢复运行。 t 表示跟踪状态。比如用gdb调试进程。 X 表示Dead，进程已经消亡，所以在ps或者top里面无法看到。 refer: https://cis.temple.edu/~ingargio/cis307/readings/signals.htmlhttps://unix.stackexchange.com/questions/5642/what-if-kill-9-does-not-workhttps://www.cnblogs.com/my_life/articles/5630903.html]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setdefault方法传入函数]]></title>
    <url>%2F2019%2F02%2F01%2Fsetdefault%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[setdefault()方法myvalue = dict_a.setdefault(a,b) 从dict_a中获取a的值，如果没有，则新增一个value为b，key为a的键值对。 案例请求获取一个数值，如果字典中存在这个值，则从字典内获取，如果不存在，则从api函数调用。 于是用了setdefault()方法，代码大致如下: 12345dict_a = &#123;&#125;for i in xxxx: myvalue = dict_a.setdefault(a,func_api()) xxxxx xxx 因为func_api()函数会请求线上，调用接口。 但是实现的时候，却发现，每次对myvalue赋值的时候，都会调用线上api接口。 猜测setdefault的逻辑，即便能通过指定的key获取到value，其default行为还是被执行。 验证猜测同时也验证了字典get方法 123456789101112&gt;&gt;&gt; def b():... print(2)... return 1... &gt;&gt;&gt; a_dict = &#123;&#125;&gt;&gt;&gt; a_dict=&#123;&quot;a&quot;:1&#125;&gt;&gt;&gt; a_dict.setdefault(&quot;a&quot;,b())21&gt;&gt;&gt; a_dict.get(&quot;a&quot;,b())21 虽然a_dict字典已经存在”a”:1,但，依旧执行了b() 处理方法先进行get，若返回为None，则进行setdefault 12345groupid = groupid_templateid_dict.get(tmp_groupname)if groupid: passelse: groupid = groupid_templateid_dict.setdefault(tmp_groupname,zhg.get_customer_hostgroups(name=groupname,output_data=output_data)) 这样就避免了重复调用func的问题。 结论其实只要把函数作为另外一个函数的参数，那么当调用这个函数的的时候，被传入的函数也会调用。]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python防注入]]></title>
    <url>%2F2019%2F01%2F30%2FPython%E9%98%B2%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[注入案例：12345678910111213141516import MySQLdbdb = MySQLdb.connect(host=&quot;localhost&quot;,user=&quot;&quot;,passwd=&quot;&quot;,db=&quot;&quot;)cur = db.cursor()platform = input(&apos;Enter language: &apos;)cur.execute(&quot;SELECT * FROM platforms WHERE language = &apos;%s&apos;;&quot; % platform)for row in cur.fetchall():print(row)db.close() 上述代码，让用户输入想查询的language，如果用户按套路，比如输入Ruby，则可以正常查询。 执行代码为：1SELECT * FROM platforms WHERE language = &apos;Ruby&apos;; 但如果搞事情输入Ruby’; DROP TABLE platforms;那么platforms表被删除。执行代码为：1SELECT * FROM platforms WHERE language = &apos;Ruby&apos;; DROP TABLE platforms;&apos;; 防止sql注入代码改写为如下:12345678910111213141516import MySQLdbdb = MySQLdb.connect(host=&quot;localhost&quot;,user=&quot;&quot;,passwd=&quot;&quot;,db=&quot;&quot;)cur = db.cursor()platform = raw_input(&apos;Enter language: &apos;)cur.execute(&quot;SELECT * FROM platforms WHERE language = %s;&quot;, (platform,))for row in cur.fetchall():print (row)db.close() 这边%s是占位符，和字符串format的方式不同，而且后面的元组前面也不需要%符号，即便是数字，也是用%s来占位。 防sql原因之所以能防sql是因为execute函数会对传入的args内容预处理。12345678910111213def mogrify(self, query, args=None): &quot;&quot;&quot; Returns the exact string that is sent to the database by calling the execute() method. This method follows the extension to the DB API 2.0 followed by Psycopg. &quot;&quot;&quot; conn = self._get_db() if PY2: # Use bytes on Python 2 always query = self._ensure_bytes(query, encoding=conn.encoding) if args is not None: query = query % self._escape_args(args, conn) execute后续调用一些函数，比如下面escape_string函数。(能力有限，前面几级调用不是非常看得懂。) 12345def escape_string(self, s): if (self.server_status &amp; SERVER_STATUS.SERVER_STATUS_NO_BACKSLASH_ESCAPES): return s.replace(&quot;&apos;&quot;, &quot;&apos;&apos;&quot;) return converters.escape_string(s) refer https://blog.sqreen.io/preventing-sql-injections-in-python/]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 只出现一次的数字]]></title>
    <url>%2F2019%2F01%2F28%2FLeetCode-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[需求给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例112输入: [2,2,1]输出: 1 示例212输入: [4,1,2,1,2]输出: 4 解题思路 使用异或的方式，非常巧妙，异或算法为相同为0，不同为1。 数字A异或数字B两次，则结果为A。 利用这个方法，可以找到非空数组里面只出现一次的那个元素。 0和数字B进行异或，得到的结果为数字B，基于这点，到最后所有元素异或剩下的结果就是只出现一次的那个元素。 解题代码1234567891011class Solution: def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; a = 0 for num in nums: a = a ^ num print(a) return a]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 最后一个单词长度]]></title>
    <url>%2F2019%2F01%2F24%2FLeetCode-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[需求给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明一个单词是指由字母组成，但不包含任何空格的字符串。 示例12输入: &quot;Hello World&quot;输出: 5 解题思路 两种情况，一种是为空，第二种是非空字符串。 字符串为空，则直接返回0，非空字符串，则返回最后一个单词。 python用split()方法，默认以空格，制表符等分割字符串，成为一个list。 解题代码123456789101112class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; slist = s.split() print(slist) if slist == []: return 0 return len(slist[-1]) refer: https://leetcode-cn.com/problems/length-of-last-word/submissions/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 实现strStr()]]></title>
    <url>%2F2019%2F01%2F23%2FLeetCode-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[需求实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路python非常简单，直接使用find命令就可以查询到指定字符串第一次出现的position。 解题代码12345678class Solution(object): def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; return haystack.find(needle) refer https://leetcode-cn.com/problems/implement-strstr/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘无法挂载]]></title>
    <url>%2F2019%2F01%2F18%2F%E7%A3%81%E7%9B%98%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[案例今天一机器的磁盘掉了，机房更换了硬盘。看了下前人都是写在/etc/fstab里面，个人不推荐写这里，写入/etc/rc.local更加好 然后修改了/etc/fstab，然后mount -a挂载，没报错，df -h没看到挂上去的盘，很奇怪。 查看了下message日志：12345Jan 18 14:55:55 SH-HDP1136 systemd: Unmounted /mnt/disk4.Jan 18 14:55:55 SH-HDP1136 systemd: Unit mnt-disk4.mount entered failed state.Jan 18 14:56:41 SH-HDP1136 kernel: XFS (sdd): Mounting V5 FilesystemJan 18 14:56:41 SH-HDP1136 kernel: XFS (sdd): Ending clean mountJan 18 14:56:41 SH-HDP1136 systemd: Unit mnt-disk4.mount is bound to inactive unit dev-disk-by\x2duuid-5aad6483\x2de21f\x2d498d\x2d9c8c\x2dfeff9fd5be76.device. Stopping, too. 最后一行谷歌查了下文档，第一篇文档说是用了重启大法。因为服务器比较重要，没考虑重启。 然后找到第二篇文档，说执行systemctl-reload，然后进行挂载。 尝试了下，的确成功了。 诡异的systemctl-reload但心里很纳闷，我修改个/etc/fstab和systemctl-reload有半毛钱关系，继续查了下谷歌，发现这是一个redhat7.4的bug。。。。。 Bug ID: 1566088 https://bugzilla.redhat.com/show_bug.cgi?id=1566088 refer: http://mamchenkov.net/wordpress/2017/11/09/systemd-strikes-again-unit-var-whatever-mount-is-bound-to-inactive-unit/https://bugzilla.redhat.com/show_bug.cgi?id=1566088]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[is和==比较区别]]></title>
    <url>%2F2019%2F01%2F17%2Fis%E5%92%8C%3D%3D%E6%AF%94%E8%BE%83%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[is** is比较的对象为内存地址 12345678&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; id(a)140379285741320&gt;&gt;&gt; id(b)140379285738696&gt;&gt;&gt; a is bFalse ==** ==比较的对象是值 12345678&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; id(a)140379285741320&gt;&gt;&gt; id(b)140379285738696&gt;&gt;&gt; a == bTrue 关于int类型的缓存123456789101112131415161718&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(a)9322464&gt;&gt;&gt; id(b)9322464&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a = 999&gt;&gt;&gt; b = 999&gt;&gt;&gt; id(a)140379285517520&gt;&gt;&gt; id(b)140379285517584&gt;&gt;&gt; a is bFalse 上述当ab都等于1的时候，两者指向的内存地址一致，但当ab赋值了999后，两者指向的内存地址不一致。 产生的原因python对于int类型进行缓存，当int属于[-5, 256]范围的时候，会被缓存，倘若在这个区间进行赋值，则指向的内存地址都是一致的。 这个产生的原因比较复杂，倘若a和b都赋值在同一行，则两者is比较也是True，具体可以看refer。 https://stackoverflow.com/questions/15171695/whats-with-the-integer-cache-inside-python]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是地址引用还是赋值操作]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%98%AF%E5%9C%B0%E5%9D%80%E5%BC%95%E7%94%A8%E8%BF%98%E6%98%AF%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本类型凡是基本类型，都是赋值。 12345a = 1b = Nonec = True 复合类型若是复合类型，都是地址指向。 函数和类的赋值也是地址指向 12345a = [1,2,3]b = &#123;&apos;a&apos;:1, &apos;b&apos;:1&#125;c = 函数，类 验证方法直接用id()看地址引用，如果原始对象改变后，其id()和赋值对象的id()不再一致，则为赋值，反之则是引用。 验证基本类型：1234567891011&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)9413248&gt;&gt;&gt; id(b)9413248&gt;&gt;&gt; a = 4&gt;&gt;&gt; id(a)9413280&gt;&gt;&gt; id(b)9413248 给a第二次更变赋值为4后，b的id()和a的id()不同，所以是赋值 验证复合类型：12345678910111213&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; id(a)140435242878376&gt;&gt;&gt; id(b)140435242878376&gt;&gt;&gt; a.append(1)&gt;&gt;&gt; id(a)140435242878376&gt;&gt;&gt; id(b)140435242878376 给a第二次更变赋值为4后，b的id()和a的id()相同，所以是地址引用。下面的类的例子也能看出是地址引用。 1234567891011121314151617class A(object): def test(self): passa = A()b = aprint(id(a))print(id(b))a.value = 1print(id(a))print(b.value)1402331338442401402331338442401402331338442401]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带宽测试]]></title>
    <url>%2F2019%2F01%2F15%2F%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[场景当时是想测试单台服务器，流量到某带宽值，cpu，内存，磁盘io的表现。现在单说iperf和nc的简单使用。 iperf简单使用 server端启用iperf -s client端连接server端，默认端口是5001,iperf -c ${server_ip} ${port} server端：12345678[root@SCA-LX5700025 ~]# iperf -s------------------------------------------------------------Server listening on TCP port 5001TCP window size: 85.3 KByte (default)------------------------------------------------------------[ 4] local 10.8.199.17 port 5001 connected with 10.8.199.18 port 38008[ ID] Interval Transfer Bandwidth[ 4] 0.0-10.0 sec 1.13 GBytes 971 Mbits/sec client端：12345678[root@SCA-LX5700026 ~]# iperf -c 10.8.199.17 -p 5001------------------------------------------------------------Client connecting to 10.8.199.17, TCP port 5001TCP window size: 85.0 KByte (default)------------------------------------------------------------[ 3] local 10.8.199.18 port 38008 connected with 10.8.199.17 port 5001[ ID] Interval Transfer Bandwidth[ 3] 0.0-10.0 sec 1.13 GBytes 973 Mbits/sec 出来的结果直接是带宽，比如上面的是趋近于1000M带宽。 参数没有研究太多参数，更多参数可以-h查看。 -b 指定带宽12345678[root@SCA-LX5700026 ~]# iperf -c 10.8.199.17 -p 5001 -b 500M------------------------------------------------------------Client connecting to 10.8.199.17, TCP port 5001TCP window size: 85.0 KByte (default)------------------------------------------------------------[ 3] local 10.8.199.18 port 38010 connected with 10.8.199.17 port 5001[ ID] Interval Transfer Bandwidth[ 3] 0.0-10.0 sec 625 MBytes 524 Mbits/sec nc简单使用 server端启用nc -vvlnp ${server_port} &gt;/dev/null，或者-4指定只使用ipv4的方式。 client端连接dd if=/dev/zero bs=1M count=1K | nc ${server_ip} ${server_port}，命令测试的是1G文件的下载速度。 server端：123456[root@SCA-LX5700025 ~]# nc -vv4lnp 5001 &gt;/dev/nullNcat: Version 7.50 ( https://nmap.org/ncat )Ncat: Listening on 0.0.0.0:5001Ncat: Connection from 10.8.199.18.Ncat: Connection from 10.8.199.18:38410.NCAT DEBUG: Closing fd 4. client端：1234[root@SCA-LX5700026 ~]# dd if=/dev/zero bs=1M count=1K | nc 10.8.199.17 50011024+0 records in1024+0 records out1073741824 bytes (1.1 GB) copied, 8.7875 s, 122 MB/s refer: https://askubuntu.com/questions/7976/how-do-you-test-the-network-speed-between-two-boxes]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql字符集字符序]]></title>
    <url>%2F2019%2F01%2F10%2Fmysql%E5%AD%97%E7%AC%A6%E9%9B%86%E5%AD%97%E7%AC%A6%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Emmmm….数据库默认配置，建库没指定字符集，然后你懂得，所有库，表，部分字段字符集都是latin1。 MariaDB version 10.1.36 数据库分字符集(character)和字符序(collation) character定义了字符以及字符的编码。 collation定义了字符的比较规则。 有四个地方涉及到字符集和字符序 服务器端(server level) 数据库(database level) 表(table level) char varchar text类型的字段(column level) 如果都未进行指定，采用何种character和collation，则默认情况为character=latin1, collation=latin1_swedish_ci 字符集 查看当前支持的字符集SHOW charsets，Default collation字段告知了，该字符集所用的默认字符序。 123456789101112mysql&gt; SHOW charset;+----------+-----------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+-----------------------------+---------------------+--------+| big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 |...... 查看server level当前的字符集SHOW VARIABLES LIKE &quot;character_set_server&quot;，查看server level当前的字符序SHOW VARIABLES LIKE &quot;collation_server&quot; 修改server level字符集的方法: 修改配置文件 编译的时候 set 全局变量命令。但这种情况重启会失效。 如果创建库，或者表，或者字段，或者配置文件my,cnf中只指定了字符集，则默认的字符序为该字符集所对应的默认字符序。 字符序 查看当前支持的字符序SHOW collation, Default字段存在Yes的，表示该字符集默认的default值。比如latin1默认的字符序为latin1_swedish_ci 1234567891011121314151617mysql&gt; SHOW collation;+--------------------------+----------+-----+---------+----------+---------+| Collation | Charset | Id | Default | Compiled | Sortlen |+--------------------------+----------+-----+---------+----------+---------+| big5_chinese_ci | big5 | 1 | Yes | Yes | 1 || big5_bin | big5 | 84 | | Yes | 1 || dec8_swedish_ci | dec8 | 3 | Yes | Yes | 1 || dec8_bin | dec8 | 69 | | Yes | 1 || cp850_general_ci | cp850 | 4 | Yes | Yes | 1 || cp850_bin | cp850 | 80 | | Yes | 1 || hp8_english_ci | hp8 | 6 | Yes | Yes | 1 || hp8_bin | hp8 | 72 | | Yes | 1 || koi8r_general_ci | koi8r | 7 | Yes | Yes | 1 || koi8r_bin | koi8r | 74 | | Yes | 1 || latin1_german1_ci | latin1 | 5 | | Yes | 1 || latin1_swedish_ci | latin1 | 8 | Yes | Yes | 1 || latin1_danish_ci | latin1 | 15 | | Yes | 1 | 如果创建库，或者表，或者字段，或者配置文件my,cnf中只指定了字符序，则默认的字符集为该字符序所对应的字符集。 字符序表示的含义 一般来说分为三段，也存在一段或者两段的情况，常见的三段如utf8mb4_general_ci,两段的如utf8mb4_bin(这类情况，其实只存在第一段和第三段，第二段不存在) 第一段代表字符集。 第二段代表语言(chinese,swedish),也有general这种通用的，或者unicode类型。 第三段代表是否敏感，是否为bin。 对于第三段的解释12345_ai Accent insensitive_as Accent sensitive_ci Case insensitive_cs case-sensitive_bin Binary Accent是否为sensitive表现为，如果为sensitive，则比较a和á是不同的，如果为insensitive则a和á比较为相同。 Case insensitive为大小写不敏感，case-sensitive为大小写敏感。 字符集和字符序的继承顺序 数据库服务，建库，建表，建字段，倘若其中有指定character和collation，则字段继承表，表继承库，库继承数据库服务。比如建库指定了字符集为utf8，那么该库下面的表如果不指定字符集，则表的字符集也为utf8，char、varchar、text的字段字符集也是utf8。 有个例外，如果修改了表， 那么该表下面的字段的字符集和字符序也会变成表的字符集和字符序。 修改查看字符集命令： 修改运行环境： 1234SET character_set_server = utf8mb4set character_set_connection = utf8mb4set character_set_database = utf8mb4set character_set_results = utf8mb4 修改库: 1234ALTER DATABASE dbname CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;验证语句 show create database dbname; 修改表: 12345671. dir varchar(255) -&gt; varchar(191) mysql5.6的版本需要修改。不保证所有版本都需要修改。ALTER TABLE dir_stats MODIFY dir VARCHAR(191);2. 修改字段类型utf8mb4alter table tablename convert to character set utf8mb4 collate utf8mb4_unicode_ci;验证语句SHOW FULL COLUMNS FROM dbname.tablename; refer: https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.htmlhttps://mariadb.com/kb/zh-cn/setting-character-sets-and-collationshttps://dev.mysql.com/doc/refman/8.0/en/charset-database.htmlhttp://zarez.net/?p=719]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promotions in Program C]]></title>
    <url>%2F2019%2F01%2F08%2FPromotions-in-Program-C%2F</url>
    <content type="text"><![CDATA[scanf()函数不会自行提升成double类型，printf()函数会自行提升成double类型。12345678910111213#include &lt;stdio.h&gt;void main(void) &#123; double num; printf(&quot;input a double type number: &quot;); scanf(&quot;%f&quot;, &amp;num); printf(&quot;the number is %f\n&quot;, num); printf(&quot;the number is %lf\n&quot;, num);&#125;input a double type number: 1the number is 0.000000the number is 0.000000 scanf()函数因为指向的是num的指针,所以不适用float promotions to double scanf()若使用double类型，必须写成”%lf”, 而printf()即便指定的是”%f”,也会自行提升成double类型。 1234567891011121314#include &lt;stdio.h&gt;void main(void) &#123; double num; printf(&quot;input a double type number: &quot;); scanf(&quot;%lf&quot;, &amp;num); printf(&quot;the number is %f\n&quot;, num); printf(&quot;the number is %lf\n&quot;, num);&#125;input a double type number: 1the number is 1.000000the number is 1.000000 integer-promotionsrefer: https://stackoverflow.com/questions/19952200/scanf-printf-double-variable-chttp://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf [6.5.2.2 page-71]https://www.geeksforgeeks.org/integer-promotions-in-c/]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言基本数字类型]]></title>
    <url>%2F2019%2F01%2F06%2Fc%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数字类型关键字 int long short unsigned char float double signed _Bool (c99加入的bool类型) _Complex (c99加入的复数类型) _Imaginary (c99加入的虚数类型) 有符号整形有符号类型可用于表示正整数和负整数。 int 系统给定的基本整数类型，c语言规定int类型不小于16位。 short或short int 最大的shrot类型整数小于或等于最大的int类型整数。c语言规定short类型至少占16位。 long或long int 该类型可表示的整数大于或等于最大的int类型整数。c语言规定long类型至少占位32位。 long long或long long int 该类型可以表示的整数大于或等于最大的long类型整数。long long 类型至少占64位。 一般而言，long类型的占用内存比short类型大，int类型的宽度要和和long类型相同，要么和short类型相同。 无符号整形无符号整形只能用于表示零和正整数，因此无符号整形可以表示的正整数比有符号整形的大。在整形类型前面加上关键字unsigned表明该类型是无符号整形。单独的unsigned相当于unsigned int。 字符类型char类型实际上存储的是整数，而非字符。ASCII编码范围是0~127，所以只需要7位二进制数表示即可(这里不包含中文日文等特殊字符集)。char类型表示一个字符要占用1个字节内存，出于历史原因，一个字节通常是8位，但是如果要表示基本字符集，也可以是16位或更大。 char 字符类型的关键字，有些编译器使用有符号的char，而有些则使用无符号的char。在需要时，可以在char前面加上关键字signed或unsigned来指明，具体使用哪一种类型。 布尔类型布尔值表示true和false。c语言用1表示true，0表示false _Bool 布尔类型的关键字，c99加入。其类型为无符号int类型，所占用的个空间只要能存储0或者1即可。 实浮点类型(实数浮点类型)实浮点类型可以表示正浮点数和负浮点数。 float 系统基本浮点类型，可精确表示至少6位有效数字。 double 存储浮点数的范围更大，能表示比float类型更多的有效数字(至少15位)和更大的指数。 long long 存储浮点束的范围比double更大，能表示比double更多的有效数字和更大的指数。 复数和虚数浮点数虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成。 float _Complex double _Complex long double _Complex float _Imaginary double _Imaginary long double _Imaginary]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未配置中间证书CA引起的安卓端无法通过https建联加载图片案例]]></title>
    <url>%2F2019%2F01%2F06%2F%E6%9C%AA%E9%85%8D%E7%BD%AE%E4%B8%AD%E9%97%B4%E8%AF%81%E4%B9%A6CA%E5%BC%95%E8%B5%B7%E7%9A%84%E5%AE%89%E5%8D%93%E7%AB%AF%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87https%E5%BB%BA%E8%81%94%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[问题描述安卓同事称代码调试访问test-material.aaa.tv/xxx/xxxx.png等图片资源的时候报错，报错信息类似如下： 1javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found. 问题分析查看了安卓的开放文档，出现该报错主要由一下三种情况发生： 颁发服务器证书的 CA 未知。 服务器证书不是由 CA 签署的，而是自签署。 服务器配置缺少中间 CA。 首先排除第一点和第二点，证书是购买的赛门铁克。 然后去ssllabs网站测试test-material.aaa.tv域名支持的https建联加密方式 起先怀疑是安卓可能使用了SSL3的加密方式进行https简练握手，后来确认安卓使用版本之后排除了该情况。 接着使用浏览器访问资源查看发现存在中间CA证书，但用域名检测网站的时候提示不含中间CA证书。于是乎又抓了一个安卓端可以显示的图片的域名来测试，在测试网站上也是属于不包含中间CA证书的情况。 两者的区别是，无法建联的域名是阿里云上的，能建联显示图片的域名是腾讯云上的。 当时很纳闷，后来查阅资料得知不同软件或者设备会有不同的行为，有些即便不存在中间CA也会帮忙代理查找。 安卓(其他苹果设备应该也是如此)自身会信任一些根证书，可能安卓去“解析”test-material.aaa.tv这个域名的时候得到的根证书，并不在信任证书里面，从而导致https建联失败。 于是发现安卓的确是存在信任一些列证书的情况： 然后来获取下test-material.aaa.tv的根证书情况，自然，在浏览器端获取到的可能是浏览器帮助代理请求获得的。得在服务器端用命令去查看，命令如下： 1openssl s_client -connect test-material.aaa.tv:443 -servername test-material.aaa.tv -connect 检测的域名，后面跟随ssl端口号-servername 指定SNI(Server Name Indication)，因为可能存在多个域名对应一张证书的情况，比如买的证书是一级域名和二级域名都可以使用这种情况，那么需要指定具体的域名。 SNI (Server Name Indication)是用来改善服务器与客户端 SSL (Secure Socket Layer)和 TLS (Transport Layer Security) 的一个扩展。主要解决一台服务器只能使用一个证书(一个域名)的缺点，随着服务器对虚拟主机的支持，一个服务器上可以为多个域名提供服务，因此SNI必须得到支持才能满足需求。 上图已经修复问题，修复之前只有条目0，不包含条目1。 红框信息： 起始证书是C=CN/L=xxxxx(后面一大串)，然后C=CN/L=xxxxx(后面一大串)这个证书又是由GeoTrust Inc./CN=GeoTrust SSL CA - G3颁发。 修复问题之前只有条目0,没有条目1，然后在安卓信任证书列表里面查不到关于信任GeoTrust Inc./CN=GeoTrust SSL CA - G3这个证书的条目。所以建联无法通过了。 GeoTrust SSL CA - G3又是由Geo Trust Inc./CN=Geo Trust Global CA颁发。 修复问题之后可以在安卓端信任列表里面查到存在Geo Trust Global CA证书条目，所以建联成功了。 问题解决方法：中间证书CA没配置导致，上阿里云后台，查看该域名对应的证书，发现的确只有本机CA证书，没有配置中间证书CA，重新配置上后，问题解决，安卓端建联正常。 refer: https://developer.android.google.cn/training/articles/security-ssl.html#MissingCahttp://blog.csdn.net/makenothing/article/details/53292335 证书检测地址: https://www.ssllabs.com/ssltest/analyze.html 安卓文档对于缺失中间证书的描述:12345678有趣的是，在大多数桌面浏览器中访问此服务器不会引发完全未知的 CA 或自签署服务器证书所引发的类似错误。这是因为大多数桌面浏览器都会将可信的中间 CA 缓存一段时间。当浏览器从某个网站访问和了解中间 CA 后，下次它就不需要将中间 CA 添加在证书链中。有些网站会专门为提供资源的辅助网络服务器这样做。例如，他们可能让具有完整证书链的服务器提供主 HTML 页面，让不包含 CA 的服务器提供图像、CSS 或 JavaScript 等资源，以节省带宽。遗憾的是，这些服务器有时候可能会提供您正在尝试从 Android 应用调用的网络服务，这一点让人难以接受。可以通过两种方法解决此问题：配置服务器以便在服务器链中添加中间 CA。大多数 CA 都可以提供有关如何为所有常用网络服务器执行此操作的文档。如果您需要网站至少通过 Android 4.2 使用默认 Android 浏览器，那么这是唯一的方法。或者，像对待其他任何未知 CA 一样对待中间 CA，并创建一个 TrustManager 以直接信任它，如前面的两部分中所述。 查看证书到期时间：openssl s_client -connect www.icoinbay.com:443 -servername www.icoinbay.com 2&gt;/dev/null |openssl x509 -noout -dates]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash fork: retry: Resource temporarily unavailable]]></title>
    <url>%2F2019%2F01%2F02%2Fbash-fork-retry-Resource-temporarily-unavailable%2F</url>
    <content type="text"><![CDATA[修改ulimit无法解决fork不出子进程的问题现场没有保留，大抵经过如下：朋友的一台系统为Ubuntu的机器，上面启动了一个进程，该进程会fork出子进程，但是当root用户所有的进程数到一万多后就无法继续fork了，输入命令开始报错bash fork: retry: Resource temporarily unavailable 排查经过： 起先我以为是ulimit的配置没修改，或者不够大，但使用ulimit -u看了下，65535，足够大了。 感觉虽然ulimit调整了，但是执行中的进程limit并没有到达65535，于是乎，去/proc/pid/limit查看了，发现max process也是65535。 那么不成是内存，cpu之类的(其实想想也不太可能，内存小也不会报fork错误)，看了发现完全够用。 这下懵圈了 bash fork: retry: Resource temporarily unavailable 这个报错绝逼是某个参数的配置配小了。 由于是Ubuntu的系统，所以和平常用的centos还是有区别的。选择谷歌了，查来查去，一堆人都说是修改ulimit参数。 最后是找到了这篇文章： https://askubuntu.com/questions/845380/bash-fork-retry-resource-temporarily-unavailable 里面让修改的地方是一个名为pid.max的文件，和我机器路径稍微有点出入，我的路径是在/sys/fs/cgroup/pids/user.slice/user-0.slice/pid.max 这个数值只有10813，所以ps -eLf | wc -l到一万七八就上不去了。 这个文件的数量改动后立马生效，不需要重启 重启机器后，这个值又会还原成10813，看来Ubuntu系统默认pid.max的值为10813(当时我没注意Ubuntu具体是哪个版本。。。。)，这个值如何产生的目前还不太清楚。 centos7在centos7上 获取当前进程数：cat /sys/fs/cgroup/pids/pids.current 类似使用ps -ef | wc -l 获取当前线程数和进程数总和：wc -l /sys/fs/cgroup/pids/tasks 类似使用ps -eLf | wc -l centos7上也是可以实现pid.max：只需要在/sys/fs/cgroup/pids/下创建以为目录，则该目录中就会自动创建pid.max：1234[root@leanote test]# pwd/sys/fs/cgroup/pids/test[root@leanote test]# lscgroup.clone_children cgroup.event_control cgroup.procs notify_on_release pids.current pids.max tasks 对当前shell交互进程限制 1234567891011[root@leanote test]# lscgroup.clone_children cgroup.event_control cgroup.procs notify_on_release pids.current pids.max tasks[root@leanote test]# cat cgroup.procs [root@leanote test]# echo $$14514[root@leanote test]# echo 14514 &gt; cgroup.procs [root@leanote test]# echo 1 &gt; pids.max -bash: fork: retry: No child processes-bash: fork: Resource temporarily unavailable-bash: fork: retry: No child processes-bash: fork: retry: No child processes 给pid.max输入1后，直接就出-bash: fork: retry: No child processes报错了。 pid.max只会对cgroup.procs中存在的进程进行pid.max限制。 当进程消失后,cgroup.procs中的进程号也会自动消失。 在上一级不存在pid.max是因为对整个系统没必要做限制。Ubuntu系统上/sys/fs/cgroup/pids/user.slice/user-0.slice/pid.max这个其实是对用户编号为0的用户进行了pid.max的限制。 refer: 知乎上看到有个小伙伴也遇到这个问题了 https://zhuanlan.zhihu.com/p/29192624 fork的文档 http://man7.org/linux/man-pages/man2/fork.2.html cgroup介绍 https://segmentfault.com/a/1190000007241437https://mccxj.github.io/blog/20171230_os-thread-limit.html cgroup 进程数限制 https://segmentfault.com/a/1190000007468509]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort函数中key的理解]]></title>
    <url>%2F2018%2F12%2F29%2Fsort%E5%87%BD%E6%95%B0%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[sort()函数12345Help on method_descriptor:sort(...) L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*(END) python3中已经取消了sort()函数中cmp参数 python中sort()函数用来排序，其中有个key的参数，十分神奇。 我对key参数的理解是：这个key是构造了一个全新的对象，对这些全新的对象进行比较排序，然后再根据结果，对原先的对象进行排序。 字典value排序:比如很常用的，对一个字典进行value排序：123456d = &#123;1: &apos;c&apos;, 2:&apos;d&apos;, 3: &apos;b&apos;, 4: &apos;a&apos;&#125;def sort_value(x): return x[1]print(sorted(d.items(), key=sort_value)) d.items得到dict_items([(1, ‘c’), (2, ‘d’), (3, ‘b’), (4, ‘a’)])，其挨个传入到key对应的sort_value函数中，返回索引为1的值，也就是value的值，然后对这个新对象进行排序，最终以新对象排序的结果来输出d.items()的排序。 将sort_value函数写成lambda则：1print(sorted(d.items(), key=lambda x :x[1])) 字符串内容重新排序:对字符串”hUangYisan6749”重新排序，要求: 数字在最前面，偶数在奇数前面。 字符串在数字后面，大写字母在小写字母后面。 思路： 字符串挨个拆出来。 构造一个元组，能够符合上述需求，然后排序的。元组的排序是从首个元素逐一排序的，碰到首元素一样，则比第二个元素 先确定一个通用的元组，总共是四种类型，奇数偶数，大写小写。例：偶数，奇数，大写，小写(1,0,0,0)，比如这样就表示该字符为偶数。 由于默认sorted排序是从小到大，所以根据需求，得写成小写，大写，奇数，偶数的方式(或者加上reverse=True) 123456789def custom_order(x): if x.islower(): return 1,0,0,0,x if x.isupper(): return 0,1,0,0,x if x.isdigit() and int(x) % 2 == 0: return 0,0,1,0,x else: return 0,0,0,1,x 当对比相同的时候，会索引+1比较，所以return不能漏掉x，因为当前面四位全部相等的时候，要比较x。 那么代码可以写成：1234567891011121314mystring = &quot;hUangYisan6749&quot;def custom_order(x): if x.islower(): return 1,0,0,0,x if x.isupper(): return 0,1,0,0,x if x.isdigit() and int(x) % 2 == 0: return 0,0,1,0,x else: return 0,0,0,1,xprint(&quot;&quot;.join(sorted(mystring,key=custom_order)))7946UYaaghinns refer: http://python.jobbole.com/85025/]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[split函数]]></title>
    <url>%2F2018%2F12%2F29%2Fsplit%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一道领扣的题给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: &quot;Hello World&quot;输出: 5 写出的其中一种答案是：123456789101112class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; slist = s.split() print(slist) if slist == []: return 0 return len(slist[-1]) split(“ “) 和 split()起先我认为split(“ “)和split()的作用是一样的，都是以空格进行分割。以至于一开始做上面领扣的题一直都有问题。 然后手工验证了下两者的情况： split(“ “)的情况 12&gt;&gt;&gt; &quot; a &quot;.split(&quot; &quot;)[&apos;&apos;, &apos;a&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;] split()的情况 12&gt;&gt;&gt; &quot; a &quot;.split()[&apos;a&apos;] 查了下split()的用法 123S.split([sep [,maxsplit]]) -&gt; list of stringsReturn a list of the words in the string S, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done. If sep is not specified or is None, any whitespace string is a separator and empty strings are removed from the result. 也就是说，如果sep不填写，那么split()执行两个行为： 以任何whitespace字符串作为分隔符。 除所有的empty string。 empty string就是not xxx返回结果为False的字符串,包括””。 refer: https://leetcode-cn.com/problems/length-of-last-word/help(str.split)]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7网卡改名]]></title>
    <url>%2F2018%2F12%2F27%2Fcentos7%E7%BD%91%E5%8D%A1%E6%94%B9%E5%90%8D%2F</url>
    <content type="text"><![CDATA[客户瞎搞，两张网卡，说是看着名称不爽，自行修改了网卡名，为bond0和bond1，bond1能启动，而bond0无法启动。我这边接手擦屁股。 先说udev服务，然后再看问题产生的原因。 system-udevd进程在centos6中为udevd进程：12[root@VM_31_91_centos6 ~]# ps -ef | grep udevroot 470 1 0 01:17 ? 00:00:00 /sbin/udevd -d 在centos7中为system-udevd进程12[root@VM_31_91_centos7 ~]# ps -ef | grep udevroot 460 1 0 10月09 ? 00:00:00 /usr/lib/systemd/systemd-udevd udev的作用是：man udevreceives device uevents directly from the kernel whenever a device is added or removed from the system, or it changes its state.当有设备从系统插入或者拔出，或者改变了状态的时候，内核会直接收到设备uevents。 udev rules文件存在位置： system rules directory: /usr/lib/udev/rules.d volatile runtime directory: /run/udev/rules.d local administration directory: /etc/udev/rules.d udev读取文件规则： 读取这些目录下以.rules为后缀的文件。 文件先后顺序和其所在目录无关，和文件的名称顺序有关。 若不同目录存在相同的文件，则根据目录名称来排优先级顺序。/etc&gt;/run&gt;/usr udev进行网卡重命名 https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsg 优先查询的是/usr/lib/udev/rules.d/60-net.rules配置文件。如果发现包含 HWADDR 条目的 ifcfg 文件与某个接口的 MAC 地址匹配，它会将该接口重命名为 ifcfg 文件中由 DEVICE 指令给出的名称。 问题产生的原因当时发现/usr/lib/udev/rules.d/60-net.rules文件内已经存在了bond1的配置，而bond0的配置写到了/etc/udev/rules.d/70-persistent-net.rules里面，由于60的优先级高于70，所以bond0网卡一直起不来。 其实centos7已经不用70-persistent-net.rules这个文件了，在centos6中，删除了70-persistent-net.rules文件，他会通过/lib/udev/write_net_rules文件来生成，但centos7已经不存在该文件了，centos7是使用/lib/udev/rename_device文件来生成/usr/lib/udev/rules.d/60-net.rules。 合理修改centos7网卡名称流程首先修改当前网卡名称 123/sbin/ip link set eth1 down/sbin/ip link set eth1 name eth123/sbin/ip link set eth123 up 然后在/usr/lib/udev/rules.d/60-net.rules中加入配置策略ACTION==”add”, SUBSYSTEM==”net”, DRIVERS==”?*”, ATTR{address}==”00:50:56:8e:3f:a7”, NAME=”eth123” refer: https://www.freedesktop.org/software/systemd/man/udev.html#https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure?tdsourcetag=s_pctim_aiomsghttps://unix.stackexchange.com/questions/205010/centos-7-rename-network-interface-without-rebooting]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从无法加载JAVA_HOME说起]]></title>
    <url>%2F2018%2F12%2F25%2F%E4%BB%8E%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDJAVA-HOME%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[这几天在做jenkins cicd的事儿，用sudo的方式启动tomcat，直接报出无法找到JAVA_HOME。当时挺纳闷的，因为我在/etc/profile里面是添加了JAVA_HOME。123456789[root@ccc bin]# sudo ./catalina.sh startNeither the JAVA_HOME nor the JRE_HOME environment variable is definedAt least one of these environment variable is needed to run this program[root@ccc bin]# tail -n 5 /etc/profileexport JAVA_HOME=/tool/jdk1.8.0_144export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH 如此如此，出现了两个疑问。 为什么/etc/profile的内容无法被加载？ 在/etc/profile里面写入jdk环境变量是否合适？ 为什么/etc/profile的内容无法被加载？先说下一个概念，linux的用户交互模式。在linux中用户交互模式可以分为两类： Interactive Shell Non-Interactive Shell Interactive Shell 顾名思义，就是登陆用户可以和shell进行交互的，比如你用xshell上一台服务器，出现的terminal就是属于Interactive Shell方式。Non-Interactive Shell 非交互的模式，比如用crontab的方式执行一个shell脚本。 那么问题就来了，这两种模式的环境变量从哪里去获取呢？ Interactive Shell登录情况 123456789101112execute /etc/profileIF ~/.bash_profile exists THEN execute ~/.bash_profileELSE IF ~/.bash_login exist THEN execute ~/.bash_login ELSE IF ~/.profile exist THEN execute ~/.profile END IF END IFEND IF 一目了然，入口为/etc/profile文件。其中在.bash_profile里面还判断是否存在~/.bashrc，如果存在则加载~/.bashrc。 12if [ -f ~/.bashrc ]; then . ~/.bashrc 还没完，在执行~/.bashrc的时候里面继续判断是否存在/etc/bashrc，如果存在则执行/etc/bashrc。 123if [ -f /etc/bashrc ]; then . /etc/bashrcfi 顺带一说，当用户退出Interactive Shell的时候，执行~/.bash_logout内容。所以可以在退出的时候定义一些行为。 123IF ~/.bash_logout exists THEN execute ~/.bash_logoutEND IF 总结下Interactive Shell的顺序： /etc/profile ~/.bash_profile ~/.bashrc /etc/bashrc ~/.bash_login ~/.profile ~/.bash_logout (当且仅当退出Interactive Shell的时候执行) Non-Interactive Shell的情况 123IF ~/.bashrc exists THEN execute ~/.bashrcEND IF 直接去执行的~/.bashrc，该文件也会判断是否存在/etc/bashrc，存在则执行/etc/bashrc。 总结下Non-Interactive Shell的顺序： ~/.bashrc /etc/bashrc 看似原因好像是因为sudo ./catalina.sh start进入了Non-Interactive Shell，从而没加载/etc/profile，其实并不是这样的。sudo在这边搞出了幺蛾子？ sudo做了啥？命令输入visudo，有那么一节内容： 1234567891011121314# Preserving HOME has security implications since many programs# use it when searching for configuration files. Note that HOME# is already set when the the env_reset option is enabled, so# this option is only effective for configurations where either# env_reset is disabled or HOME is present in the env_keep list.#Defaults always_set_homeDefaults env_resetDefaults env_keep = &quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS&quot;Defaults env_keep += &quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;Defaults env_keep += &quot;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;Defaults env_keep += &quot;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;Defaults env_keep += &quot;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot; 其行为会将env reset，但是会保留部分环境变量。这一行为导致了sudo ./catalina.sh start无法寻找到jdk变量。 比较差劲的解决方法：man一下sudo，有个-E的参数，能保留之前的环境变量，但是不推荐这样做，因为有安全隐患： 123-E The -E (preserve environment) option indicates to the security policy that the user wishes to preserve their existing environment variables. The security policy may return an error if the -E option is specified and the user does not have permission to preserve the environment. 1234567[root@ccc bin]# sudo -E ./catalina.sh startUsing CATALINA_BASE: /opt/mixcdn-tomcatUsing CATALINA_HOME: /opt/mixcdn-tomcatUsing CATALINA_TMPDIR: /opt/mixcdn-tomcat/tempUsing JRE_HOME: /tool/jdk1.8.0_144Using CLASSPATH: /opt/mixcdn-tomcat/bin/bootstrap.jar:/opt/mixcdn-tomcat/bin/tomcat-juli.jarTomcat started. 好的解决方法在下面： 在/etc/profile里面写入jdk环境变量是否合适？针对部署tomcat的jdk环境，很多文档，包括我自己，之前也是从别人那边拿来的部署jdk文档，将jdk环境变量写入/etc/profile，等文件中，这个观念基本上贯穿了我整个运维生涯。 其实官方给出了写法，在catalina.sh里面: 12345678910111213141516171819202122232425262728# Control Script for the CATALINA Server## Environment Variable Prerequisites## Do not set the variables in this script. Instead put them into a script# setenv.sh in CATALINA_BASE/bin to keep your customizations separate.## CATALINA_HOME May point at your Catalina &quot;build&quot; directory.## CATALINA_BASE (Optional) Base directory for resolving dynamic portions# of a Catalina installation. If not present, resolves to........# Ensure that any user defined CLASSPATH variables are not used on startup,# but allow them to be specified in setenv.sh, in rare case when it is needed.CLASSPATH=if [ -r &quot;$CATALINA_BASE/bin/setenv.sh&quot; ]; then . &quot;$CATALINA_BASE/bin/setenv.sh&quot;elif [ -r &quot;$CATALINA_HOME/bin/setenv.sh&quot; ]; then . &quot;$CATALINA_HOME/bin/setenv.sh&quot;fi........ 就是在tomcat/bin目录下面，写入一个setenv.sh文件里面写入需要的环境变量，当运行catalina.sh启动脚本的时候，其会进行执行该setenv.sh文件，当前我的版本是1.8，非特殊情况其已经不需要写入CLASSPATH。(据说jdk1.5之后就不需要写入CLASSPATH了。) 123[root@ccc bin]# cat setenv.shexport JAVA_HOME=/tool/jdk1.8.0_144export PATH=$PATH:$JAVA_HOME/bin 多看官方文档，多看服务自带脚本还是非常有必要的。 Refer: https://www.thegeekstuff.com/2008/10/execution-sequence-for-bash_profile-bashrc-bash_login-profile-and-bash_logout/https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/https://stackoverflow.com/questions/8633461/how-to-keep-environment-variables-when-using-sudohttps://segmentfault.com/q/1010000011528636/a-1020000011538128 下次写sudo su两个命令。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clean/rm/reset/revert/checkout用法和区别]]></title>
    <url>%2F2018%2F12%2F22%2Fgit-clean-rm-reset-revert-checkout%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git的工作区和暂存区先说下这两个概念：工作区，就是你git仓库的目录，你进行修改文件的区域。暂存区，git从库里面有个.git的隐藏目录，里面”有一块”，可以理解为暂存区。 工作区和缓存区如何联系起来？通过提交代码行为的步骤流程来解读: 修改代码文件 git add 修改后的代码文件 此刻的行为将该代码文件从工作区添加到了暂存区 git commit -m &#39;commit 内容&#39; 此刻的行为把暂存区的内容提交到了本地分支上 最后的git push操作只是一个将本地分支推送到远端的行为，所以先不考虑进去，只考前面三点。 查看工作区和暂存区常用的命令为git status 一般常见的是如下三种情况： 在工作区新建了文件或目录，但还未将这些文件或目录git add提交到暂存区。这些文件或目录被标记为untracked files。 123456789101112huangyisan:~/Desktop/github/test $ touch foo barhuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar foonothing added to commit but untracked files present (use &quot;git add&quot; to track) 对修改后的文件进行了git add操作，将这些文件提交到了暂存区，但未执行git commit -m &#39;xxx&#39;，未提交到本地分支。此时文件属于Changes to be committed状态 123456789101112huangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 对已经git add操作，但未提交到本地分支的文件，继续进行了修改，修改完后未进行git add，此时文件属于Changes not staged for commit状态 123456789101112131415161718huangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 已经commit到本地分支的文件，且该文件在工作区没被修改之前，其不会在git status中出现。 git checkout – file两种情况 若被checkout的文件在暂存区，但工作区修改了，也就是上面的第三种情况，此时执行该命令，被checkout的文件变成和暂存区一样的状态和内容。12345678910111213141516171819202122232425262728293031huangyisan:~/Desktop/github/test $ echo &apos;first line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foohuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 将foo文件写入’first line’内容后，用git add foo，提交到了暂存区，未commit情况下，再写入新内容’new line’,若想还原到暂存区状态，则使用命令git checkout -- foo 被修改文件不在暂存区，此时使用git checkout -- file命令，则该文件和当前版本仓库中原先的文件一致。123456789101112huangyisan:~/Desktop/github/test $ git statusOn branch masternothing to commit, working tree cleanhuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 干净的工作区，修改了foo文件，然后进行checkout操作之后，foo文件还原成了仓库中该文件原先的状态和内容。 git cleangit clean 的对象为untracked files，也就是在工作区新建，但还未执行git add命令提交到暂存区的文件或目录。1234567891011121314151617181920212223huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ touch new1 new2huangyisan:~/Desktop/github/test $ mkdir &#123;tmp1,tmp2&#125;huangyisan:~/Desktop/github/test $ lsbar foo new1 new2 tmp1 tmp2huangyisan:~/Desktop/github/test $ git clean -nWould remove new1Would remove new2huangyisan:~/Desktop/github/test $ git clean -f new1Removing new1huangyisan:~/Desktop/github/test $ git clean -df tmp1Removing tmp1/huangyisan:~/Desktop/github/test $ lsbar foo new2 tmp2huangyisan:~/Desktop/github/test $ git clean -fRemoving new2huangyisan:~/Desktop/github/test $ lsbar foo tmp2huangyisan:~/Desktop/github/test $ git clean -dfRemoving tmp2/huangyisan:~/Desktop/github/test $ lsbar foo git clean -n，干跑模式，可以列出哪些文件会被清除，但不会列出哪些目录会被清除。git clean -f，若指定文件，则该文件被清除，若不指定文件，则所有未被提交到暂存区的文件都被清除。git clean -df，若指定目录，则该目录被清除，若不指定目录，则所有未被提交到暂存区的目录都被清除。 git rmgit rm等价于rm xxx &amp;&amp; git add .。如果一个文件是被rm删除，则可以使用git checkout -- file将文件还原回来，而如果是用git rm删除，则该文件不可以被git checkout -- file。当然，如果是rm文件，然后git add操作，也是不能被git checkout -- file还原回来的。123456789101112131415huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ rm fooremove foo? yhuangyisan:~/Desktop/github/test $ lsbarhuangyisan:~/Desktop/github/test $ git checkout foohuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git rm foorm &apos;foo&apos;huangyisan:~/Desktop/github/test $ git checkout fooerror: pathspec &apos;foo&apos; did not match any file(s) known to git.huangyisan:~/Desktop/github/test $ lsbar foo文件起先被rm删除，并未提交到暂存区，所以是可以被checkout还原，后来执行了git rm，所以当使用checkout还原的时候就报错了。 git reset三种模式 –mixed 默认方式，将暂存区内容清空，回退到工作区，并且保留工作区的修改内容。 1234567891011121314151617181920212223242526272829huangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git reset HEADUnstaged changes after reset:M foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foono changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 暂存区被清空，工作区的更变被保留下来，foo文件存在new line这行内容。 –soft 暂存区内容，工作区内容都被保留，HEAD指向指定的commit号，该commit号原先的文件若有变动，则直接被add到暂存区。 123456789101112131415161718192021222324252627282930313233343536373839huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foohuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ git log --onelinee5ca64a (HEAD -&gt; master) 10ba0aa5 1ebaa828 1a2f32c5 18f89d40 updatebe60bed 1bb51c34 .df8f824 update4dbd952 update9e683fb 179dfad8 13e58cef add 194e5bf4 remove02aadbb okhuangyisan:~/Desktop/github/test $ git reset --soft 8f89d40huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foonew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: bar new file: foo 将foo的改动add到暂存区后，使用git reset --soft 8f89d40，8f89d40这个commit号原先是存在bar这个文件，且foo文件不存在，因为reset之前的内容和之后的比较出现了差异，则这些差异被add到了新的暂存区中。 –hard HEAD重置到指定commit号，且清空暂存区，工作区的内容和该commit号版本仓库的内容一致。 123456huangyisan:~/Desktop/github/test $ git reset --hard HEADHEAD is now at 14d3892 1huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foofirst line 暂存区被清空，工作区内容成了当前commit号版本仓库的内容，也就是没修改之前的内容，foo文件不存在new line行。但若工作区存在Untracked files，则这些Untracked files会携带进入到指定的commit号版本仓库的工作区中，所以要恢复到和某个commit号完全一致，还需要git clean -f清空Untracked files。 git reset会将HEAD指向的分支指向reset对应的commit，而git checkout是HEAD直接指向对应的commit。 git revert仅将某个commit号提交分支的内容撤销，且将此次撤销作为一个新的提交。 12345678910111213141516171819huangyisan:~/Desktop/github/test $ git log --oneline145af31 (HEAD -&gt; master) add newedf54e3 add fooc11842d add bar5f4b280 remove allhuangyisan:~/Desktop/github/test $ lsbar foo new new1huangyisan:~/Desktop/github/test $ git revert c11842d[master 19e736c] Revert &quot;add bar&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 barhuangyisan:~/Desktop/github/test $ lsfoo new new1huangyisan:~/Desktop/github/test $ git log --oneline19e736c (HEAD -&gt; master) Revert &quot;add bar&quot;145af31 add newedf54e3 add fooc11842d add bar5f4b280 remove all c11842d是将bar文件提交到了分支，当执行git revert c11842d,则撤销了提交bar文件到分支，所以执行完后，bar文件不见了，但foo文件依旧存在，所以revert只影响了被撤销的commit的变更内容，而且看git log，多了一个新的commit提交号19e736c。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getchar()存储类型]]></title>
    <url>%2F2018%2F12%2F20%2Fgetchar-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[getchar()返回类型声明为int类型getchar()函数从文本流读入下一个输入字符，并且作为结果返回。 一个读取字符，并且打印的程序，当读取end of file(EOF)的时候结束。123456789101112#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c != EOF) &#123; putchar(c); c = getchar(); &#125; return 0;&#125; 起先没搞明白为什么对c的声明是int类型，而不是char类型。 后来查阅资料得知，char类型的声明，会根据不同的编译器，或者不同的架构平台，可能成为unsigned char或者是signed char类型。 如果是unsigned char类型，占8位，一个字节，其范围为0000 0000 ~ 1111 1111，即0 ~ 255，那么无法存储EOF这个结束符，EOF可以理解为数值-1(C89, C99, C11并没有给EOF定义一个具体的值，只是说EOF是一个负值常量)。 而当被作为signed char类型，虽然其取值范围为-128 ~ +127，虽然能够存储EOF这个结束符，看似正常，但在linux的环境，会混淆char 255和EOF，导致输入数据的截断。 在linux平台运行以下程序 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char c; printf(&quot;Enter characters : &quot;); while((c= getchar()) != EOF)&#123; putchar(c); &#125; return 0;&#125; 输出结果可以发现\0377后面部分没有被打印。 12[root@VM_31_91_centos ~]# gcc test.c &amp;&amp; echo -e &apos;Hello world\0377And some more&apos; | ./a.outEnter characters : Hello world[root@VM_31_91_centos ~]# getchar()和putchar()初始返回的值都为int类型。对于getchar()函数返回值的声明使用int类型 打印出EOF的值123456789101112131415#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c == EOF) &#123; printf(&quot;this is the value of EOF:%d&quot;,c); c = getchar(); break; &#125; return 0;&#125; 执行程序，按CTRL+D发送EOF，查看得到的数值为-1。 refer https://stackoverflow.com/questions/18013167/why-must-the-variable-used-to-hold-getchars-return-value-be-declared-as-inthttps://stackoverflow.com/questions/35356322/difference-between-int-and-char-in-getchar-fgetc-and-putchar-fputchttps://stackoverflow.com/questions/7119470/int-c-getcharThe C Programming Language - By Kernighan and Ritchie]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新式类的C3 MRO理解]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%96%B0%E5%BC%8F%E7%B1%BB%E7%9A%84C3-MRO%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[新式类python2.3以及之后的版本遵循的原则：C3 MRO 其遵循的原则为：一个类同时继承的类中，如果没有共同父类，则往最左的类的父类查询；如果存在共同父类，则从左到右查询。 自省方法__mro__ 存在共同父类的情况123456789class D(object): passclass E(object): passclass F(object): passclass B(D, E): passclass C(D, F): passclass A(B, C): passprint(A.__mro__)(&lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.E&apos;&gt;, &lt;class &apos;__main__.F&apos;&gt;, &lt;class &apos;object&apos;&gt;) 顺序解释:这边需要注意的是B和C有相同的父类，所以B查询后直接查询的C。 12345678910111213查询关系D --&gt; D,objectE --&gt; E,objectF --&gt; F,objectB --&gt; B, D, E, ...., objectC --&gt; C, D, F, ...., objectA --&gt; A. B, C, ...., object 将B和C带入后得到 --&gt; A, (B, D, E, ..., object), (C,D,F, ..., object) B和C存在共同的父类，D，所以B和C是同一级别，查询顺序是A, B, C, 然后D, --&gt; A, B, C, D (E, ..., object), (F, ..., object) --&gt; A, B, C, D, E, F, object 不存在共同父类的情况123456789101112class g(object): passclass f(object): passclass h(object): passclass i(object): passclass e(object): passclass d(h,i): passclass b(d,e): passclass c(f,g): passclass a(b,c): passprint(a.__mro__)(&lt;class &apos;__main__.a&apos;&gt;, &lt;class &apos;__main__.b&apos;&gt;, &lt;class &apos;__main__.d&apos;&gt;, &lt;class &apos;__main__.h&apos;&gt;, &lt;class &apos;__main__.i&apos;&gt;, &lt;class &apos;__main__.e&apos;&gt;, &lt;class &apos;__main__.c&apos;&gt;, &lt;class &apos;__main__.f&apos;&gt;, &lt;class &apos;__main__.g&apos;&gt;, &lt;class &apos;object&apos;&gt;) 顺序解释：因为b和c不存在相同的父类，所以查询b查不到后直接查询b的父类。 1234567891011121314151617查询关系：g --&gt; g, objectf --&gt; f, objecth --&gt; h, objecti --&gt; i, objecte --&gt; e, objectb --&gt; b, d, e, ..., objectc --&gt; c, f, g, ..., objectd --&gt; d, h, i, ..., objecta --&gt; a, b, c, ..., object 将B和C带入后得到 --&gt; a, (b, d, e, ..., object), (c, f, g, ..., object) 将b带入后得到 --&gt; a, (b, (d, h, i, ..., object), e, ..., object), (c, f, g, ..., object) b和c没有共同的父类，所以直接查询了d，d后，查询他的继承，h，因为h最顶了，所以开始依次返回，查询其平级的i，然后折回到b中右边的e,然后再次返回到a中右边的c，然后查询c中的f,发现到顶了，则查询其平级的g，然后依次退出，发现直接查询完了全部，则查询object。]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[True or False]]></title>
    <url>%2F2018%2F12%2F18%2FTrue-or-False%2F</url>
    <content type="text"><![CDATA[链式比较先来看一段代码: 12&gt;&gt;&gt; 2 in [1,0] == FalseFalse 起先我认为输出的结果是True，因为 2 in [1,0] 为False，接着False == False 返回的是True。 后来发现，这个其实是链式比较(chained comparisons)，这种比较法，常见的为类似1&lt;2&lt;3这种，能立马反应过来，其实质为 1&lt;2 and 2&lt;3。所以2 in [1,0] == False的本质其实为(2 in [1,0]) and ([1,0] == False)，很显然，前面的返回为False，后面的返回也为False，False and False的结果为False，所以最终得到的结果为False。 如下比较符号进行组合，都为链式比较“&lt;” | “&gt;” | “==” | “&gt;=” | “&lt;=” | “&lt;&gt;” | “!=” | “is” [“not”] | [“not”] “in” https://docs.python.org/2/reference/expressions.html#comparisons 空字符串代码如下： 12&gt;&gt;&gt; &quot;&quot; in &quot;abc&quot;True 空字符串始终被视为任何其他字符串的子字符串，所以其返回为True。字符串的比较等价于find()方法，x in y 等价于y.find(x) != -1。当find()执行结果为-1的时候，表示x不是y的子字符串，反之，则x为y的子字符串。空字符串的执行结果如下: 12&gt;&gt;&gt; &quot;abc&quot;.find(&apos;&apos;) != -1True https://docs.python.org/3/reference/expressions.html#membership-test-operations]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
</search>
