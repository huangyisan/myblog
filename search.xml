<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git clean/rm/reset/revert/checkout用法和区别]]></title>
    <url>%2F2018%2F12%2F22%2Fgit-clean-rm-reset-revert-checkout%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git的工作区和暂存区先说下这两个概念：工作区，就是你git仓库的目录，你进行修改文件的区域。暂存区，git从库里面有个.git的隐藏目录，里面”有一块”，可以理解为暂存区。 工作区和缓存区如何联系起来？通过提交代码行为的步骤流程来解读: 修改代码文件 git add 修改后的代码文件 此刻的行为将该代码文件从工作区添加到了暂存区 git commit -m &#39;commit 内容&#39; 此刻的行为把暂存区的内容提交到了本地分支上 最后的git push操作只是一个将本地分支推送到远端的行为，所以先不考虑进去，只考前面三点。 查看工作区和暂存区常用的命令为git status 一般常见的是如下三种情况： 在工作区新建了文件或目录，但还未将这些文件或目录git add提交到暂存区。这些文件或目录被标记为untracked files。 123456789101112huangyisan:~/Desktop/github/test $ touch foo barhuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar foonothing added to commit but untracked files present (use &quot;git add&quot; to track) 对修改后的文件进行了git add操作，将这些文件提交到了暂存区，但未执行git commit -m &#39;xxx&#39;，未提交到本地分支。此时文件属于Changes to be committed状态 123456789101112huangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 对已经git add操作，但未提交到本地分支的文件，继续进行了修改，修改完后未进行git add，此时文件属于Changes not staged for commit状态 123456789101112131415161718huangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: fooUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) bar 已经commit到本地分支的文件，且该文件在工作区没被修改之前，其不会在git status中出现。 git checkout – file两种情况 若被checkout的文件在暂存区，但工作区修改了，也就是上面的第三种情况，此时执行该命令，被checkout的文件变成和暂存区一样的状态和内容。12345678910111213141516171819202122232425262728293031huangyisan:~/Desktop/github/test $ echo &apos;first line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: fooChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foohuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 将foo文件写入’first line’内容后，用git add foo，提交到了暂存区，未commit情况下，再写入新内容’new line’,若想还原到暂存区状态，则使用命令git checkout -- foo 被修改文件不在暂存区，此时使用git checkout -- file命令，则该文件和当前版本仓库中原先的文件一致。123456789101112huangyisan:~/Desktop/github/test $ git statusOn branch masternothing to commit, working tree cleanhuangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git checkout -- foohuangyisan:~/Desktop/github/test $ cat foofirst line 干净的工作区，修改了foo文件，然后进行checkout操作之后，foo文件还原成了仓库中该文件原先的状态和内容。 git cleangit clean 的对象为untracked files，也就是在工作区新建，但还未执行git add命令提交到暂存区的文件或目录。1234567891011121314151617181920212223huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ touch new1 new2huangyisan:~/Desktop/github/test $ mkdir &#123;tmp1,tmp2&#125;huangyisan:~/Desktop/github/test $ lsbar foo new1 new2 tmp1 tmp2huangyisan:~/Desktop/github/test $ git clean -nWould remove new1Would remove new2huangyisan:~/Desktop/github/test $ git clean -f new1Removing new1huangyisan:~/Desktop/github/test $ git clean -df tmp1Removing tmp1/huangyisan:~/Desktop/github/test $ lsbar foo new2 tmp2huangyisan:~/Desktop/github/test $ git clean -fRemoving new2huangyisan:~/Desktop/github/test $ lsbar foo tmp2huangyisan:~/Desktop/github/test $ git clean -dfRemoving tmp2/huangyisan:~/Desktop/github/test $ lsbar foo git clean -n，干跑模式，可以列出哪些文件会被清除，但不会列出哪些目录会被清除。git clean -f，若指定文件，则该文件被清除，若不指定文件，则所有未被提交到暂存区的文件都被清除。git clean -df，若指定目录，则该目录被清除，若不指定目录，则所有未被提交到暂存区的目录都被清除。 git rmgit rm等价于rm xxx &amp;&amp; git add .。如果一个文件是被rm删除，则可以使用git checkout -- file将文件还原回来，而如果是用git rm删除，则该文件不可以被git checkout -- file。当然，如果是rm文件，然后git add操作，也是不能被git checkout -- file还原回来的。123456789101112131415huangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ rm fooremove foo? yhuangyisan:~/Desktop/github/test $ lsbarhuangyisan:~/Desktop/github/test $ git checkout foohuangyisan:~/Desktop/github/test $ lsbar foohuangyisan:~/Desktop/github/test $ git rm foorm &apos;foo&apos;huangyisan:~/Desktop/github/test $ git checkout fooerror: pathspec &apos;foo&apos; did not match any file(s) known to git.huangyisan:~/Desktop/github/test $ lsbar foo文件起先被rm删除，并未提交到暂存区，所以是可以被checkout还原，后来执行了git rm，所以当使用checkout还原的时候就报错了。 git reset三种模式 –mixed 默认方式，将暂存区内容清空，回退到工作区，并且保留工作区的修改内容。 1234567891011121314151617181920212223242526272829huangyisan:~/Desktop/github/test $ cat foofirst linehuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt;&gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git reset HEADUnstaged changes after reset:M foohuangyisan:~/Desktop/github/test $ cat foofirst linenew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foono changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 暂存区被清空，工作区的更变被保留下来，foo文件存在new line这行内容。 –soft 暂存区内容，工作区内容都被保留，HEAD指向指定的commit号，该commit号原先的文件若有变动，则直接被add到暂存区。 123456789101112131415161718192021222324252627282930313233343536373839huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foohuangyisan:~/Desktop/github/test $ echo &apos;new line&apos; &gt; foohuangyisan:~/Desktop/github/test $ git add foohuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: foohuangyisan:~/Desktop/github/test $ git log --onelinee5ca64a (HEAD -&gt; master) 10ba0aa5 1ebaa828 1a2f32c5 18f89d40 updatebe60bed 1bb51c34 .df8f824 update4dbd952 update9e683fb 179dfad8 13e58cef add 194e5bf4 remove02aadbb okhuangyisan:~/Desktop/github/test $ git reset --soft 8f89d40huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foonew linehuangyisan:~/Desktop/github/test $ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: bar new file: foo 将foo的改动add到暂存区后，使用git reset --soft 8f89d40，8f89d40这个commit号原先是存在bar这个文件，且foo文件不存在，因为reset之前的内容和之后的比较出现了差异，则这些差异被add到了新的暂存区中。 –hard HEAD重置到指定commit号，且清空暂存区，工作区的内容和该commit号版本仓库的内容一致。 123456huangyisan:~/Desktop/github/test $ git reset --hard HEADHEAD is now at 14d3892 1huangyisan:~/Desktop/github/test $ lsfoohuangyisan:~/Desktop/github/test $ cat foofirst line 暂存区被清空，工作区内容成了当前commit号版本仓库的内容，也就是没修改之前的内容，foo文件不存在new line行。但若工作区存在Untracked files，则这些Untracked files会携带进入到指定的commit号版本仓库的工作区中，所以要恢复到和某个commit号完全一致，还需要git clean -f清空Untracked files。 git revert仅将某个commit号提交分支的内容撤销，且将此次撤销作为一个新的提交。 12345678910111213141516171819huangyisan:~/Desktop/github/test $ git log --oneline145af31 (HEAD -&gt; master) add newedf54e3 add fooc11842d add bar5f4b280 remove allhuangyisan:~/Desktop/github/test $ lsbar foo new new1huangyisan:~/Desktop/github/test $ git revert c11842d[master 19e736c] Revert &quot;add bar&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 barhuangyisan:~/Desktop/github/test $ lsfoo new new1huangyisan:~/Desktop/github/test $ git log --oneline19e736c (HEAD -&gt; master) Revert &quot;add bar&quot;145af31 add newedf54e3 add fooc11842d add bar5f4b280 remove all c11842d是将bar文件提交到了分支，当执行git revert c11842d,则撤销了提交bar文件到分支，所以执行完后，bar文件不见了，但foo文件依旧存在，所以revert只影响了被撤销的commit的变更内容，而且看git log，多了一个新的commit提交号19e736c。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getchar()存储类型]]></title>
    <url>%2F2018%2F12%2F20%2Fgetchar-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[getchar()返回类型声明为int类型getchar()函数从文本流读入下一个输入字符，并且作为结果返回。 一个读取字符，并且打印的程序，当读取end of file(EOF)的时候结束。123456789101112#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c != EOF) &#123; putchar(c); c = getchar(); &#125; return 0;&#125; 起先没搞明白为什么对c的声明是int类型，而不是char类型。 后来查阅资料得知，char类型的声明，会根据不同的编译器，或者不同的架构平台，可能成为unsigned char或者是signed char类型。 如果是unsigned char类型，占8位，一个字节，其范围为0000 0000 ~ 1111 1111，即0 ~ 255，那么无法存储EOF这个结束符，EOF可以理解为数值-1(C89, C99, C11并没有给EOF定义一个具体的值，只是说EOF是一个负值常量)。 而当被作为signed char类型，虽然其取值范围为-128 ~ +127，虽然能够存储EOF这个结束符，看似正常，但在linux的环境，会混淆char 255和EOF，导致输入数据的截断。 在linux平台运行以下程序 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char c; printf(&quot;Enter characters : &quot;); while((c= getchar()) != EOF)&#123; putchar(c); &#125; return 0;&#125; 输出结果可以发现\0377后面部分没有被打印。 12[root@VM_31_91_centos ~]# gcc test.c &amp;&amp; echo -e &apos;Hello world\0377And some more&apos; | ./a.outEnter characters : Hello world[root@VM_31_91_centos ~]# getchar()和putchar()初始返回的值都为int类型。对于getchar()函数返回值的声明使用int类型 打印出EOF的值123456789101112131415#include &lt;stdio.h&gt;int main (void)&#123; int c; c = getchar(); while (c == EOF) &#123; printf(&quot;this is the value of EOF:%d&quot;,c); c = getchar(); break; &#125; return 0;&#125; 执行程序，按CTRL+D发送EOF，查看得到的数值为-1。 refer https://stackoverflow.com/questions/18013167/why-must-the-variable-used-to-hold-getchars-return-value-be-declared-as-inthttps://stackoverflow.com/questions/35356322/difference-between-int-and-char-in-getchar-fgetc-and-putchar-fputchttps://stackoverflow.com/questions/7119470/int-c-getcharThe C Programming Language - By Kernighan and Ritchie]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[True or False]]></title>
    <url>%2F2018%2F12%2F18%2FTrue-or-False%2F</url>
    <content type="text"><![CDATA[链式比较先来看一段代码: 12&gt;&gt;&gt; 2 in [1,0] == FalseFalse 起先我认为输出的结果是True，因为 2 in [1,0] 为False，接着False == False 返回的是True。 后来发现，这个其实是链式比较(chained comparisons)，这种比较法，常见的为类似1&lt;2&lt;3这种，能立马反应过来，其实质为 1&lt;2 and 2&lt;3。所以2 in [1,0] == False的本质其实为(2 in [1,0]) and ([1,0] == False)，很显然，前面的返回为False，后面的返回也为False，False and False的结果为False，所以最终得到的结果为False。 如下比较符号进行组合，都为链式比较“&lt;” | “&gt;” | “==” | “&gt;=” | “&lt;=” | “&lt;&gt;” | “!=” | “is” [“not”] | [“not”] “in” https://docs.python.org/2/reference/expressions.html#comparisons 空字符串代码如下： 12&gt;&gt;&gt; &quot;&quot; in &quot;abc&quot;True 空字符串始终被视为任何其他字符串的子字符串，所以其返回为True。字符串的比较等价于find()方法，x in y 等价于y.find(x) != -1。当find()执行结果为-1的时候，表示x不是y的子字符串，反之，则x为y的子字符串。空字符串的执行结果如下: 12&gt;&gt;&gt; &quot;abc&quot;.find(&apos;&apos;) != -1True https://docs.python.org/3/reference/expressions.html#membership-test-operations]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
